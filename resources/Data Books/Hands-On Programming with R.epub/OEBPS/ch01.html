<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 1. The Very Basics</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt01.html" title="Part I. Project 1: Weighted Dice"/><link rel="prev" href="pt01.html" title="Part I. Project 1: Weighted Dice"/><link rel="next" href="ch02.html" title="Chapter 2. Packages and Help Pages"/></head><body><section class="chapter" title="Chapter 1. The Very Basics" epub:type="chapter" id="BASICS"><div class="titlepage"><div><div><h2 class="title">Chapter 1. The Very Basics</h2></div></div></div><p>This chapter provides a broad overview of the R language that will get you programming right away. In it, you will build a pair of virtual dice that you can use to generate random numbers. Don’t worry if you’ve never programmed before; the chapter will teach you everything you need to know.</p><p>To simulate a pair of dice, you will have to distill each die into its essential features. You cannot place a physical object, like a die, into a computer (well, not without unscrewing some screws), but you can save <span class="emphasis"><em>information</em></span> about the object in your computer’s memory.</p><p>Which information should you save? In general, a die has six important pieces of information: when you roll a die, it can only result in one of six numbers: 1, 2, 3, 4, 5, and 6. You can capture the essential characteristics of a die by saving the numbers 1, 2, 3, 4, 5, and 6 as a group of values in your computer’s memory.</p><p>Let’s work on saving these numbers first and then consider a method for “rolling” our die.</p><div class="sect1" title="The R User Interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_the_r_user_interface">The R User Interface</h2></div></div></div><p>Before you can ask your computer to save some numbers, you’ll need to know how to talk to it. That’s where R and RStudio come in. RStudio gives you a way to talk to your computer. R gives you a language to speak in. To get started, open RStudio just as you would open any other application on your computer. When you do, a window should appear in your screen like the one shown in <a class="xref" href="ch01.html#FIGURE-CONSOLE" title="Figure 1-1. Your computer does your bidding when you type R commands at the prompt in the bottom line of the console pane. Don’t forget to hit the Enter key. When you first open RStudio, the console appears in the pane on your left, but you can change this with File &gt; Preferences in the menu bar.">Figure 1-1</a>.<a id="id449363" class="indexterm"/></p><div class="figure"><a id="FIGURE-CONSOLE"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0101.png.jpg" alt="The R console pane in RStudio"/></div></div><div class="figure-title">Figure 1-1. Your computer does your bidding when you type R commands at the prompt in the bottom line of the console pane. Don’t forget to hit the Enter key. When you first open RStudio, the console appears in the pane on your left, but you can change this with File &gt; Preferences in the menu bar.</div></div><div class="tip" title="Tip"><h3 class="title">Tip</h3><p>If you do not yet have R and RStudio intalled on your computer—or do not know what I am talking about—visit <a class="xref" href="apa.html" title="Appendix A. Installing R and RStudio">Appendix A</a>. The appendix will give you an overview of the two free tools and tell you how to download them.</p></div><p>The RStudio interface is simple. You type R code into the bottom line of the RStudio console pane and then click Enter to run it. The code you type is called a <span class="emphasis"><em>command</em></span>, because it will command your computer to do something for you. The line you type it into is called the <span class="emphasis"><em>command line</em></span>.<a id="id451610" class="indexterm"/><a id="id469062" class="indexterm"/><a id="id367031" class="indexterm"/></p><p>When you type a command at the prompt and hit Enter, your computer executes the command and shows you the results. Then RStudio displays a fresh prompt for your next command. For example, if you type <code class="literal">1 + 1</code> and hit Enter, RStudio will display:</p><pre class="programlisting"><code class="o">&gt;</code> <code class="m">1</code> <code class="o">+</code> <code class="m">1</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="m">2</code>
<code class="o">&gt;</code></pre><p>You’ll notice that a <code class="literal">[1]</code> appears next to your result. R is just letting you know that this line begins with the first value in your result. Some commands return more than one value, and their results may fill up multiple lines. For example, the command <code class="literal">100:130</code> returns 31 values; it creates a sequence of integers from 100 to 130. Notice that new bracketed numbers appear at the start of the second and third lines of output. These numbers just mean that the second line begins with the 14th value in the result, and the third line begins with the 25th value. You can mostly ignore the numbers that appear in brackets:</p><pre class="programlisting"><code class="o">&gt;</code> <code class="m">100</code><code class="o">:</code><code class="m">130</code> <a id="CO1-1"/><img src="callouts/1.png" alt="1"/>
 <code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="m">100</code> <code class="m">101</code> <code class="m">102</code> <code class="m">103</code> <code class="m">104</code> <code class="m">105</code> <code class="m">106</code> <code class="m">107</code> <code class="m">108</code> <code class="m">109</code> <code class="m">110</code> <code class="m">111</code> <code class="m">112</code>
<code class="p">[</code><code class="m">14</code><code class="p">]</code> <code class="m">113</code> <code class="m">114</code> <code class="m">115</code> <code class="m">116</code> <code class="m">117</code> <code class="m">118</code> <code class="m">119</code> <code class="m">120</code> <code class="m">121</code> <code class="m">122</code> <code class="m">123</code> <code class="m">124</code> <code class="m">125</code>
<code class="p">[</code><code class="m">25</code><code class="p">]</code> <code class="m">126</code> <code class="m">127</code> <code class="m">128</code> <code class="m">129</code> <code class="m">130</code></pre><div class="calloutlist"><dl><dt><a href="#CO1-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
The colon operator (<code class="literal">+</code>) returns every integer between two integers. It is an easy way to create a sequence of numbers.<a id="id491998" class="indexterm"/><a id="id465934" class="indexterm"/><a id="id465940" class="indexterm"/>
</p></dd></dl></div><div class="tip" title="Isn’t R a language?"><h3 class="title">Isn’t R a language?</h3><p>You may hear me speak of R in the third person. For example, I might say, “Tell R to do this” or “Tell R to do that”, but of course R can’t do anything; it is just a language. This way of speaking is shorthand for saying, “Tell your computer to do this by writing a command in the R language at the command line of your RStudio console.” Your computer, and not R, does the actual work.<a id="id474895" class="indexterm"/></p><p>Is this shorthand confusing and slightly lazy to use? Yes. Do a lot of people use it? Everyone I know—probably because it is so convenient.</p></div><div class="tip" title="When do we compile?"><h3 class="title">When do we compile?</h3><p>In some languages, like C, Java, and FORTRAN, you have to compile your human-readable code into machine-readable code (often 1s and 0s) before you can run it. If you’ve programmed in such a language before, you may wonder whether you have to compile your R code before you can use it. The answer is no. R is a dynamic programming language, which means R automatically interprets your code as you run it.<a id="id448730" class="indexterm"/><a id="id448722" class="indexterm"/><a id="id487884" class="indexterm"/><a id="id487890" class="indexterm"/><a id="id440872" class="indexterm"/></p></div><p>If you type an incomplete command and press Enter, R will display a + prompt, which means it is waiting for you to type the rest of your command. Either finish the command or hit Escape to start over:<a id="id386550" class="indexterm"/></p><pre class="programlisting"><code class="o">&gt;</code> <code class="m">5</code> <code class="o">-</code>
<code class="o">+</code>
<code class="o">+</code> <code class="m">1</code>
<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="m">4</code></pre><p>If you type a command that R doesn’t recognize, R will return an error message. If you ever see an error message, don’t panic. R is just telling you that your computer couldn’t understand or do what you asked it to do. You can then try a different command at the next prompt:<a id="id389147" class="indexterm"/><a id="id430968" class="indexterm"/></p><pre class="programlisting"><code class="o">&gt;</code> <code class="m">3</code> <code class="o">% 5</code>
<code class="o">Error: unexpected input in "3 %</code> <code class="m">5</code><code class="s">"</code>
<code class="o">&gt;</code></pre><p>Once you get the hang of the command line, you can easily do anything in R that you would do with a calculator.<a id="id491484" class="indexterm"/><a id="id442950" class="indexterm"/> For example, you could do some basic arithmetic:</p><pre class="programlisting"><code class="m">2</code> <code class="o">*</code> <code class="m">3</code>
<code class="c1">## 6</code>

<code class="m">4</code> <code class="o">-</code> <code class="m">1</code>
<code class="c1">## 3</code>

<code class="m">6</code> <code class="o">/</code> <code class="p">(</code><code class="m">4</code> <code class="o">-</code> <code class="m">1</code><code class="p">)</code>
<code class="c1">## 2</code></pre><p>Did you notice something different about this code? I’ve left out the <code class="literal">&gt;</code>’s and <code class="literal">[1]</code>’s. This will make the code easier to copy and paste if you want to put it in your own console.<a id="id494862" class="indexterm"/><a id="id494868" class="indexterm"/></p><p>R treats the hashtag character, <code class="literal">#</code>, in a special way; R will not run anything that follows a hashtag on a line. This makes hashtags very useful for adding comments and annotations to your code. Humans will be able to read the comments, but your computer will pass over them. The hashtag is known as the <span class="emphasis"><em>commenting symbol</em></span> in R.<a id="id480544" class="indexterm"/><a id="id387252" class="indexterm"/><a id="id387258" class="indexterm"/></p><p>For the remainder of the book, I’ll use hashtags to display the output of R code. I’ll use a single hashtag to add my own comments and a double hashtag, <code class="literal">##</code>, to display the results of code. I’ll avoid showing <code class="literal">&gt;</code>s and <code class="literal">[1]</code>s unless I want you to look at them.<a id="id384946" class="indexterm"/><a id="id384951" class="indexterm"/></p><div class="tip" title="Cancelling commands"><h3 class="title">Cancelling commands</h3><p>Some R commands may take a long time to run. You can cancel a command once it has begun by typing <code class="literal">ctrl + c</code>. Note that it may also take R a long time to cancel the command.<a id="id491704" class="indexterm"/><a id="id505875" class="indexterm"/></p></div><div class="sidebar"><div class="sidebar-title">Exercise</div><p>That’s the basic interface for executing R code in RStudio. Think you have it? If so, try doing these simple tasks. If you execute everything correctly, you should end up with the same number that you started with:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Choose any number and add 2 to it.
</li><li class="listitem">
Multiply the result by 3.
</li><li class="listitem">
Subtract 6 from the answer.
</li><li class="listitem">
Divide what you get by 3.
</li></ol></div></div><p>Throughout the book, I’ll put exercises in boxes, like the one just mentioned. I’ll follow each exercise with a model answer, like the one that follows.</p><p>You could start with the number 10, and then do the preceding steps:</p><pre class="programlisting"><code class="m">10</code> <code class="o">+</code> <code class="m">2</code>
<code class="c1">## 12</code>

<code class="m">12</code> <code class="o">*</code> <code class="m">3</code>
<code class="c1">## 36</code>

<code class="m">36</code> <code class="o">-</code> <code class="m">6</code>
<code class="c1">## 30</code>

<code class="m">30</code> <code class="o">/</code> <code class="m">3</code>
<code class="c1">## 10</code></pre><p>Now that you know how to use R, let’s use it to make a virtual die. The <code class="literal">:</code> operator from a couple of pages ago gives you a nice way to create a group of numbers from one to six. The <code class="literal">:</code> operator returns its results as a <span class="emphasis"><em>vector</em></span>, a one-dimensional set of numbers:<a id="id442676" class="indexterm"/><a id="id383784" class="indexterm"/><a id="id476835" class="indexterm"/><a id="id384748" class="indexterm"/><a id="id452061" class="indexterm"/><a id="id452070" class="indexterm"/></p><pre class="programlisting"><code class="m">1</code><code class="o">:</code><code class="m">6</code>
<code class="c1">## 1 2 3 4 5 6</code></pre><p>That’s all there is to how a virtual die looks! But you are not done yet. Running <code class="literal">1:6</code> generated a vector of numbers for you to see, but it didn’t save that vector anywhere in your computer’s memory. What you are looking at is basically the footprints of six numbers that existed briefly and then melted back into your computer’s RAM. If you want to use those numbers again, you’ll have to ask your computer to save them somewhere. You can do that by creating an R <span class="emphasis"><em>object</em></span>.</p></div><div class="sect1" title="Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_objects">Objects</h2></div></div></div><p>R lets you save data by storing it inside an R object.<a id="id458145" class="indexterm"/><a id="id377374" class="indexterm"/> What’s an object? Just a name that you can use to call up stored data. For example, you can save data into an object like <span class="emphasis"><em><code class="literal">a</code></em></span> or <span class="emphasis"><em><code class="literal">b</code></em></span>. Wherever R encounters the object, it will replace it with the data saved inside, like so:</p><pre class="programlisting">a <code class="o">&lt;-</code> <code class="m">1</code> <a id="CO2-1"/><img src="callouts/1.png" alt="1"/>
a <a id="CO2-2"/><img src="callouts/2.png" alt="2"/>
<code class="c1">## 1</code>

a <code class="o">+</code> <code class="m">2</code> <a id="CO2-3"/><img src="callouts/3.png" alt="3"/>
<code class="c1">## 3</code></pre><div class="calloutlist"><dl><dt><a href="#CO2-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
To create an R object, choose a name and then use the less-than symbol, <code class="literal">&lt;</code>, followed by a minus sign, <code class="literal">-</code>, to save data into it. This combination looks like an arrow, <code class="literal">&lt;-</code>. R will make an object, give it your name, and store in it whatever follows the arrow.<a id="id438048" class="indexterm"/>
</p></dd><dt><a href="#CO2-2"><img src="callouts/2.png" alt="2"/></a> </dt><dd><p>
When you ask R what’s in <code class="literal">a</code>, it tells you on the next line.
</p></dd><dt><a href="#CO2-3"><img src="callouts/3.png" alt="3"/></a> </dt><dd><p>
You can use your object in new R commands, too. Since <code class="literal">a</code> previously stored the value of 1, you’re now adding 1 to 2.
</p></dd></dl></div><p>So, for another example, the following code would create an object named <code class="literal">die</code> that contains the numbers one through six. To see what is stored in an object, just type the object’s name by itself:<a id="id470990" class="indexterm"/></p><pre class="programlisting">die <code class="o">&lt;-</code> <code class="m">1</code><code class="o">:</code><code class="m">6</code>

die
<code class="c1">## 1 2 3 4 5 6</code></pre><p>When you create an object, the object will appear in the environment pane of RStudio, as shown in <a class="xref" href="ch01.html#FIGURE-ENVIRONMENT" title="Figure 1-2. The RStudio environment pane keeps track of the R objects you create.">Figure 1-2</a>. This pane will show you all of the objects you’ve created since opening RStudio.<a id="id452364" class="indexterm"/><a id="id451421" class="indexterm"/></p><div class="figure"><a id="FIGURE-ENVIRONMENT"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0102.png.jpg" alt="The environment pane in RStudio"/></div></div><div class="figure-title">Figure 1-2. The RStudio environment pane keeps track of the R objects you create.</div></div><p>You can name an object in R almost anything you want, but there are a few rules.<a id="id431014" class="indexterm"/><a id="id387736" class="indexterm"/><a id="id387741" class="indexterm"/> First, a name cannot start with a number. Second, a name cannot use some special symbols, like <code class="literal">^</code>, <code class="literal">!</code>, <code class="literal">$</code>, <code class="literal">@</code>, <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">/</code>, or <code class="literal">*</code>:<a id="id480992" class="indexterm"/></p><div class="informaltable"><table style="width: 80%; border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Good names</td><td style="border-bottom: 0.5pt solid ; ">Names that cause errors</td></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">a</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">1trial</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">b</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">$</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">FOO</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">^mean</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">my_var</code></p></td><td style="border-bottom: 0.5pt solid ; "><p><code class="literal">2nd</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">.day</code></p></td><td><p><code class="literal">!bad</code></p></td></tr></tbody></table></div><div class="warning" title="Warning" epub:type="warning"><h3 class="title">Warning</h3><p>R also understands capitalization (or is case-sensitive), so <code class="literal">name</code> and <code class="literal">Name</code> will refer to different objects:<a id="id450368" class="indexterm"/><a id="id363239" class="indexterm"/></p><pre class="programlisting">Name <code class="o">&lt;-</code> <code class="m">1</code>
name <code class="o">&lt;-</code> <code class="m">0</code>

Name <code class="o">+</code> <code class="m">1</code>
<code class="c1">## 2</code></pre></div><p>Finally, R will overwrite any previous information stored in an object without asking you for permission. So, it is a good idea to <span class="emphasis"><em>not</em></span> use names that are already taken:</p><pre class="programlisting">my_number <code class="o">&lt;-</code> <code class="m">1</code>
my_number
<code class="c1">## 1</code>

my_number <code class="o">&lt;-</code> <code class="m">999</code>
my_number
<code class="c1">## 999</code></pre><p>You can see which object names you have already used with the function <code class="literal">ls</code>:<a id="id498991" class="indexterm"/><a id="id447438" class="indexterm"/><a id="id447444" class="indexterm"/></p><pre class="screen">ls()
## "a"         "die"       "my_number" "name"     "Name"</pre><p>You can also see which names you have used by examining RStudio’s environment pane.<a id="id488866" class="indexterm"/><a id="id488872" class="indexterm"/></p><p>You now have a virtual die that is stored in your computer’s memory. You can access it whenever you like by typing the word <span class="strong"><strong><code class="literal">die</code></strong></span>. So what can you do with this die? Quite a lot. R will replace an object with its contents whenever the object’s name appears in a command. So, for example, you can do all sorts of math with the die. Math isn’t so helpful for rolling dice, but manipulating sets of numbers will be your stock and trade as a data scientist.<a id="id459938" class="indexterm"/><a id="id464922" class="indexterm"/><a id="id384962" class="indexterm"/> So let’s take a look at how to do that:</p><pre class="programlisting">die <code class="o">-</code> <code class="m">1</code>
<code class="c1">## 0 1 2 3 4 5</code>

die <code class="o">/</code> <code class="m">2</code>
<code class="c1">## 0.5 1.0 1.5 2.0 2.5 3.0</code>

die <code class="o">*</code> die
<code class="c1">## 1  4  9 16 25 36</code></pre><p>If you are a big fan of linear algebra (and who isn’t?), you may notice that R does not always follow the rules of matrix multiplication. Instead, R uses <span class="emphasis"><em>element-wise execution</em></span>. When you manipulate a set of numbers, R will apply the same operation to each element in the set. So for example, when you run <span class="strong"><strong><code class="literal">die - 1</code></strong></span>, R subtracts one from each element of <code class="literal">die</code>.<a id="id469137" class="indexterm"/><a id="id469144" class="indexterm"/><a id="id492760" class="indexterm"/><a id="id492766" class="indexterm"/></p><p>When you use two or more vectors in an operation, R will line up the vectors and perform a sequence of individual operations. For example, when you run <span class="strong"><strong><code class="literal">die * die</code></strong></span>, R lines up the two <code class="literal">die</code> vectors and then multiplies the first element of vector 1 by the first element of vector 2. It then multiplies the second element of vector 1 by the second element of vector 2, and so on, until every element has been multiplied. The result will be a new vector the same length as the first two, as shown in <a class="xref" href="ch01.html#FIGURE-LANGUAGE-ELEMENT-WISE" title="Figure 1-3. When R performs element-wise execution, it matches up vectors and then manipulates each pair of elements independently.">Figure 1-3</a>.<a id="id427462" class="indexterm"/></p><div class="figure"><a id="FIGURE-LANGUAGE-ELEMENT-WISE"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0103.png.jpg" alt="Element-wise execution"/></div></div><div class="figure-title">Figure 1-3. When R performs element-wise execution, it matches up vectors and then manipulates each pair of elements independently.</div></div><p>If you give R two vectors of unequal lengths, R will repeat the shorter vector until it is as long as the longer vector, and then do the math, as shown in <a class="xref" href="ch01.html#FIGURE-LANGUAGE-RECYCLE" title="Figure 1-4. R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.">Figure 1-4</a>. This isn’t a permanent change—the shorter vector will be its original size after R does the math. If the length of the short vector does not divide evenly into the length of the long vector, R will return a warning message.<a id="id363190" class="indexterm"/><a id="id388608" class="indexterm"/> This behavior is known as <span class="emphasis"><em>vector recycling</em></span>, and it helps R do element-wise operations:</p><pre class="programlisting"><code class="m">1</code><code class="o">:</code><code class="m">2</code>
<code class="c1">## 1 2</code>

<code class="m">1</code><code class="o">:</code><code class="m">4</code>
<code class="c1">## 1 2 3 4</code>

die
<code class="c1">## 1 2 3 4 5 6</code>

die <code class="o">+</code> <code class="m">1</code><code class="o">:</code><code class="m">2</code>
<code class="c1">## 2 4 4 6 6 8</code>

die <code class="o">+</code> <code class="m">1</code><code class="o">:</code><code class="m">4</code>
<code class="c1">## 2 4 6 8 6 8</code>
Warning message<code class="o">:</code>
In die <code class="o">+</code> <code class="m">1</code><code class="o">:</code><code class="m">4</code> <code class="o">:</code>
  longer object length is not a multiple of shorter object length</pre><div class="figure"><a id="FIGURE-LANGUAGE-RECYCLE"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0104.png.jpg" alt="Vector recycling"/></div></div><div class="figure-title">Figure 1-4. R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.</div></div><p>Element-wise operations are a very useful feature in R because they manipulate groups of values in an orderly way. When you start working with data sets, element-wise operations will ensure that values from one observation or case are only paired with values from the same observation or case. Element-wise operations also make it easier to write your own programs and functions in R.</p><p>But don’t think that R has given up on traditional matrix multiplication.<a id="id435540" class="indexterm"/><a id="id451271" class="indexterm"/><a id="id451277" class="indexterm"/>  You just have to ask for it when you want it. You can do inner multiplication with the <code class="literal">%*%</code> operator and outer multiplication with the <code class="literal">%o%</code> operator:</p><pre class="programlisting">die <code class="o">%*%</code> die
<code class="c1">## 91</code>

die <code class="o">%o%</code> die
<code class="c1">##      [,1] [,2] [,3] [,4] [,5] [,6]</code>
<code class="c1">## [1,]    1    2    3    4    5    6</code>
<code class="c1">## [2,]    2    4    6    8   10   12</code>
<code class="c1">## [3,]    3    6    9   12   15   18</code>
<code class="c1">## [4,]    4    8   12   16   20   24</code>
<code class="c1">## [5,]    5   10   15   20   25   30</code>
<code class="c1">## [6,]    6   12   18   24   30   36</code></pre><p>You can also do things like transpose a matrix with <code class="literal">t</code> and take its determinant with <code class="literal">det</code>.</p><p>Don’t worry if you’re not familiar with these operations. They are easy to look up, and you won’t need them for this book.</p><p>Now that you can do math with your <code class="literal">die</code> object, let’s look at how you could “roll” it. Rolling your die will require something more sophisticated than basic arithmetic; you’ll need to randomly select one of the die’s values. And for that, you will need a <span class="emphasis"><em>function</em></span>.</p></div><div class="sect1" title="Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_functions">Functions</h2></div></div></div><p>R comes with many functions that you can use to do sophisticated tasks like random sampling. For example, you can round a number with the <code class="literal">round</code> function, or calculate its factorial with the <code class="literal">factorial</code> function. Using a function is pretty simple.<a id="id447471" class="indexterm"/><a id="id490178" class="indexterm"/><a id="id490184" class="indexterm"/><a id="id435117" class="indexterm"/><a id="id435126" class="indexterm"/> Just write the name of the function and then the data you want the function to operate on in parentheses:</p><pre class="programlisting">round<code class="p">(</code><code class="m">3.1415</code><code class="p">)</code>
<code class="c1">## 3</code>

factorial<code class="p">(</code><code class="m">3</code><code class="p">)</code>
<code class="c1">## 6</code></pre><p>The data that you pass into the function is called the function’s <span class="emphasis"><em>argument</em></span>. The argument can be raw data, an R object, or even the results of another R function.<a id="id387671" class="indexterm"/><a id="id387679" class="indexterm"/> In this last case, R will work from the innermost function to the outermost, as in <a class="xref" href="ch01.html#FIGURE-PEMDAS" title="Figure 1-5. When you link functions together, R will resolve them from the innermost operation to the outermost. Here R first looks up die, then calculates the mean of one through six, then rounds the mean.">Figure 1-5</a>:</p><pre class="programlisting">mean<code class="p">(</code><code class="m">1</code><code class="o">:</code><code class="m">6</code><code class="p">)</code>
<code class="c1">## 3.5</code>

mean<code class="p">(</code>die<code class="p">)</code>
<code class="c1">## 3.5</code>

round<code class="p">(</code>mean<code class="p">(</code>die<code class="p">))</code>
<code class="c1">## 4</code></pre><p>Lucky for us, there is an R function that can help “roll” the die. You can simulate a roll of the die with R’s <code class="literal">sample</code> function. <code class="literal">sample</code> takes <span class="emphasis"><em>two</em></span> arguments: a vector named <code class="literal">x</code> and a number named <code class="literal">size</code>. <code class="literal">sample</code> will return <code class="literal">size</code> elements from the vector:<a id="id385932" class="indexterm"/><a id="id385940" class="indexterm"/><a id="id380737" class="indexterm"/><a id="id369786" class="indexterm"/></p><pre class="programlisting">sample<code class="p">(</code>x <code class="o">=</code> <code class="m">1</code><code class="o">:</code><code class="m">4</code><code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">)</code>
<code class="c1">## 3 2</code></pre><div class="figure"><a id="FIGURE-PEMDAS"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0105.png.jpg" alt="Order of operations"/></div></div><div class="figure-title">Figure 1-5. When you link functions together, R will resolve them from the innermost operation to the outermost. Here R first looks up die, then calculates the mean of one through six, then rounds the mean.</div></div><p>To roll your die and get a number back, set <code class="literal">x</code> to <code class="literal">die</code> and sample one element from it. You’ll get a new (maybe different) number each time you roll it:</p><pre class="programlisting">sample<code class="p">(</code>x <code class="o">=</code> die<code class="p">,</code> size <code class="o">=</code> <code class="m">1</code><code class="p">)</code>
<code class="c1">## 2</code>

sample<code class="p">(</code>x <code class="o">=</code> die<code class="p">,</code> size <code class="o">=</code> <code class="m">1</code><code class="p">)</code>
<code class="c1">## 1</code>

sample<code class="p">(</code>x <code class="o">=</code> die<code class="p">,</code> size <code class="o">=</code> <code class="m">1</code><code class="p">)</code>
<code class="c1">## 6</code></pre><p>Many R functions take multiple arguments that help them do their job. You can give a function as many arguments as you like as long as you separate each argument with a comma.<a id="id364685" class="indexterm"/><a id="id505506" class="indexterm"/></p><p>You may have noticed that I set <code class="literal">die</code> and <code class="literal">1</code> equal to the names of the arguments in <code class="literal">sample</code>, <code class="literal">x</code> and <code class="literal">size</code>. Every argument in every R function has a name. You can specify which data should be assigned to which argument by setting a name equal to data, as in the preceding code. This becomes important as you begin to pass multiple arguments to the same function; names help you avoid passing the wrong data to the wrong argument. However, using names is optional.<a id="id376849" class="indexterm"/><a id="id480033" class="indexterm"/> You will notice that R users do not often use the name of the first argument in a function. So you might see the previous code written as:</p><pre class="programlisting">sample<code class="p">(</code>die<code class="p">,</code> size <code class="o">=</code> <code class="m">1</code><code class="p">)</code>
<code class="c1">## 2</code></pre><p>Often, the name of the first argument is not very descriptive, and it is usually obvious what the first piece of data refers to anyways.</p><p>But how do you know which argument names to use?<a id="id373343" class="indexterm"/> If you try to use a name that a function does not expect, you will likely get an error:</p><pre class="programlisting">round<code class="p">(</code><code class="m">3.1415</code><code class="p">,</code> corners <code class="o">=</code> <code class="m">2</code><code class="p">)</code>
<code class="c1">## Error in round(3.1415, corners = 2) : unused argument(s) (corners = 2)</code></pre><p>If you’re not sure which names to use with a function, you can look up the function’s arguments with <code class="literal">args</code>.<a id="id434883" class="indexterm"/><a id="id478042" class="indexterm"/> To do this, place the name of the function in the parentheses behind <code class="literal">args</code>. For example, you can see that the <code class="literal">round</code> function takes two arguments, one named <code class="literal">x</code> and one named <code class="literal">digits</code>:</p><pre class="programlisting">args<code class="p">(</code>round<code class="p">)</code>
<code class="c1">## function (x, digits = 0)</code>
<code class="c1">## NULL</code></pre><p>Did you notice that <code class="literal">args</code> shows that the <code class="literal">digits</code> argument of <code class="literal">round</code> is already set to 0? Frequently, an R function will take optional arguments like <code class="literal">digits</code>. These arguments are considered optional because they come with a default value. You can pass a new value to an optional argument if you want, and R will use the default value if you do not. For example, <code class="literal">round</code> will round your number to 0 digits past the decimal point by default. To override the default, supply your own value for <code class="literal">digits</code>:</p><pre class="programlisting">round<code class="p">(</code><code class="m">3.1415</code><code class="p">,</code> digits <code class="o">=</code> <code class="m">2</code><code class="p">)</code>
<code class="c1">## 3.14</code></pre><p>You should write out the names of each argument after the first one or two when you call a function with multiple arguments. Why? First, this will help you and others understand your code. It is usually obvious which argument your first input refers to (and sometimes the second input as well). However, you’d need a large memory to remember the third and fourth arguments of every R function. Second, and more importantly, writing out argument names prevents errors.</p><p>If you do not write out the names of your arguments, R will match your values to the arguments in your function by order. For example, in the following code, the first value, <code class="literal">die</code>, will be matched to the first argument of <code class="literal">sample</code>, which is named <code class="literal">x</code>. The next value, <code class="literal">1</code>, will be matched to the next argument, <code class="literal">size</code>:</p><pre class="programlisting">sample<code class="p">(</code>die<code class="p">,</code> <code class="m">1</code><code class="p">)</code>
<code class="c1">## 2</code></pre><p>As you provide more arguments, it becomes more likely that your order and R’s order may not align. As a result, values may get passed to the wrong argument. Argument names prevent this. R will always match a value to its argument name, no matter where it appears in the order of arguments:</p><pre class="programlisting">sample<code class="p">(</code>size <code class="o">=</code> <code class="m">1</code><code class="p">,</code> x <code class="o">=</code> die<code class="p">)</code>
<code class="c1">## 2</code></pre></div><div class="sect1" title="Sample with Replacement"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_sample_with_replacement">Sample with Replacement</h2></div></div></div><p>If you set <code class="literal">size = 2</code>, you can <span class="emphasis"><em>almost</em></span> simulate a pair of dice.<a id="id385586" class="indexterm"/><a id="id385592" class="indexterm"/><a id="id508627" class="indexterm"/> Before we run that code, think for a minute why that might be the case. <code class="literal">sample</code> will return two numbers, one for each die:</p><pre class="programlisting">sample<code class="p">(</code>die<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">)</code>
<code class="c1">## 3 4</code></pre><p>I said this “almost” works because this method does something funny. If you use it many times, you’ll notice that the second die never has the same value as the first die, which means you’ll never roll something like a pair of threes or snake eyes. What is going on?</p><p>By default, <code class="literal">sample</code> builds a sample <span class="emphasis"><em>without replacement</em></span>. To see what this means, imagine that <code class="literal">sample</code> places all of the values of <code class="literal">die</code> in a jar or urn. Then imagine that <code class="literal">sample</code> reaches into the jar and pulls out values one by one to build its sample. Once a value has been drawn from the jar, <code class="literal">sample</code> sets it aside. The value doesn’t go back into the jar, so it cannot be drawn again. So if <code class="literal">sample</code> selects a six on its first draw, it will not be able to select a six on the second draw; six is no longer in the jar to be selected. Although <code class="literal">sample</code> creates its sample electronically, it follows this seemingly physical behavior.</p><p>One side effect of this behavior is that each draw depends on the draws that come before it. In the real world, however, when you roll a pair of dice, each die is independent of the other. If the first die comes up six, it does not prevent the second die from coming up six. In fact, it doesn’t influence the second die in any way whatsoever. You can recreate this behavior in <code class="literal">sample</code> by adding the argument <code class="literal">replace = TRUE</code>:</p><pre class="programlisting">sample<code class="p">(</code>die<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
<code class="c1">## 5 5</code></pre><p>The argument <code class="literal">replace = TRUE</code> causes <code class="literal">sample</code> to sample <span class="emphasis"><em>with replacement</em></span>. Our jar example provides a good way to understand the difference between sampling with replacement and without. When <code class="literal">sample</code> uses replacement, it draws a value from the jar and records the value. Then it puts the value back into the jar. In other words, <code class="literal">sample</code> <span class="emphasis"><em>replaces</em></span> each value after each draw. As a result, <code class="literal">sample</code> may select the same value on the second draw. Each value has a chance of being selected each time. It is as if every draw were the first draw.</p><p>Sampling with replacement is an easy way to create <span class="emphasis"><em>independent random samples</em></span>.<a id="id376297" class="indexterm"/><a id="id376303" class="indexterm"/> Each value in your sample will be a sample of size one that is independent of the other values. This is the correct way to simulate a pair of dice:</p><pre class="programlisting">sample<code class="p">(</code>die<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
<code class="c1">## 2 4</code></pre><p>Congratulate yourself; you’ve just run your first simulation in R! You now have a method for simulating the result of rolling a pair of dice.<a id="id475495" class="indexterm"/><a id="id475504" class="indexterm"/><a id="id372066" class="indexterm"/> If you want to add up the dice, you can feed your result straight into the <code class="literal">sum</code> function:</p><pre class="programlisting">dice <code class="o">&lt;-</code> sample<code class="p">(</code>die<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
dice
<code class="c1">## 2 4</code>

sum<code class="p">(</code>dice<code class="p">)</code>
<code class="c1">## 6</code></pre><p>What would happen if you call <code class="literal">dice</code> multiple times? Would R generate a new pair of dice values each time? Let’s give it a try:</p><pre class="programlisting">dice
<code class="c1">## 2 4</code>

dice
<code class="c1">## 2 4</code>

dice
<code class="c1">## 2 4</code></pre><p>Nope. Each time you call <code class="literal">dice</code>, R will show you the result of that one time you called <code class="literal">sample</code> and saved the output to <code class="literal">dice</code>. R won’t rerun <code class="literal">sample(die, 2, replace = TRUE)</code> to create a new roll of the dice. This is a relief in a way. Once you save a set of results to an R object, those results do not change. Programming would be quite hard if the values of your objects changed each time you called them.</p><p>However, it <span class="emphasis"><em>would</em></span> be convenient to have an object that can re-roll the dice whenever you call it. You can make such an object by writing your own R function.</p></div><div class="sect1" title="Writing Your Own Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="WRITE-FUNCTIONS">Writing Your Own Functions</h2></div></div></div><p>To recap, you already have working R code that simulates rolling a pair of<a id="id389425" class="indexterm"/> dice:</p><pre class="programlisting">die <code class="o">&lt;-</code> <code class="m">1</code><code class="o">:</code><code class="m">6</code>
dice <code class="o">&lt;-</code> sample<code class="p">(</code>die<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
sum<code class="p">(</code>dice<code class="p">)</code></pre><p>You can retype this code into the console anytime you want to re-roll your dice. However, this is an awkward way to work with the code. It would be easier to use your code if you wrapped it into its own function, which is exactly what we’ll do now. We’re going to write a function named <code class="literal">roll</code> that you can use to roll your virtual dice. When you’re finished, the function will work like this: each time you call <code class="literal">roll()</code>, R will return the sum of rolling two dice:</p><pre class="programlisting">roll<code class="p">()</code>
<code class="c1">## 8</code>

roll<code class="p">()</code>
<code class="c1">## 3</code>

roll<code class="p">()</code>
<code class="c1">## 7</code></pre><p>Functions may seem mysterious or fancy, but they are just another type of R object. Instead of containing data, they contain code. This code is stored in a special format that makes it easy to reuse the code in new situations. You can write your own functions by recreating this format.<a id="id474302" class="indexterm"/></p><div class="sect2" title="The Function Constructor"><div class="titlepage"><div><div><h3 class="title" id="_the_function_constructor">The Function Constructor</h3></div></div></div><p>Every function in R has three basic parts: a name, a body of code, and a set of arguments. To make your own function, you need to replicate these parts and store them in an R object, which you can do with the <code class="literal">function</code> function.<a id="id499141" class="indexterm"/><a id="id499135" class="indexterm"/><a id="id476697" class="indexterm"/><a id="id476705" class="indexterm"/><a id="id511324" class="indexterm"/> To do this, call <code class="literal">function()</code> and follow it with a pair of braces, <code class="literal">{}</code>:</p><pre class="programlisting">my_function <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{}</code></pre><p><code class="literal">function</code> will build a function out of whatever R code you place between the braces. For example, you can turn your dice code into a function by calling:</p><pre class="programlisting">roll <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  die <code class="o">&lt;-</code> <code class="m">1</code><code class="o">:</code><code class="m">6</code> <a id="CO3-1"/><img src="callouts/1.png" alt="1"/>
  dice <code class="o">&lt;-</code> sample<code class="p">(</code>die<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
  sum<code class="p">(</code>dice<code class="p">)</code>
<code class="p">}</code></pre><div class="calloutlist"><dl><dt><a href="#CO3-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
Notice that I indented each line of code between the braces. This makes the code easier for you and me to read but has no impact on how the code runs. R ignores spaces and line breaks and executes one complete expression at a time.<a id="id493183" class="indexterm"/>
</p></dd></dl></div><p>Just hit the Enter key between each line after the first brace, <code class="literal">{</code>. R will wait for you to type the last brace, <code class="literal">}</code>, before it responds.</p><p>Don’t forget to save the output of <code class="literal">function</code> to an R object. This object will become your new function. To use it, write the object’s name followed by an open and closed parenthesis:</p><pre class="programlisting">roll<code class="p">()</code>
<code class="c1">## 9</code></pre><p>You can think of the parentheses as the “trigger” that causes R to run the function. If you type in a function’s name <span class="emphasis"><em>without</em></span> the parentheses, R will show you the code that is stored inside the function. If you type in the name <span class="emphasis"><em>with</em></span> the parentheses, R will run that code:</p><pre class="programlisting">roll
<code class="c1">## function() {</code>
<code class="c1">##   die &lt;- 1:6</code>
<code class="c1">##   dice &lt;- sample(die, size = 2, replace = TRUE)</code>
<code class="c1">##   sum(dice)</code>
<code class="c1">## }</code>

roll<code class="p">()</code>
<code class="c1">## 6</code></pre><p>The code that you place inside your function is known as the <span class="emphasis"><em>body</em></span> of the function. When you run a function in R, R will execute all of the code in the body and then return the result of the last line of code. If the last line of code doesn’t return a value, neither will your function, so you want to ensure that your final line of code returns a value. One way to check this is to think about what would happen if you ran the body of code line by line in the command line. Would R display a result after the last line, or would it not?<a id="id456279" class="indexterm"/></p><p>Here’s some code that would display a result:</p><pre class="programlisting">dice
<code class="m">1</code> <code class="o">+</code> <code class="m">1</code>
sqrt<code class="p">(</code><code class="m">2</code><code class="p">)</code></pre><p>And here’s some code that would not:</p><pre class="programlisting">dice <code class="o">&lt;-</code> sample<code class="p">(</code>die<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
two <code class="o">&lt;-</code> <code class="m">1</code> <code class="o">+</code> <code class="m">1</code>
a <code class="o">&lt;-</code> sqrt<code class="p">(</code><code class="m">2</code><code class="p">)</code></pre><p>Do you notice the pattern? These lines of code do not return a value to the command line; they save a value to an object.</p></div></div><div class="sect1" title="Arguments"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_arguments">Arguments</h2></div></div></div><p>What if we<a id="id385722" class="indexterm"/> removed one line of code from our function and changed the name <code class="literal">die</code> to <code class="literal">bones</code>, like this?</p><pre class="programlisting">roll2 <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  dice <code class="o">&lt;-</code> sample<code class="p">(</code>bones<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
  sum<code class="p">(</code>dice<code class="p">)</code>
<code class="p">}</code></pre><p>Now I’ll get an error when I run the function. The function needs the object <code class="literal">bones</code> to do its job, but there is no object named <code class="literal">bones</code> to be found:</p><pre class="programlisting">roll2<code class="p">()</code>
<code class="c1">## Error in sample(bones, size = 2, replace = TRUE) :</code>
<code class="c1">##   object 'bones' not found</code></pre><p>You can supply <code class="literal">bones</code> when you call <code class="literal">roll2</code> if you make <code class="literal">bones</code> an argument of the function. To do this, put the name <code class="literal">bones</code> in the parentheses that follow <code class="literal">function</code> when you define <code class="literal">roll2</code>:</p><pre class="programlisting">roll2 <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>bones<code class="p">)</code> <code class="p">{</code>
  dice <code class="o">&lt;-</code> sample<code class="p">(</code>bones<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
  sum<code class="p">(</code>dice<code class="p">)</code>
<code class="p">}</code></pre><p>Now <code class="literal">roll2</code> will work as long as you supply <code class="literal">bones</code> when you call the function. You can take advantage of this to roll different types of dice each time you call <code class="literal">roll2</code>. Dungeons and Dragons, here we come!</p><p>Remember, we’re rolling pairs of dice:</p><pre class="programlisting">roll2<code class="p">(</code>bones <code class="o">=</code> <code class="m">1</code><code class="o">:</code><code class="m">4</code><code class="p">)</code>
<code class="c1">##  3</code>

roll2<code class="p">(</code>bones <code class="o">=</code> <code class="m">1</code><code class="o">:</code><code class="m">6</code><code class="p">)</code>
<code class="c1">## 10</code>

roll2<code class="p">(</code><code class="m">1</code><code class="o">:</code><code class="m">20</code><code class="p">)</code>
<code class="c1">## 31</code></pre><p>Notice that <code class="literal">roll2</code> will still give an error if you do not supply a value for the <code class="literal">bones</code> argument when<a id="id515891" class="indexterm"/><a id="id451544" class="indexterm"/> you call <code class="literal">roll2</code>:</p><pre class="programlisting">roll2<code class="p">()</code>
<code class="c1">## Error in sample(bones, size = 2, replace = TRUE) :</code>
<code class="c1">##   argument "bones" is missing, with no default</code></pre><p>You can prevent this error by giving the <code class="literal">bones</code> argument a default value. To do this, set <code class="literal">bones</code> equal to a value when you define <code class="literal">roll2</code>:</p><pre class="programlisting">roll2 <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>bones <code class="o">=</code> <code class="m">1</code><code class="o">:</code><code class="m">6</code><code class="p">)</code> <code class="p">{</code>
  dice <code class="o">&lt;-</code> sample<code class="p">(</code>bones<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
  sum<code class="p">(</code>dice<code class="p">)</code>
<code class="p">}</code></pre><p>Now you can supply a new value for <code class="literal">bones</code> if you like, and <code class="literal">roll2</code> will use the default if you do not:</p><pre class="programlisting">roll2<code class="p">()</code>
<code class="c1">## 9</code></pre><p>You can give your functions as many arguments as you like. Just list their names, separated by commas, in the parentheses that follow <code class="literal">function</code>. When the function is run, R will replace each argument name in the function body with the value that the user supplies for the argument. If the user does not supply a value, R will replace the argument name with the argument’s default value (if you defined one).<a id="id459092" class="indexterm"/></p><p>To summarize, <code class="literal">function</code> helps you construct your own R functions. You create a body of code for your function to run by writing code between the braces that follow <code class="literal">function</code>. You create arguments for your function to use by supplying their names in the parentheses that follow <code class="literal">function</code>. Finally, you give your function a name by saving its output to an R object, as shown in <a class="xref" href="ch01.html#FIGURE-LANGUAGE-FUNCTIONS" title="Figure 1-6. Every function in R has the same parts, and you can use function to create these parts.">Figure 1-6</a>.</p><p>Once you’ve created your function, R will treat it like every other function in R. Think about how useful this is. Have you ever tried to create a new Excel option and add it to Microsoft’s menu bar? Or a new slide animation and add it to Powerpoint’s options? When you work with a programming language, you can do these types of things. As you learn to program in R, you will be able to create new, customized, reproducible tools for yourself whenever you like. <a class="xref" href="pt03.html" title="Part III. Project 3: Slot Machine">Part III</a> will teach you much more about writing functions in R.</p><div class="figure"><a id="FIGURE-LANGUAGE-FUNCTIONS"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0106.png" alt="Parts of a function"/></div></div><div class="figure-title">Figure 1-6. Every function in R has the same parts, and you can use function to create these parts.</div></div></div><div class="sect1" title="Scripts"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_scripts">Scripts</h2></div></div></div><p>What if you want to edit <code class="literal">roll2</code> again? You could go back and retype each line of code in <code class="literal">roll2</code>, but it would be so much easier if you had a draft of the code to start from.<a id="id371083" class="indexterm"/><a id="id371092" class="indexterm"/><a id="id371098" class="indexterm"/> You can create a draft of your code as you go by using an R <span class="emphasis"><em>script</em></span>. An R script is just a plain text file that you save R code in. You can open an R script in RStudio by going to <code class="literal">File &gt; New File &gt; R script</code> in the menu bar. RStudio will then open a fresh script above your console pane, as shown in <a class="xref" href="ch01.html#FIGURE-SCRIPT" title="Figure 1-7. When you open an R Script (File &gt; New File &gt; R Script in the menu bar), RStudio creates a fourth pane above the console where you can write and edit your code.">Figure 1-7</a>.</p><p>I strongly encourage you to write and edit all of your R code in a script before you run it in the console. Why? This habit creates a reproducible record of your work. When you’re finished for the day, you can save your script and then use it to rerun your entire analysis the next day. Scripts are also very handy for editing and proofreading your code, and they make a nice copy of your work to share with others. To save a script, click the scripts pane, and then go to <code class="literal">File &gt; Save As</code> in the menu bar.</p><p>RStudio comes with many built-in features that make it easy to work with scripts. First, you can automatically execute a line of code in a script by clicking the Run button, as shown in <a class="xref" href="ch01.html#FIGURE-SCRIPT-RUN" title="Figure 1-8. You can run a highlighted portion of code in your script if you click the Run button at the top of the scripts pane. You can run the entire script by clicking the Source button.">Figure 1-8</a>.</p><p>R will run whichever line of code your cursor is on. If you have a whole section highlighted, R will run the highlighted code. Alternatively, you can run the entire script by clicking the Source button. Don’t like clicking buttons? You can use Control + Return as a shortcut for the Run button. On Macs, that would be Command + Return.</p><div class="figure"><a id="FIGURE-SCRIPT"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0107.png.jpg" alt="Scripts"/></div></div><div class="figure-title">Figure 1-7. When you open an R Script (File &gt; New File &gt; R Script in the menu bar), RStudio creates a fourth pane above the console where you can write and edit your code.</div></div><div class="figure"><a id="FIGURE-SCRIPT-RUN"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0108.png.jpg" alt="Run and Source"/></div></div><div class="figure-title">Figure 1-8. You can run a highlighted portion of code in your script if you click the Run button at the top of the scripts pane. You can run the entire script by clicking the Source button.</div></div><p>If you’re not convinced about scripts, you soon will be. It becomes a pain to write multi-line code in the console’s single-line command line. Let’s avoid that headache and open your first script now before we move to the next chapter.</p><div class="tip" title="Extract function"><h3 class="title">Extract function</h3><p>RStudio comes with a tool that can help you build functions. To use it, highlight the lines of code in your R script that you want to turn into a function. Then click <code class="literal">Code &gt; Extract Function</code> in the menu bar. RStudio will ask you for a function name to use and then wrap you code in a <code class="literal">function</code> call. It will scan the code for undefined variables and use these as arguments.<a id="id508337" class="indexterm"/><a id="id445666" class="indexterm"/></p><p>You may want to double-check RStudio’s work. It assumes that your code is correct, so if it does something surprising, you may have a problem in your code.</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_summary">Summary</h2></div></div></div><p>You’ve covered a lot of ground already. You now have a virtual die stored in your computer’s memory, as well as your own R function that rolls a pair of dice. You’ve also begun speaking the R language.</p><p>As you’ve seen, R is a language that you can use to talk to your computer. You write commands in R and run them at the command line for your computer to read. Your computer will sometimes talk back—for example, when you commit an error—but it usually just does what you ask and then displays the result.</p><p>The two most important components of the R language are objects, which store data, and functions, which manipulate data. R also uses a host of operators like <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">&lt;-</code> to do basic tasks. As a data scientist, you will use R objects to store data in your computer’s memory, and you will use functions to automate tasks and do complicated calculations. We will examine objects in more depth later in <a class="xref" href="pt02.html" title="Part II. Project 2: Playing Cards">Part II</a> and dig further into functions in <a class="xref" href="pt03.html" title="Part III. Project 3: Slot Machine">Part III</a>. The vocabulary you have developed here will make each of those projects easier to understand. However, we’re not done with your dice yet.</p><p>In <a class="xref" href="ch02.html" title="Chapter 2. Packages and Help Pages">Chapter 2</a>, you’ll run some simulations on your dice and build your first graphs in R. You’ll also look at two of the most useful components of the R language: R <span class="emphasis"><em>packages</em></span>, which are collections of functions writted by R’s talented community of developers, and R documentation, which is a collection of help pages built into R that explains every function and data set in the language.</p></div></section></body></html>
