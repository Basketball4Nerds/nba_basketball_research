<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 10. Speed</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt03.html" title="Part III. Project 3: Slot Machine"/><link rel="prev" href="ch09.html" title="Chapter 9. Loops"/><link rel="next" href="apa.html" title="Appendix A. Installing R and RStudio"/></head><body><section class="chapter" title="Chapter 10. Speed" epub:type="chapter" id="SPEED"><div class="titlepage"><div><div><h2 class="title">Chapter 10. Speed</h2></div></div></div><p>As a data scientist, you need speed. You can work with bigger data and do more ambitious tasks when your code runs fast. This chapter will show you a specific way to write fast code in R. You will then use the method to simulate 10 million plays of your slot machine.<a id="id534375" class="indexterm"/><a id="id534349" class="indexterm"/><a id="id534376" class="indexterm"/></p><div class="sect1" title="Vectorized Code"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_vectorized_code">Vectorized Code</h2></div></div></div><p>You can write a piece of code in many different ways, but the fastest R code will usually take advantage of three things: logical tests, subsetting, and element-wise execution. These are the things that R does best. Code that uses these things usually has a certain quality: it is <span class="emphasis"><em>vectorized</em></span>; the code can take a vector of values as input and manipulate each value in the vector at the same time.<a id="id534435" class="indexterm"/><a id="id534444" class="indexterm"/><a id="id534450" class="indexterm"/></p><p>To see what vectorized code looks like, compare these two examples of an absolute value function. Each takes a vector of numbers and transforms it into a vector of absolute values (e.g., positive numbers). The first example is not vectorized; <code class="literal">abs_loop</code> uses a <code class="literal">for</code> loop to manipulate each element of the vector one at a time:</p><pre class="programlisting">abs_loop <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>vec<code class="p">){</code>
  <code class="kr">for</code> <code class="p">(</code>i <code class="kr">in</code> <code class="m">1</code><code class="o">:</code>length<code class="p">(</code>vec<code class="p">))</code> <code class="p">{</code>
    <code class="kr">if</code> <code class="p">(</code>vec<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;</code> <code class="m">0</code><code class="p">)</code> <code class="p">{</code>
      vec<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> <code class="o">-</code>vec<code class="p">[</code>i<code class="p">]</code>
    <code class="p">}</code>
  <code class="p">}</code>
  vec
<code class="p">}</code></pre><p>The second example, <code class="literal">abs_set</code>, is a vectorized version of <code class="literal">abs_loop</code>. It uses logical subsetting to manipulate every negative number in the vector at the same time:</p><pre class="programlisting">abs_sets <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>vec<code class="p">){</code>
  negs <code class="o">&lt;-</code> vec <code class="o">&lt;</code> <code class="m">0</code>
  vec<code class="p">[</code>negs<code class="p">]</code> <code class="o">&lt;-</code> vec<code class="p">[</code>negs<code class="p">]</code> <code class="o">*</code> <code class="m">-1</code>
  vec
<code class="p">}</code></pre><p><code class="literal">abs_set</code> is much faster than <code class="literal">abs_loop</code> because it relies on operations that R does quickly: logical tests, subsetting, and element-wise execution.</p><p>You can use the <code class="literal">system.time</code> function to see just how fast <code class="literal">abs_set</code> is. <code class="literal">system.time</code> takes an R expression, runs it, and then displays how much time elapsed while the expression ran.</p><p>To compare <code class="literal">abs_loop</code> and <code class="literal">abs_set</code>, first make a long vector of positive and negative numbers. <code class="literal">long</code> will contain 10 million values:</p><pre class="programlisting">long <code class="o">&lt;-</code> rep<code class="p">(</code>c<code class="p">(</code><code class="m">-1</code><code class="p">,</code> <code class="m">1</code><code class="p">),</code> <code class="m">5000000</code><code class="p">)</code> <a id="CO11-1"/><img src="callouts/1.png" alt="1"/></pre><div class="calloutlist"><dl><dt><a href="#CO11-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
<code class="literal">rep</code> repeats a value, or vector of values, many times. To use <code class="literal">rep</code>, give it a vector of values and then the number of times to repeat the vector. R will return the results as a new, longer vector.
</p></dd></dl></div><p>You can then use <code class="literal">system.time</code> to measure how much time it takes each function to evaluate <code class="literal">long</code>:</p><pre class="programlisting">system.time<code class="p">(</code>abs_loop<code class="p">(</code>long<code class="p">))</code> <a id="CO12-1"/><img src="callouts/1.png" alt="1"/>
<code class="c1">##    user  system elapsed</code>
<code class="c1">##  15.982   0.032  16.018</code>

system.time<code class="p">(</code>abs_sets<code class="p">(</code>long<code class="p">))</code>
<code class="c1">##    user  system elapsed</code>
<code class="c1">##   0.529   0.063   0.592</code></pre><div class="calloutlist"><dl><dt><a href="#CO12-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
Don’t confuse <code class="literal">system.time</code> with <code class="literal">Sys.time</code>, which returns the current time.<a id="id534976" class="indexterm"/><a id="id534986" class="indexterm"/><a id="id534992" class="indexterm"/><a id="id535001" class="indexterm"/>
</p></dd></dl></div><p>The first two columns of the output of <code class="literal">system.time</code> report how many seconds your computer spent executing the call on the user side and system sides of your process, a dichotomy that will vary from OS to OS.</p><p>The last column displays how many seconds elapsed while R ran the expression. The results show that <code class="literal">abs_set</code> calculated the absolute value 30 times faster than <code class="literal">abs_loop</code> when applied to a vector of 10 million numbers. You can expect similar speed-ups whenever you write vectorized code.</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Many preexisting R functions are already vectorized and have been optimized to perform quickly. You can make your code faster by relying on these functions whenever possible. For example, R comes with a built-in absolute value function, <code class="literal">abs</code>.</p><p>Check to see how much faster <code class="literal">abs</code> computes the absolute value of <code class="literal">long</code> than <code class="literal">abs_loop</code> and <code class="literal">abs_set</code> do.</p></div><p>You can measure the speed of <code class="literal">abs</code> with <code class="literal">system.time</code>. It takes <code class="literal">abs</code> a lightning-fast 0.05 seconds to calculate the absolute value of 10 million numbers. This is 0.592 / 0.054 = 10.96 times faster than <code class="literal">abs_set</code> and nearly 300 times faster than <code class="literal">abs_loop</code>:</p><pre class="programlisting">system.time<code class="p">(</code>abs<code class="p">(</code>long<code class="p">))</code>
<code class="c1">##   user  system elapsed</code>
<code class="c1">##  0.037   0.018   0.054</code></pre></div><div class="sect1" title="How to Write Vectorized Code"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_how_to_write_vectorized_code">How to Write Vectorized Code</h2></div></div></div><p>Vectorized code is easy to write in R because most R functions are already vectorized. Code based on these functions can easily be made vectorized and therefore fast.<a id="ix_VCwrite" class="indexterm"/>  To create vectorized code:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Use vectorized functions to complete the sequential steps in your program.
</li><li class="listitem">
Use logical subsetting to handle parallel cases. Try to manipulate every element in a case at once.
</li></ol></div><p><code class="literal">abs_loop</code> and <code class="literal">abs_set</code> illustrate these rules. The functions both handle two cases and perform one sequential step, <a class="xref" href="ch10.html#FIGURE-ADVANCED-ABS" title="Figure 10-1. abs_loop uses a for loop to sift data into one of two cases: negative numbers and nonnegative numbers.">Figure 10-1</a>. If a number is positive, the functions leave it alone. If a number is negative, the functions multiply it by negative one.</p><div class="figure"><a id="FIGURE-ADVANCED-ABS"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_1001.png" alt="The cases of abs_loop"/></div></div><div class="figure-title">Figure 10-1. abs_loop uses a for loop to sift data into one of two cases: negative numbers and nonnegative numbers.</div></div><p>You can identify all of the elements of a vector that fall into a case with a logical test. R will execute the test in element-wise fashion and return a <code class="literal">TRUE</code> for every element that belongs in the case. For example, <code class="literal">vec &lt; 0</code> identifies every value of <code class="literal">vec</code> that belongs to the negative case. You can use the same logical test to extract the set of negative values with logical subsetting:</p><pre class="programlisting">vec <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">-2</code><code class="p">,</code> <code class="m">3</code><code class="p">,</code> <code class="m">-4</code><code class="p">,</code> <code class="m">5</code><code class="p">,</code> <code class="m">-6</code><code class="p">,</code> <code class="m">7</code><code class="p">,</code> <code class="m">-8</code><code class="p">,</code> <code class="m">9</code><code class="p">,</code> <code class="m">-10</code><code class="p">)</code>
vec <code class="o">&lt;</code> <code class="m">0</code>
<code class="c1">## FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE</code>

vec<code class="p">[</code>vec <code class="o">&lt;</code> <code class="m">0</code><code class="p">]</code>
<code class="c1">## -2  -4  -6  -8 -10</code></pre><p>The plan in <a class="xref" href="ch10.html#FIGURE-ADVANCED-ABS" title="Figure 10-1. abs_loop uses a for loop to sift data into one of two cases: negative numbers and nonnegative numbers.">Figure 10-1</a> now requires a sequential step: you must multiply each of the negative values by negative one. All of R’s arithmetic operators are vectorized, so you can use <code class="literal">*</code> to complete this step in vectorized fashion. <code class="literal">*</code> will multiply each number in <code class="literal">vec[vec &lt; 0]</code> by negative one at the same time:</p><pre class="programlisting">vec<code class="p">[</code>vec <code class="o">&lt;</code> <code class="m">0</code><code class="p">]</code> <code class="o">*</code> <code class="m">-1</code>
<code class="c1">## 2  4  6  8 10</code></pre><p>Finally, you can use R’s assignment operator, which is also vectorized, to save the new set over the old set in the original <code class="literal">vec</code> object. Since <code class="literal">&lt;-</code> is vectorized, the elements of the new set will be paired up to the elements of the old set, in order, and then element-wise assignment will occur. As a result, each negative value will be replaced by its positive partner, as in <a class="xref" href="ch10.html#FIGURE-VECTORIZED-ASSIGNMENT" title="Figure 10-2. Use logical subsetting to modify groups of values in place. R’s arithmetic and assignment operators are vectorized, which lets you manipulate and update multiple values at once.">Figure 10-2</a>.<a id="id535486" class="indexterm"/><a id="id535494" class="indexterm"/></p><div class="figure"><a id="FIGURE-VECTORIZED-ASSIGNMENT"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_1002.png.jpg" alt="Vectorized assignment"/></div></div><div class="figure-title">Figure 10-2. Use logical subsetting to modify groups of values in place. R’s arithmetic and assignment operators are vectorized, which lets you manipulate and update multiple values at once.</div></div><div class="sidebar"><div class="sidebar-title">Exercise</div><p>The following function converts a vector of slot symbols to a vector of new slot symbols. Can you vectorize it? How much faster does the vectorized version work?</p><pre class="programlisting">change_symbols <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>vec<code class="p">){</code>
  <code class="kr">for</code> <code class="p">(</code>i <code class="kr">in</code> <code class="m">1</code><code class="o">:</code>length<code class="p">(</code>vec<code class="p">)){</code>
    <code class="kr">if</code> <code class="p">(</code>vec<code class="p">[</code>i<code class="p">]</code> <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code> <code class="p">{</code>
      vec<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"joker"</code>
    <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>vec<code class="p">[</code>i<code class="p">]</code> <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code> <code class="p">{</code>
      vec<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"ace"</code>
    <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>vec<code class="p">[</code>i<code class="p">]</code> <code class="o">==</code> <code class="s">"7"</code><code class="p">)</code> <code class="p">{</code>
      vec<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"king"</code>
    <code class="p">}</code><code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>vec<code class="p">[</code>i<code class="p">]</code> <code class="o">==</code> <code class="s">"B"</code><code class="p">)</code> <code class="p">{</code>
      vec<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"queen"</code>
    <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>vec<code class="p">[</code>i<code class="p">]</code> <code class="o">==</code> <code class="s">"BB"</code><code class="p">)</code> <code class="p">{</code>
      vec<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"jack"</code>
    <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>vec<code class="p">[</code>i<code class="p">]</code> <code class="o">==</code> <code class="s">"BBB"</code><code class="p">)</code> <code class="p">{</code>
      vec<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"ten"</code>
    <code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
      vec<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"nine"</code>
    <code class="p">}</code>
  <code class="p">}</code>
  vec
<code class="p">}</code>

vec <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code><code class="p">,</code> <code class="s">"C"</code><code class="p">,</code> <code class="s">"7"</code><code class="p">,</code> <code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">,</code> <code class="s">"0"</code><code class="p">)</code>

change_symbols<code class="p">(</code>vec<code class="p">)</code>
<code class="c1">##  "joker" "ace"   "king"  "queen" "jack"  "ten"   "nine"</code>

many <code class="o">&lt;-</code> rep<code class="p">(</code>vec<code class="p">,</code> <code class="m">1000000</code><code class="p">)</code>

system.time<code class="p">(</code>change_symbols<code class="p">(</code>many<code class="p">))</code>
<code class="c1">##    user  system elapsed</code>
<code class="c1">##  30.057   0.031  30.079</code></pre></div><p><code class="literal">change_symbols</code> uses a <code class="literal">for</code> loop to sort values into seven different cases, as demonstrated in <a class="xref" href="ch10.html#FIGURE-ADVANCED-CHANGE" title="Figure 10-3. change_many does something different for each of seven cases.">Figure 10-3</a>.</p><p>To vectorize <code class="literal">change_symbols</code>, create a logical test that can identify each case:</p><pre class="programlisting">vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"DD"</code><code class="p">]</code>
<code class="c1">## "DD"</code>

vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"C"</code><code class="p">]</code>
<code class="c1">## "C"</code>

vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"7"</code><code class="p">]</code>
<code class="c1">## "7"</code>

vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"B"</code><code class="p">]</code>
<code class="c1">## "B"</code>

vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"BB"</code><code class="p">]</code>
<code class="c1">## "BB"</code>

vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"BBB"</code><code class="p">]</code>
<code class="c1">## "BBB"</code>

vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"0"</code><code class="p">]</code>
<code class="c1">## "0"</code></pre><div class="figure"><a id="FIGURE-ADVANCED-CHANGE"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_1003.png" alt="The cases of change_many"/></div></div><div class="figure-title">Figure 10-3. change_many does something different for each of seven cases.</div></div><p>Then write code that can change the symbols for each case:</p><pre class="programlisting">vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"DD"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"joker"</code>
vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"C"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"ace"</code>
vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"7"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"king"</code>
vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"B"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"queen"</code>
vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"BB"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"jack"</code>
vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"BBB"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"ten"</code>
vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"0"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"nine"</code></pre><p>When you combine this into a function, you have a vectorized version of <code class="literal">change_symbols</code> that runs about 14 times faster:</p><pre class="programlisting">change_vec <code class="o">&lt;-</code> <code class="kr">function</code> <code class="p">(</code>vec<code class="p">)</code> <code class="p">{</code>
  vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"DD"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"joker"</code>
  vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"C"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"ace"</code>
  vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"7"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"king"</code>
  vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"B"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"queen"</code>
  vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"BB"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"jack"</code>
  vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"BBB"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"ten"</code>
  vec<code class="p">[</code>vec <code class="o">==</code> <code class="s">"0"</code><code class="p">]</code> <code class="o">&lt;-</code> <code class="s">"nine"</code>

  vec
<code class="p">}</code>

system.time<code class="p">(</code>change_vec<code class="p">(</code>many<code class="p">))</code>
<code class="c1">##   user  system elapsed</code>
<code class="c1">##  1.994   0.059   2.051</code></pre><p>Or, even better, use a lookup table. Lookup tables are a vectorized method because they rely on R’s vectorized selection operations:</p><pre class="programlisting">change_vec2 <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>vec<code class="p">){</code>
  tb <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="s">"joker"</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="s">"ace"</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="s">"king"</code><code class="p">,</code> <code class="s">"B"</code> <code class="o">=</code> <code class="s">"queen"</code><code class="p">,</code>
    <code class="s">"BB"</code> <code class="o">=</code> <code class="s">"jack"</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="s">"ten"</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="s">"nine"</code><code class="p">)</code>
  unname<code class="p">(</code>tb<code class="p">[</code>vec<code class="p">])</code>
<code class="p">}</code>

system.time<code class="p">(</code>change_vec<code class="p">(</code>many<code class="p">))</code>
<code class="c1">##   user  system elapsed</code>
<code class="c1">##  0.687   0.059   0.746</code></pre><p>Here, a lookup table is 40 times faster than the original function.</p><p><code class="literal">abs_loop</code> and <code class="literal">change_many</code> illustrate a characteristic of vectorized code: programmers often write slower, nonvectorized code by relying on unnecessary <code class="literal">for</code> loops, like the one in <code class="literal">change_many</code>. I think this is the result of a general misunderstanding about R. <code class="literal">for</code> loops do not behave the same way in R as they do in other languages, which means you should write code differently in R than you would in other languages.</p><p>When you write in languages like C and Fortran, you must compile your code before your computer can run it. This compilation step optimizes how the <code class="literal">for</code> loops in the code use your computer’s memory, which makes the <code class="literal">for</code> loops very fast. As a result, many programmers use <code class="literal">for</code> loops frequently when they write in C and Fortran.<a id="id537438" class="indexterm"/></p><p>When you write in R, however, you do not compile your code. You skip this step, which makes programming in R a more user-friendly experience. Unfortunately, this also means you do not give your loops the speed boost they would receive in C or Fortran. As a result, your loops will run slower than the other operations we have studied: logical tests, subsetting, and element-wise execution. If you can write your code with the faster operations instead of a <code class="literal">for</code> loop, you should do so. No matter which language you write in, you should try to use the features of the language that run the fastest.</p><div class="tip" title="if and for"><h3 class="title">if and for</h3><p>A good way to spot <code class="literal">for</code> loops that could be vectorized is to look for combinations of <code class="literal">if</code> and <code class="literal">for</code>. <code class="literal">if</code> can only be applied to one value at a time, which means it is often used in conjunction with a <code class="literal">for</code> loop. The <code class="literal">for</code> loop helps apply <code class="literal">if</code> to an entire vector of values. This combination can usually be replaced with logical subsetting, which will do the same thing but run much faster.</p></div><p>This doesn’t mean that you should never use <code class="literal">for</code> loops in R. There are still many places in R where <code class="literal">for</code> loops make sense. <code class="literal">for</code> loops perform a basic task that you cannot always recreate with vectorized code. <code class="literal">for</code> loops are also easy to understand and run reasonably fast in R, so long as you take a few precautions.<a id="id537557" class="indexterm"/></p></div><div class="sect1" title="How to Write Fast for Loops in R"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_how_to_write_fast_for_loops_in_r">How to Write Fast for Loops in R</h2></div></div></div><p>You can dramatically increase the speed of your <code class="literal">for</code> loops by doing two things to optimize each loop. First, do as much as you can outside of the <code class="literal">for</code> loop. Every line of code that you place inside of the <code class="literal">for</code> loop will be run many, many times. If a line of code only needs to be run once, place it outside of the loop to avoid repetition.<a id="id537594" class="indexterm"/><a id="id537561" class="indexterm"/></p><p>Second, make sure that any storage objects that you use with the loop are large enough to contain <span class="emphasis"><em>all</em></span> of the results of the loop. For example, both loops below will need to store one million values. The first loop stores its values in an object named <code class="literal">output</code> that begins with a length of <span class="emphasis"><em>one million</em></span>:</p><pre class="programlisting">system.time<code class="p">(</code>
  output <code class="o">&lt;-</code> rep<code class="p">(</code><code class="kc">NA</code><code class="p">,</code> <code class="m">1000000</code><code class="p">)</code>
  <code class="kr">for</code> <code class="p">(</code>i <code class="kr">in</code> <code class="m">1</code><code class="o">:</code><code class="m">1000000</code><code class="p">)</code> <code class="p">{</code>
    output<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> i <code class="o">+</code> <code class="m">1</code>
  <code class="p">}</code>
<code class="p">)</code>
<code class="c1">##   user  system elapsed</code>
<code class="c1">##  1.709   0.015   1.724</code></pre><p>The second loop stores its values in an object named <code class="literal">output</code> that begins with a length of <span class="emphasis"><em>one</em></span>. R will expand the object to a length of one million as it runs the loop. The code in this loop is very similar to the code in the first loop, but the loop takes <span class="emphasis"><em>37 minutes</em></span> longer to run than the first loop:</p><pre class="programlisting">system.time<code class="p">(</code>
  output <code class="o">&lt;-</code> <code class="kc">NA</code>
  <code class="kr">for</code> <code class="p">(</code>i <code class="kr">in</code> <code class="m">1</code><code class="o">:</code><code class="m">1000000</code><code class="p">)</code> <code class="p">{</code>
    output<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> i <code class="o">+</code> <code class="m">1</code>
  <code class="p">}</code>
<code class="p">)</code>
<code class="c1">##     user   system  elapsed</code>
<code class="c1">## 1689.537  560.951 2249.927</code></pre><p>The two loops do the same thing, so what accounts for the difference? In the second loop, R has to increase the length of <code class="literal">output</code> by one for each run of the loop. To do this, R needs to find a new place in your computer’s memory that can contain the larger object. R must then copy the <code class="literal">output</code> vector over and erase the old version of <code class="literal">output</code> before moving on to the next run of the loop. By the end of the loop, R has rewritten <code class="literal">output</code> in your computer’s memory one million times.</p><p>In the first case, the size of <code class="literal">output</code> never changes; R can define one <code class="literal">output</code> object in memory and use it for each run of the <code class="literal">for</code> loop.</p><div class="tip" title="Tip"><h3 class="title">Tip</h3><p>The authors of R use low-level languages like C and Fortran to write basic R functions, many of which use <code class="literal">for</code> loops. These functions are compiled and optimized before they become a part of R, which makes them quite fast.</p><p>Whenever you see <code class="literal">.Primitive</code>, <code class="literal">.Internal</code>, or <code class="literal">.Call</code> written in a function’s definition, you can be confident the function is calling code from another language. You’ll get all of the speed advantages of that language by using the function.<a id="id537979" class="indexterm"/><a id="id537959" class="indexterm"/><a id="id537964" class="indexterm"/></p></div></div><div class="sect1" title="Vectorized Code in Practice"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_vectorized_code_in_practice">Vectorized Code in Practice</h2></div></div></div><p>To see how vectorized code can help you as a data scientist, consider our slot machine project. In <a class="xref" href="ch09.html" title="Chapter 9. Loops">Chapter 9</a>, you calculated the exact payout rate for your slot machine, but you could have estimated this payout rate with a simulation. If you played the slot machine many, many times, the average prize over all of the plays would be a good estimate of the true payout rate.<a id="id537945" class="indexterm"/></p><p>This method of estimation is based on the law of large numbers and is similar to many statistical simulations. To run this simulation, you could use a <code class="literal">for</code> loop:</p><pre class="programlisting">winnings <code class="o">&lt;-</code> vector<code class="p">(</code>length <code class="o">=</code> <code class="m">1000000</code><code class="p">)</code>
<code class="kr">for</code> <code class="p">(</code>i <code class="kr">in</code> <code class="m">1</code><code class="o">:</code><code class="m">1000000</code><code class="p">)</code> <code class="p">{</code>
  winnings<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> play<code class="p">()</code>
<code class="p">}</code>

mean<code class="p">(</code>winnings<code class="p">)</code>
<code class="c1">## 0.9366984</code></pre><p>The estimated payout rate after 10 million runs is 0.937, which is very close to the true payout rate of 0.934. Note that I’m using the modified <code class="literal">score</code> function that treats diamonds as wilds.</p><p>If you run this simulation, you will notice that it takes a while to run. In fact, the simulation takes 342,308 seconds to run, which is about 5.7 minutes. This is not particularly impressive, and you can do better by using vectorized code:</p><pre class="programlisting">system.time<code class="p">(</code><code class="kr">for</code> <code class="p">(</code>i <code class="kr">in</code> <code class="m">1</code><code class="o">:</code><code class="m">1000000</code><code class="p">)</code> <code class="p">{</code>
  winnings<code class="p">[</code>i<code class="p">]</code> <code class="o">&lt;-</code> play<code class="p">()</code>
<code class="p">})</code>
<code class="c1">##    user  system elapsed</code>
<code class="c1">## 342.041   0.355 342.308</code></pre><p>The current <code class="literal">score</code> function is not vectorized. It takes a single slot combination and uses an <code class="literal">if</code> tree to assign a prize to it. This combination of an <code class="literal">if</code> tree with a <code class="literal">for</code> loop suggests that you could write a piece of vectorized code that takes <span class="emphasis"><em>many</em></span> slot combinations and then uses logical subsetting to operate on them all at once.</p><p>For example, you could rewrite <code class="literal">get_symbols</code> to generate <span class="emphasis"><em>n</em></span> slot combinations and return them as an <span class="emphasis"><em>n</em></span> × 3 matrix, like the one that follows. Each row of the matrix will contain one slot combination to be scored:</p><pre class="programlisting">get_many_symbols <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>n<code class="p">)</code> <code class="p">{</code>
  wheel <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code><code class="p">,</code> <code class="s">"7"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"B"</code><code class="p">,</code> <code class="s">"C"</code><code class="p">,</code> <code class="s">"0"</code><code class="p">)</code>
  vec <code class="o">&lt;-</code> sample<code class="p">(</code>wheel<code class="p">,</code> size <code class="o">=</code> <code class="m">3</code> <code class="o">*</code> n<code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">,</code>
    prob <code class="o">=</code> c<code class="p">(</code><code class="m">0.03</code><code class="p">,</code> <code class="m">0.03</code><code class="p">,</code> <code class="m">0.06</code><code class="p">,</code> <code class="m">0.1</code><code class="p">,</code> <code class="m">0.25</code><code class="p">,</code> <code class="m">0.01</code><code class="p">,</code> <code class="m">0.52</code><code class="p">))</code>
  matrix<code class="p">(</code>vec<code class="p">,</code> ncol <code class="o">=</code> <code class="m">3</code><code class="p">)</code>
<code class="p">}</code>

get_many_symbols<code class="p">(</code><code class="m">5</code><code class="p">)</code>
<code class="c1">##      [,1]  [,2] [,3]</code>
<code class="c1">## [1,] "B"   "0"  "B"</code>
<code class="c1">## [2,] "0"   "BB" "7"</code>
<code class="c1">## [3,] "0"   "0"  "BBB"</code>
<code class="c1">## [4,] "0"   "0"  "B"</code>
<code class="c1">## [5,] "BBB" "0"  "0"</code></pre><p>You could also rewrite <code class="literal">play</code> to take a parameter, <code class="literal">n</code>, and return <code class="literal">n</code> prizes, in a data frame:</p><pre class="programlisting">play_many <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>n<code class="p">)</code> <code class="p">{</code>
  symb_mat <code class="o">&lt;-</code> get_many_symbols<code class="p">(</code>n <code class="o">=</code> n<code class="p">)</code>
  data.frame<code class="p">(</code>w1 <code class="o">=</code> symb_mat<code class="p">[,</code><code class="m">1</code><code class="p">],</code> w2 <code class="o">=</code> symb_mat<code class="p">[,</code><code class="m">2</code><code class="p">],</code>
             w3 <code class="o">=</code> symb_mat<code class="p">[,</code><code class="m">3</code><code class="p">],</code> prize <code class="o">=</code> score_many<code class="p">(</code>symb_mat<code class="p">))</code>
<code class="p">}</code></pre><p>This new function would make it easy to simulate a million, or even 10 million plays of the slot machine, which will be our goal. When we’re finished, you will be able to estimate the payout rate with:</p><pre class="programlisting"><code class="c1"># plays &lt;- play_many(10000000))</code>
<code class="c1"># mean(plays$prize)</code></pre><p>Now you just need to write <code class="literal">score_many</code>, a vectorized (matix-ized?) version of <code class="literal">score</code> that takes an <span class="emphasis"><em>n</em></span> × 3 matrix and returns <span class="emphasis"><em>n</em></span> prizes. It will be difficult to write this function because <code class="literal">score</code> is already quite complicated. I would not expect you to feel confident doing this on your own until you have more practice and experience than we’ve been able to develop here.</p><p>Should you like to test your skills and write a version of <code class="literal">score_many</code>, I recommend that you use the function <code class="literal">rowSums</code> within your code. It calculates the sum of each row of numbers (or logicals) in a matrix.</p><p>If you would like to test yourself in a more modest way, I recommend that you study the following model <code class="literal">score_many</code> function until you understand how each part works and how the parts work together to create a vectorized function. To do this, it will be helpful to create a concrete example, like this:</p><pre class="programlisting">symbols <code class="o">&lt;-</code> matrix<code class="p">(</code>
  c<code class="p">(</code><code class="s">"DD"</code><code class="p">,</code> <code class="s">"DD"</code><code class="p">,</code> <code class="s">"DD"</code><code class="p">,</code>
    <code class="s">"C"</code><code class="p">,</code> <code class="s">"DD"</code><code class="p">,</code> <code class="s">"0"</code><code class="p">,</code>
    <code class="s">"B"</code><code class="p">,</code> <code class="s">"B"</code><code class="p">,</code> <code class="s">"B"</code><code class="p">,</code>
    <code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">,</code>
    <code class="s">"C"</code><code class="p">,</code> <code class="s">"C"</code><code class="p">,</code> <code class="s">"0"</code><code class="p">,</code>
    <code class="s">"7"</code><code class="p">,</code> <code class="s">"DD"</code><code class="p">,</code> <code class="s">"DD"</code><code class="p">),</code> nrow <code class="o">=</code> <code class="m">6</code><code class="p">,</code> byrow <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>

symbols
<code class="c1">##      [,1] [,2] [,3]</code>
<code class="c1">## [1,] "DD" "DD" "DD"</code>
<code class="c1">## [2,] "C"  "DD" "0"</code>
<code class="c1">## [3,] "B"  "B"  "B"</code>
<code class="c1">## [4,] "B"  "BB" "BBB"</code>
<code class="c1">## [5,] "C"  "C"  "0"</code>
<code class="c1">## [6,] "7"  "DD" "DD"</code></pre><p>Then you can run each line of <code class="literal">score_many</code> against the example and examine the results as you go.</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Study the model <code class="literal">score_many</code> function until you are satisfied that you understand how it works and could write a similar function yourself.</p></div><div class="sidebar"><div class="sidebar-title">Advanced Challenge</div><p>Instead of examining the model answer, write your own vectorized version of <code class="literal">score</code>. Assume that the data is stored in an <span class="emphasis"><em>n</em></span> × 3 matrix where each row of the matrix contains one combination of slots to be scored.</p><p>You can use the version of <code class="literal">score</code> that treats diamonds as wild or the version of <code class="literal">score</code> that doesn’t. However, the model answer will use the version treating diamonds as wild.</p></div><p><code class="literal">score_many</code> is a vectorized version of <code class="literal">score</code>. You can use it to run the simulation at the start of this section in a little over 20 seconds. This is 17 times faster than using a <code class="literal">for</code> loop:</p><pre class="programlisting"><code class="c1"># symbols should be a matrix with a column for each slot machine window</code>
score_many <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>symbols<code class="p">)</code> <code class="p">{</code>

  <code class="c1"># Step 1: Assign base prize based on cherries and diamonds ---------</code>
  <code class="c1">## Count the number of cherries and diamonds in each combination</code>
  cherries <code class="o">&lt;-</code> rowSums<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code>
  diamonds <code class="o">&lt;-</code> rowSums<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code>

  <code class="c1">## Wild diamonds count as cherries</code>
  prize <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)[</code>cherries <code class="o">+</code> diamonds <code class="o">+</code> <code class="m">1</code><code class="p">]</code>

  <code class="c1">## ...but not if there are zero real cherries</code>
  <code class="c1">### (cherries is coerced to FALSE where cherries == 0)</code>
  prize<code class="p">[</code><code class="o">!</code>cherries<code class="p">]</code> <code class="o">&lt;-</code> <code class="m">0</code>

  <code class="c1"># Step 2: Change prize for combinations that contain three of a kind</code>
  same <code class="o">&lt;-</code> symbols<code class="p">[,</code> <code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[,</code> <code class="m">2</code><code class="p">]</code> <code class="o">&amp;</code>
    symbols<code class="p">[,</code> <code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[,</code> <code class="m">3</code><code class="p">]</code>
  payoffs <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code>
    <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code> <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
  prize<code class="p">[</code>same<code class="p">]</code> <code class="o">&lt;-</code> payoffs<code class="p">[</code>symbols<code class="p">[</code>same<code class="p">,</code> <code class="m">1</code><code class="p">]]</code>

  <code class="c1"># Step 3: Change prize for combinations that contain all bars ------</code>
  bars <code class="o">&lt;-</code> symbols <code class="o">==</code> <code class="s">"B"</code> <code class="o">|</code> symbols <code class="o">==</code>  <code class="s">"BB"</code> <code class="o">|</code> symbols <code class="o">==</code> <code class="s">"BBB"</code>
  all_bars <code class="o">&lt;-</code> bars<code class="p">[,</code> <code class="m">1</code><code class="p">]</code> <code class="o">&amp;</code> bars<code class="p">[,</code> <code class="m">2</code><code class="p">]</code> <code class="o">&amp;</code> bars<code class="p">[,</code> <code class="m">3</code><code class="p">]</code> <code class="o">&amp;</code> <code class="o">!</code>same
  prize<code class="p">[</code>all_bars<code class="p">]</code> <code class="o">&lt;-</code> <code class="m">5</code>

  <code class="c1"># Step 4: Handle wilds ---------------------------------------------</code>

  <code class="c1">## combos with two diamonds</code>
  two_wilds <code class="o">&lt;-</code> diamonds <code class="o">==</code> <code class="m">2</code>

  <code class="c1">### Identify the nonwild symbol</code>
  one <code class="o">&lt;-</code> two_wilds <code class="o">&amp;</code> symbols<code class="p">[,</code> <code class="m">1</code><code class="p">]</code> <code class="o">!=</code> symbols<code class="p">[,</code> <code class="m">2</code><code class="p">]</code> <code class="o">&amp;</code>
    symbols<code class="p">[,</code> <code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[,</code> <code class="m">3</code><code class="p">]</code>
  two <code class="o">&lt;-</code> two_wilds <code class="o">&amp;</code> symbols<code class="p">[,</code> <code class="m">1</code><code class="p">]</code> <code class="o">!=</code> symbols<code class="p">[,</code> <code class="m">2</code><code class="p">]</code> <code class="o">&amp;</code>
    symbols<code class="p">[,</code> <code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[,</code> <code class="m">3</code><code class="p">]</code>
  three <code class="o">&lt;-</code> two_wilds <code class="o">&amp;</code> symbols<code class="p">[,</code> <code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[,</code> <code class="m">2</code><code class="p">]</code> <code class="o">&amp;</code>
    symbols<code class="p">[,</code> <code class="m">2</code><code class="p">]</code> <code class="o">!=</code> symbols<code class="p">[,</code> <code class="m">3</code><code class="p">]</code>

  <code class="c1">### Treat as three of a kind</code>
  prize<code class="p">[</code>one<code class="p">]</code> <code class="o">&lt;-</code> payoffs<code class="p">[</code>symbols<code class="p">[</code>one<code class="p">,</code> <code class="m">1</code><code class="p">]]</code>
  prize<code class="p">[</code>two<code class="p">]</code> <code class="o">&lt;-</code> payoffs<code class="p">[</code>symbols<code class="p">[</code>two<code class="p">,</code> <code class="m">2</code><code class="p">]]</code>
  prize<code class="p">[</code>three<code class="p">]</code> <code class="o">&lt;-</code> payoffs<code class="p">[</code>symbols<code class="p">[</code>three<code class="p">,</code> <code class="m">3</code><code class="p">]]</code>

  <code class="c1">## combos with one wild</code>
  one_wild <code class="o">&lt;-</code> diamonds <code class="o">==</code> <code class="m">1</code>

  <code class="c1">### Treat as all bars (if appropriate)</code>
  wild_bars <code class="o">&lt;-</code> one_wild <code class="o">&amp;</code> <code class="p">(</code>rowSums<code class="p">(</code>bars<code class="p">)</code> <code class="o">==</code> <code class="m">2</code><code class="p">)</code>
  prize<code class="p">[</code>wild_bars<code class="p">]</code> <code class="o">&lt;-</code> <code class="m">5</code>

  <code class="c1">### Treat as three of a kind (if appropriate)</code>
  one <code class="o">&lt;-</code> one_wild <code class="o">&amp;</code> symbols<code class="p">[,</code> <code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[,</code> <code class="m">2</code><code class="p">]</code>
  two <code class="o">&lt;-</code> one_wild <code class="o">&amp;</code> symbols<code class="p">[,</code> <code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[,</code> <code class="m">3</code><code class="p">]</code>
  three <code class="o">&lt;-</code> one_wild <code class="o">&amp;</code> symbols<code class="p">[,</code> <code class="m">3</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[,</code> <code class="m">1</code><code class="p">]</code>
  prize<code class="p">[</code>one<code class="p">]</code> <code class="o">&lt;-</code> payoffs<code class="p">[</code>symbols<code class="p">[</code>one<code class="p">,</code> <code class="m">1</code><code class="p">]]</code>
  prize<code class="p">[</code>two<code class="p">]</code> <code class="o">&lt;-</code> payoffs<code class="p">[</code>symbols<code class="p">[</code>two<code class="p">,</code> <code class="m">2</code><code class="p">]]</code>
  prize<code class="p">[</code>three<code class="p">]</code> <code class="o">&lt;-</code> payoffs<code class="p">[</code>symbols<code class="p">[</code>three<code class="p">,</code> <code class="m">3</code><code class="p">]]</code>

  <code class="c1"># Step 5: Double prize for every diamond in combo ------------------</code>
  unname<code class="p">(</code>prize <code class="o">*</code> <code class="m">2</code><code class="o">^</code>diamonds<code class="p">)</code>

<code class="p">}</code>

system.time<code class="p">(</code>play_many<code class="p">(</code><code class="m">10000000</code><code class="p">))</code>
<code class="c1">##   user  system elapsed</code>
<code class="c1">## 20.942   1.433  22.367</code></pre><div class="sect2" title="Loops Versus Vectorized Code"><div class="titlepage"><div><div><h3 class="title" id="_loops_versus_vectorized_code">Loops Versus Vectorized Code</h3></div></div></div><p>In many languages, <code class="literal">for</code> loops run very fast. As a result, programmers learn to use <code class="literal">for</code> loops whenever possible when they code. Often these programmers continue to rely on <code class="literal">for</code> loops when they begin to program in R, usually without taking the simple steps needed to optimize R’s <code class="literal">for</code> loops. These programmers may become disillusioned with R when their code does not work as fast as they would like. If you think that this may be happening to you, examine how often you are using <code class="literal">for</code> loops and what you are using them to do. If you find yourself using <code class="literal">for</code> loops for every task, there is a good chance that you are “speaking R with a C accent.” The cure is to learn to write and use vectorized code.<a id="id540923" class="indexterm"/><a id="id539304" class="indexterm"/></p><p>This doesn’t mean that <code class="literal">for</code> loops have no place in R. <code class="literal">for</code> loops are a very useful feature; they can do many things that vectorized code cannot do. You also should not become a slave to vectorized code. Sometimes it would take more time to rewrite code in vectorized format than to let a <code class="literal">for</code> loop run. For example, would it be faster to let the slot simulation run for 5.7 minutes or to rewrite <code class="literal">score</code>?</p></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_summary_10">Summary</h2></div></div></div><p>Fast code is an important component of data science because you can do more with fast code than you can do with slow code. You can work with larger data sets before computational constraints intervene, and you can do more computation before time constraints intervene. The fastest code in R will rely on the things that R does best: logical tests, subsetting, and element-wise execution. I’ve called this type of code vectorized code because code written with these operations will take a vector of values as input and operate on each element of the vector at the same time. The majority of the code written in R is already vectorized.<a id="id541011" class="indexterm"/></p><p>If you use these operations, but your code does not appear vectorized, analyze the sequential steps and parallel cases in your program. Ensure that you’ve used vectorized functions to handle the steps and logical subsetting to handle the cases. Be aware, however, that some tasks cannot be vectorized.</p></div><div class="sect1" title="Project 3 Wrap-up"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_project_3_wrap_up">Project 3 Wrap-up</h2></div></div></div><p>You have now written your first program in R, and it is a program that you should be proud of. <code class="literal">play</code> is not a simple <code class="literal">hello world</code> exercise, but a real program that does a real task in a complicated way.</p><p>Writing new programs in R will always be challenging because programming depends so much on your own creativity, problem-solving ability, and experience writing similar types of programs. However, you can use the suggestions in this chapter to make even the most complicated program manageable: divide tasks into simple steps and cases, work with concrete examples, and describe possible solutions in English.</p><p>This project completes the education you began in <a class="xref" href="ch01.html" title="Chapter 1. The Very Basics">Chapter 1</a>. You can now use R to handle data, which has augmented your ability to analyze data. You can:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">
Load and store data in your computer—not on paper or in your mind
</li><li class="listitem">
Accurately recall and change individual values without relying on your memory
</li><li class="listitem">
Instruct your computer to do tedious, or complex, tasks on your behalf
</li></ul></div><p>These skills solve an important logistical problem faced by every data scientist: <span class="emphasis"><em>how can you store and manipulate data without making errors?</em></span> However, this is not the only problem that you will face as a data scientist. The next problem will appear when you try to understand the information contained in your data. It is nearly impossible to spot insights or to discover patterns in raw data. A third problem will appear when you try to use your data set to reason about reality, which includes things not contained in your data set. What exactly does your data imply about things outside of the data set? How certain can you be?</p><p>I refer to these problems as the logistical, tactical, and strategic problems of data science, as shown in <a class="xref" href="ch10.html#FIGURE-PREFACE-VENN" title="Figure 10-4. The three core skill sets of data science: computer programming, data comprehension, and scientific reasoning.">Figure 10-4</a>. You’ll face them whenever you try to learn from data:<a id="id541105" class="indexterm"/></p><div class="variablelist"><dl><dt><span class="term">
A logistical problem
</span></dt><dd>
  How can you store and manipulate data without making errors?
</dd><dt><span class="term">
A tactical problem
</span></dt><dd>
  How can you discover the information contained in your data?
</dd><dt><span class="term">
A strategic problem
</span></dt><dd>
  How can you use the data to draw conclusions about the world at large?
</dd></dl></div><div class="figure"><a id="FIGURE-PREFACE-VENN"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_1004.png" alt="Data Science"/></div></div><div class="figure-title">Figure 10-4. The three core skill sets of data science: computer programming, data comprehension, and scientific reasoning.</div></div><p>A well-rounded data scientist will need to be able to solve each of these problems in many different situations. By learning to program in R, you have mastered the logistical problem, which is a prerequisite for solving the tactical and strategic problems.<a id="id541201" class="indexterm"/></p><p>If you would like to learn how to reason with data, or how to transform, visualize, and explore your data sets with R tools, I recommend the book <span class="emphasis"><em>Data Science with R</em></span>, the companion volume to this book. <span class="emphasis"><em>Data Science with R</em></span> teaches a simple workflow for transforming, visualizing, and modeling data in R, as well as how to report results with the R Markdown and Shiny packages. More importantly, <span class="emphasis"><em>Data Science with R</em></span> will teach you how to use your data to draw conclusions about the world at large, which is the real science of data science.</p></div></section></body></html>
