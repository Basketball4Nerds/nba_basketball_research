<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 6. Environments</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Project 2: Playing Cards"/><link rel="prev" href="ch05.html" title="Chapter 5. Modifying Values"/><link rel="next" href="pt03.html" title="Part III. Project 3: Slot Machine"/></head><body><section class="chapter" title="Chapter 6. Environments" epub:type="chapter" id="ENVIRONMENTS"><div class="titlepage"><div><div><h2 class="title">Chapter 6. Environments</h2></div></div></div><p>Your deck is now ready for a game of blackjack (or hearts or war), but are your <code class="literal">shuffle</code> and <code class="literal">deal</code> functions up to snuff? Definitely not. For example, <code class="literal">deal</code> deals the same card over and over again:</p><pre class="programlisting">deal<code class="p">(</code>deck<code class="p">)</code>
<code class="c1">## face   suit value</code>
<code class="c1">## king spades    13</code>

deal<code class="p">(</code>deck<code class="p">)</code>
<code class="c1">## face   suit value</code>
<code class="c1">## king spades    13</code>

deal<code class="p">(</code>deck<code class="p">)</code>
<code class="c1">## face   suit value</code>
<code class="c1">## king spades    13</code></pre><p>And the <code class="literal">shuffle</code> function doesn’t actually shuffle <code class="literal">deck</code> (it returns a copy of <code class="literal">deck</code> that has been shuffled). In short, both of these functions use <code class="literal">deck</code>, but neither manipulates <code class="literal">deck</code>—and we would like them to.</p><p>To fix these functions, you will need to learn how R stores, looks up, and manipulates objects like <code class="literal">deck</code>. R does all of these things with the help of an environment system.</p><div class="sect1" title="Environments"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_environments">Environments</h2></div></div></div><p>Consider for a moment how your computer stores files. Every file is saved in a folder, and each folder is saved in another folder, which forms a hierarchical file system. If your computer wants to open up a file, it must first look up the file in this file system.<a id="id515254" class="indexterm"/><a id="id515247" class="indexterm"/></p><p>You can see your file system by opening a finder window. For example, <a class="xref" href="ch06.html#FIGURE-ENVIRONMENTS-FOLDERS" title="Figure 6-1. Your computer arranges files into a hierarchy of folders and subfolders. To look at a file, you need to find where it is saved in the file system.">Figure 6-1</a> shows part of the file system on my computer. I have tons of folders. Inside one of them is a subfolder named <span class="emphasis"><em>Documents</em></span>, inside of that subfolder is a sub-subfolder named <span class="keep-together">ggsubplot</span>, inside of that folder is a folder named <span class="emphasis"><em>inst</em></span>, inside of that is a folder named <span class="emphasis"><em>doc</em></span>, and inside of that is a file named <span class="emphasis"><em>manual.pdf</em></span>.</p><div class="figure"><a id="FIGURE-ENVIRONMENTS-FOLDERS"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0601.png" alt=""/></div></div><div class="figure-title">Figure 6-1. Your computer arranges files into a hierarchy of folders and subfolders. To look at a file, you need to find where it is saved in the file system.</div></div><p>R uses a similar system to save R objects. Each object is saved inside of an environment, a list-like object that resembles a folder on your computer. Each environment is connected to a <span class="emphasis"><em>parent environment</em></span>, a higher-level environment, which creates a hierarchy of environments.<a id="id515326" class="indexterm"/></p><p>You can see R’s environment system with the <code class="literal">parenvs</code> function in the devtools package. <code class="literal">parenvs(all = TRUE)</code> will return a list of the environments that your R session is using.<a id="id515343" class="indexterm"/><a id="id515352" class="indexterm"/><a id="id466422" class="indexterm"/><a id="id466430" class="indexterm"/> The actual output will vary from session to session depending on which packages you have loaded. Here’s the output from my current session:</p><pre class="programlisting">library<code class="p">(</code>devtools<code class="p">)</code>
parenvs<code class="p">(</code>all <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
<code class="c1">##    label                            name</code>
<code class="c1">## 1  &lt;environment: R_GlobalEnv&gt;       ""</code>
<code class="c1">## 2  &lt;environment: package:devtools&gt;  "package:devtools"</code>
<code class="c1">## 3  &lt;environment: 0x7fff3321c388&gt;    "tools:rstudio"</code>
<code class="c1">## 4  &lt;environment: package:stats&gt;     "package:stats"</code>
<code class="c1">## 5  &lt;environment: package:graphics&gt;  "package:graphics"</code>
<code class="c1">## 6  &lt;environment: package:grDevices&gt; "package:grDevices"</code>
<code class="c1">## 7  &lt;environment: package:utils&gt;     "package:utils"</code>
<code class="c1">## 8  &lt;environment: package:datasets&gt;  "package:datasets"</code>
<code class="c1">## 9  &lt;environment: package:methods&gt;   "package:methods"</code>
<code class="c1">## 10 &lt;environment: 0x7fff3193dab0&gt;    "Autoloads"</code>
<code class="c1">## 11 &lt;environment: base&gt;              ""</code>
<code class="c1">## 12 &lt;environment: R_EmptyEnv&gt;        ""</code></pre><p>It takes some imagination to interpret this output, so let’s visualize the environments as a system of folders, <a class="xref" href="ch06.html#FIGURE-ENVIRONMENTS-ENVIRONMENTS" title="Figure 6-2. R stores R objects in an environment tree that resembles your computer’s folder system.">Figure 6-2</a>. You can think of the environment tree like this. The lowest-level environment is named <code class="literal">R_GlobalEnv</code> and is saved inside an environment named <code class="literal">package:devtools</code>, which is saved inside the environment named <code class="literal">0x7fff3321c388</code>, and so on, until you get to the final, highest-level environment, <code class="literal">R_EmptyEnv</code>. <code class="literal">R_EmptyEnv</code> is the only R environment that does not have a parent environment.<a id="id440068" class="indexterm"/></p><div class="figure"><a id="FIGURE-ENVIRONMENTS-ENVIRONMENTS"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0602.png" alt=""/></div></div><div class="figure-title">Figure 6-2. R stores R objects in an environment tree that resembles your computer’s folder system.</div></div><p>Remember that this example is just a metaphor. R’s environments exist in your RAM memory, and not in your file system. Also, R environments aren’t technically saved inside one another. Each environment is connected to a parent environment, which makes it easy to search up R’s environment tree. But this connection is one-way: there’s no way to look at one environment and tell what its “children” are. So you cannot search down R’s environment tree. In other ways, though, R’s environment system works similar to a file system.</p></div><div class="sect1" title="Working with Environments"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_working_with_environments">Working with Environments</h2></div></div></div><p>R comes with some helper functions that you can use to explore your environment tree.<a id="id440114" class="indexterm"/><a id="id440186" class="indexterm"/><a id="id440195" class="indexterm"/><a id="id440203" class="indexterm"/><a id="id440127" class="indexterm"/><a id="id440136" class="indexterm"/> First, you can refer to any of the environments in your tree with <code class="literal">as.environment</code>. <code class="literal">as.environment</code> takes an environment name (as a character string) and returns the corresponding environment:</p><pre class="programlisting">as.environment<code class="p">(</code><code class="s">"package:stats"</code><code class="p">)</code>
<code class="c1">## &lt;environment: package:stats&gt;</code>
<code class="c1">## attr(,"name")</code>
<code class="c1">## [1] "package:stats"</code>
<code class="c1">## attr(,"path")</code>
<code class="c1">## [1] "/Library/Frameworks/R.framework/Versions/3.0/Resources/library/stats"</code></pre><p>Three environments in your tree also come with their own accessor functions.<a id="id442994" class="indexterm"/><a id="id443003" class="indexterm"/><a id="id443012" class="indexterm"/><a id="id443020" class="indexterm"/><a id="id443027" class="indexterm"/><a id="id443036" class="indexterm"/> These are the global environment (<code class="literal">R_GlobalEnv</code>), the base environment (<code class="literal">base</code>), and the empty environment (<code class="literal">R_EmptyEnv</code>). You can refer to them with:</p><pre class="programlisting">globalenv<code class="p">()</code>
<code class="c1">## &lt;environment: R_GlobalEnv&gt;</code>

baseenv<code class="p">()</code>
<code class="c1">## &lt;environment: base&gt;</code>

emptyenv<code class="p">()</code>
<code class="c1">##&lt;environment: R_EmptyEnv&gt;</code></pre><p>Next, you can look up an environment’s parent<a id="id443096" class="indexterm"/><a id="id443102" class="indexterm"/> with <code class="literal">parent.env</code>:</p><pre class="programlisting">parent.env<code class="p">(</code>globalenv<code class="p">())</code>
<code class="c1">## &lt;environment: package:devtools&gt;</code>
<code class="c1">## attr(,"name")</code>
<code class="c1">## [1] "package:devtools"</code>
<code class="c1">## attr(,"path")</code>
<code class="c1">## [1] "/Library/Frameworks/R.framework/Versions/3.0/Resources/library/devtools"</code></pre><p>Notice that the empty environment is the only R environment without<a id="id467503" class="indexterm"/> a parent:</p><pre class="programlisting">parent.env<code class="p">(</code>emptyenv<code class="p">())</code>
<code class="c1">## Error in parent.env(emptyenv()) : the empty environment has no parent</code></pre><p>You can view the objects saved in an environment with <code class="literal">ls</code> or <code class="literal">ls.str</code>.<a id="id467543" class="indexterm"/><a id="id467552" class="indexterm"/><a id="id467560" class="indexterm"/><a id="id467566" class="indexterm"/><a id="id467575" class="indexterm"/><a id="id467581" class="indexterm"/> <code class="literal">ls</code> will return just the object names, but <code class="literal">ls.str</code> will display a little about each object’s structure:</p><pre class="programlisting">ls<code class="p">(</code>emptyenv<code class="p">())</code>
<code class="c1">## character(0)</code>

ls<code class="p">(</code>globalenv<code class="p">())</code>
<code class="c1">##  "deal"    "deck"    "deck2"   "deck3"   "deck4"   "deck5"</code>
<code class="c1">##  "die"     "gender"  "hand"    "lst"     "mat"     "mil"</code>
<code class="c1">##  "new"     "now"     "shuffle" "vec"</code></pre><p>The empty environment is—not surprisingly—empty; the base environment has too many objects to list here; and the global environment has some familiar faces. It is where R has saved all of the objects that you’ve created so far.<a id="id465182" class="indexterm"/><a id="id465191" class="indexterm"/><a id="id465197" class="indexterm"/></p><div class="tip" title="Tip"><h3 class="title">Tip</h3><p>RStudio’s environment pane displays all of the objects in your global environment.</p></div><p>You can use R’s <code class="literal">$</code> syntax to access an object in a specific environment.<a id="id465229" class="indexterm"/><a id="id465234" class="indexterm"/><a id="id465240" class="indexterm"/><a id="id465246" class="indexterm"/><a id="id465256" class="indexterm"/> For example, you can access <code class="literal">deck</code> from the global environment:</p><pre class="programlisting">head<code class="p">(</code>globalenv<code class="p">()</code><code class="o">$</code>deck<code class="p">,</code> <code class="m">3</code><code class="p">)</code>
<code class="c1">##  face   suit value</code>
<code class="c1">##  king spades    13</code>
<code class="c1">## queen spades    12</code>
<code class="c1">##  jack spades    11</code></pre><p>And you can use the <code class="literal">assign</code> function to save an object into a particular environment.<a id="id374654" class="indexterm"/><a id="id374657" class="indexterm"/><a id="id374665" class="indexterm"/><a id="id374671" class="indexterm"/> First give <code class="literal">assign</code> the name of the new object (as a character string). Then give <code class="literal">assign</code> the value of the new object, and finally the environment to save the object in:</p><pre class="programlisting">assign<code class="p">(</code><code class="s">"new"</code><code class="p">,</code> <code class="s">"Hello Global"</code><code class="p">,</code> envir <code class="o">=</code> globalenv<code class="p">())</code>

globalenv<code class="p">()</code><code class="o">$</code>new
<code class="c1">## "Hello Global"</code></pre><p>Notice that <code class="literal">assign</code> works similar to <code class="literal">&lt;-</code>. If an object already exists with the given name in the given environment, <code class="literal">assign</code> will overwrite it without asking for permission. This makes <code class="literal">assign</code> useful for updating objects but creates the potential for heartache.<a id="id374774" class="indexterm"/><a id="id374776" class="indexterm"/><a id="id374783" class="indexterm"/></p><p>Now that you can explore R’s environment tree, let’s examine how R uses it. R works closely with the environment tree to look up objects, store objects, and evaluate functions. How R does each of these tasks will depend on the current active environment.</p><div class="sect2" title="The Active Environment"><div class="titlepage"><div><div><h3 class="title" id="_the_active_environment">The Active Environment</h3></div></div></div><p>At any moment of time, R is working closely with a single environment. R will store new objects in this environment (if you create any), and R will use this environment as a starting point to look up existing objects (if you call any). I’ll call this special environment the <span class="emphasis"><em>active environment</em></span>. The active environment is usually the global environment, but this may change when you run a function.<a id="id497346" class="indexterm"/><a id="id497361" class="indexterm"/><a id="id497367" class="indexterm"/><a id="id497375" class="indexterm"/></p><p>You can use <code class="literal">environment</code> to see the current active environment:</p><pre class="programlisting">environment<code class="p">()</code>
<code class="o">&lt;</code>environment<code class="o">:</code> R_GlobalEnv<code class="o">&gt;</code></pre><p>The global environment plays a special role in R. It is the active environment for every command that you run at the command line. As a result, any object that you create at the command line will be saved in the global environment. You can think of the global environment as your user workspace.</p><p>When you call an object at the command line, R will look for it first in the global environment. But what if the object is not there? In that case, R will follow a series of rules to look up the object.</p></div></div><div class="sect1" title="Scoping Rules"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_scoping_rules">Scoping Rules</h2></div></div></div><p>R follows a special set of rules to look up objects.<a id="id497488" class="indexterm"/><a id="id497490" class="indexterm"/><a id="id497496" class="indexterm"/> These rules are known as R’s scoping rules, and you’ve already met a couple of them:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
R looks for objects in the current active environment.
</li><li class="listitem">
When you work at the command line, the active environment is the global environment. Hence, R looks up objects that you call at the command line in the global environment.
</li></ol></div><p>Here is a third rule that explains how R finds objects that are not in the active environment:</p><div class="orderedlist"><ol class="orderedlist" start="3" type="1"><li class="listitem">
When R does not find an object in an environment, R looks in the environment’s parent environment, then the parent of the parent, and so on, until R finds the object or reaches the empty environment.
</li></ol></div><p>So, if you call an object at the command line, R will look for it in the global environment. If R can’t find it there, R will look in the parent of the global environment, and then the parent of the parent, and so on, working its way up the environment tree until it finds the object, as in <a class="xref" href="ch06.html#FIGURE-ENVIRONMENTS-PATH" title="Figure 6-3. R will search for an object by name in the active environment, here the global environment. If R does not find the object there, it will search in the active environment’s parent, and then the parent’s parent, and so on until R finds the object or runs out of environments.">Figure 6-3</a>. If R cannot find the object in any environment, it will return an error that says the object is not found.<a id="id453071" class="indexterm"/></p><div class="figure"><a id="FIGURE-ENVIRONMENTS-PATH"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0603.png" alt=""/></div></div><div class="figure-title">Figure 6-3. R will search for an object by name in the active environment, here the global environment. If R does not find the object there, it will search in the active environment’s parent, and then the parent’s parent, and so on until R finds the object or runs out of environments.</div></div><div class="tip" title="Tip"><h3 class="title">Tip</h3><p>Remember that functions are a type of object in R. R will store and look up functions the same way it stores and looks up other objects, by searching for them by name in the environment tree.<a id="id453136" class="indexterm"/><a id="id453138" class="indexterm"/></p></div></div><div class="sect1" title="Assignment"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_assignment">Assignment</h2></div></div></div><p>When you assign a value to an object, R saves the value in the active environment under the object’s name. If an object with the same name already exists in the active environment, R will overwrite it.<a id="id453191" class="indexterm"/><a id="id453168" class="indexterm"/><a id="id453175" class="indexterm"/><a id="id453183" class="indexterm"/></p><p>For example, an object named <code class="literal">new</code> exists in the global environment:</p><pre class="programlisting">new
<code class="c1">## "Hello Global"</code></pre><p>You can save a new object named <code class="literal">new</code> to the global environment with this command. R will overwrite the old object as a result:</p><pre class="programlisting">new <code class="o">&lt;-</code> <code class="s">"Hello Active"</code>

new
<code class="c1">## "Hello Active"</code></pre><p>This arrangement creates a quandry for R whenever R runs a function. Many functions save temporary objects that help them do their jobs. For example, the <code class="literal">roll</code> function from <a class="xref" href="pt01.html" title="Part I. Project 1: Weighted Dice">Part I</a> saved an object named <code class="literal">die</code> and an object named <code class="literal">dice</code>:</p><pre class="programlisting">roll <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  die <code class="o">&lt;-</code> <code class="m">1</code><code class="o">:</code><code class="m">6</code>
  dice <code class="o">&lt;-</code> sample<code class="p">(</code>die<code class="p">,</code> size <code class="o">=</code> <code class="m">2</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
  sum<code class="p">(</code>dice<code class="p">)</code>
<code class="p">}</code></pre><p>R must save these temporary objects in the active environment; but if R does that, it may overwrite existing objects. Function authors cannot guess ahead of time which names may already exist in your active environment. How does R avoid this risk? Every time R runs a function, it creates a new active environment to evaluate the function in.<a id="id467131" class="indexterm"/><a id="id467269" class="indexterm"/></p></div><div class="sect1" title="Evaluation"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_evaluation">Evaluation</h2></div></div></div><p>R creates a new environment <span class="emphasis"><em>each</em></span> time it evaluates a function. R will use the new environment as the active environment while it runs the function, and then R will return to the environment that you called the function from, bringing the function’s result with it. Let’s call these new environments <span class="emphasis"><em>runtime environments</em></span> because R creates them at runtime to evaluate functions.<a id="id453651" class="indexterm"/><a id="id453646" class="indexterm"/><a id="ix_Eeval" class="indexterm"/><a id="ix_eval" class="indexterm"/></p><p>We’ll use the following function to explore R’s runtime environments.<a id="id453726" class="indexterm"/><a id="id453717" class="indexterm"/> We want to know what the environments look like: what are their parent environments, and what objects do they contain? <code class="literal">show_env</code> is designed to tell us:</p><pre class="programlisting">show_env <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(){</code>
  list<code class="p">(</code>ran.in <code class="o">=</code> environment<code class="p">(),</code>
    parent <code class="o">=</code> parent.env<code class="p">(</code>environment<code class="p">()),</code>
    objects <code class="o">=</code> ls.str<code class="p">(</code>environment<code class="p">()))</code>
<code class="p">}</code></pre><p><code class="literal">show_env</code> is itself a function, so when we call <code class="literal">show_env()</code>, R will create a runtime environment to evaluate the function in. The results of <code class="literal">show_env</code> will tell us the name of the runtime environment, its parent, and which objects the runtime environment contains:</p><pre class="programlisting">show_env<code class="p">()</code>
<code class="c1">## $ran.in</code>
<code class="c1">## &lt;environment: 0x7ff711d12e28&gt;</code>
<code class="c1">##</code>
<code class="c1">## $parent</code>
<code class="c1">## &lt;environment: R_GlobalEnv&gt;</code>
<code class="c1">##</code>
<code class="c1">## $objects</code></pre><p>The results reveal that R created a new environment named <code class="literal">0x7ff711d12e28</code> to run <code class="literal">show_env()</code> in. The environment had no objects in it, and its parent was the <code class="literal">global environment</code>. So for purposes of running <code class="literal">show_env</code>, R’s environment tree looked like <a class="xref" href="ch06.html#FIGURE-ENVIRONMENTS-TREE" title="Figure 6-4. R creates a new environment to run show_env in. The environment is a child of the global environment.">Figure 6-4</a>.</p><p>Let’s run <code class="literal">show_env</code> again:</p><pre class="programlisting">show_env<code class="p">()</code>
<code class="c1">## $ran.in</code>
<code class="c1">## &lt;environment: 0x7ff715f49808&gt;</code>
<code class="c1">##</code>
<code class="c1">## $parent</code>
<code class="c1">## &lt;environment: R_GlobalEnv&gt;</code>
<code class="c1">##</code>
<code class="c1">## $objects</code></pre><p>This time <code class="literal">show_env</code> ran in a new environment, <code class="literal">0x7ff715f49808</code>.  R creates a new environment <span class="emphasis"><em>each</em></span> time you run a function. The <code class="literal">0x7ff715f49808</code> environment looks exactly the same as <code class="literal">0x7ff711d12e28</code>. It is empty and has the same global environment as its parent.</p><div class="figure"><a id="FIGURE-ENVIRONMENTS-TREE"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0604.png" alt=""/></div></div><div class="figure-title">Figure 6-4. R creates a new environment to run show_env in. The environment is a child of the global environment.</div></div><p>Now let’s consider which environment R will use as the parent of the runtime environment.</p><p>R will connect a function’s runtime environment to the environment that the function <span class="emphasis"><em>was first created in</em></span>.<a id="id462774" class="indexterm"/><a id="id462793" class="indexterm"/> This environment plays an important role in the function’s life—because all of the function’s runtime environments will use it as a parent. Let’s call this environment the <span class="emphasis"><em>origin environment</em></span>. You can look up a function’s origin environment by running <code class="literal">environment</code> on the function:</p><pre class="programlisting">environment<code class="p">(</code>show_env<code class="p">)</code>
<code class="c1">## &lt;environment: R_GlobalEnv&gt;</code></pre><p>The origin environment of <code class="literal">show_env</code> is the global environment because we created <code class="literal">show_env</code> at the command line, but the origin environment does not need to be the global environment. For example, the environment of <code class="literal">parenvs</code> is the <code class="literal">devtools</code> package:</p><pre class="programlisting">environment<code class="p">(</code>parenvs<code class="p">)</code>
<code class="c1">## &lt;environment: namespace:devtools&gt;</code></pre><p>In other words, the parent of a runtime environment will not always be the global environment; it will be whichever environment the function was first created in.</p><p>Finally, let’s look at the objects contained in a runtime environment. At the moment, <code class="literal">show_env</code>’s runtime environments do not contain any objects, but that is easy to fix. Just have <code class="literal">show_env</code> create some objects in its body of code. R will store any objects created by <code class="literal">show_env</code> in its runtime environment. Why? Because the runtime environment will be the active environment when those objects are created:</p><pre class="programlisting">show_env <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(){</code>
  a <code class="o">&lt;-</code> <code class="m">1</code>
  b <code class="o">&lt;-</code> <code class="m">2</code>
  c <code class="o">&lt;-</code> <code class="m">3</code>
  list<code class="p">(</code>ran.in <code class="o">=</code> environment<code class="p">(),</code>
    parent <code class="o">=</code> parent.env<code class="p">(</code>environment<code class="p">()),</code>
    objects <code class="o">=</code> ls.str<code class="p">(</code>environment<code class="p">()))</code>
<code class="p">}</code></pre><p>This time when we run <code class="literal">show_env</code>, R stores <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> in the runtime environment:</p><pre class="programlisting">show_env<code class="p">()</code>
<code class="c1">## $ran.in</code>
<code class="c1">## &lt;environment: 0x7ff712312cd0&gt;</code>
<code class="c1">##</code>
<code class="c1">## $parent</code>
<code class="c1">## &lt;environment: R_GlobalEnv&gt;</code>
<code class="c1">##</code>
<code class="c1">## $objects</code>
<code class="c1">## a :  num 1</code>
<code class="c1">## b :  num 2</code>
<code class="c1">## c :  num 3</code></pre><p>This is how R ensures that a function does not overwrite anything that it shouldn’t. Any objects created by the function are stored in a safe, out-of-the-way runtime environment.</p><p>R will also put a second type of object in a runtime environment. If a function has arguments, R will copy over each argument to the runtime environment. The argument will appear as an object that has the name of the argument but the value of whatever input the user provided for the argument. This ensures that a function will be able to find and use each of its arguments:</p><pre class="programlisting">foo <code class="o">&lt;-</code> <code class="s">"take me to your runtime"</code>

show_env <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>x <code class="o">=</code> foo<code class="p">){</code>
  list<code class="p">(</code>ran.in <code class="o">=</code> environment<code class="p">(),</code>
    parent <code class="o">=</code> parent.env<code class="p">(</code>environment<code class="p">()),</code>
    objects <code class="o">=</code> ls.str<code class="p">(</code>environment<code class="p">()))</code>
<code class="p">}</code>

show_env<code class="p">()</code>
<code class="c1">## $ran.in</code>
<code class="c1">## &lt;environment: 0x7ff712398958&gt;</code>
<code class="c1">##</code>
<code class="c1">## $parent</code>
<code class="c1">## &lt;environment: R_GlobalEnv&gt;</code>
<code class="c1">##</code>
<code class="c1">## $objects</code>
<code class="c1">## x :  chr "take me to your runtime"</code></pre><p>Let’s put this all together to see how R evaluates a function. Before you call a function, R is working in an active environment; let’s call this the <span class="emphasis"><em>calling environment</em></span>. It is the environment R calls the function from.<a id="id516087" class="indexterm"/><a id="id516066" class="indexterm"/></p><p>Then you call the function. R responds by setting up a new runtime environment. This environment will be a child of the function’s origin enviornment. R will copy each of the function’s arguments into the runtime environment and then make the runtime environment the new active environment.</p><p>Next, R runs the code in the body of the function. If the code creates any objects, R stores them in the active, that is, runtime environment. If the code calls any objects, R uses its scoping rules to look them up. R will search the runtime environment, then the parent of the runtime environment (which will be the origin environment), then the parent of the origin environment, and so on. Notice that the calling environment might not be on the search path. Usually, a function will only call its arguments, which R can find in the active runtime environment.</p><p>Finally, R finishes running the function. It switches the active environment back to the calling environment. Now R executes any other commands in the line of code that called the function. So if you save the result of the function to an object with <code class="literal">&lt;-</code>, the new object will be stored in the calling environment.</p><p>To recap, R stores its objects in an environment system. At any moment of time, R is working closely with a single active environment. It stores new objects in this environment, and it uses the environment as a starting point when it searches for existing objects. R’s active environment is usually the global environment, but R will adjust the active environment to do things like run functions in a safe manner.</p><p>How can you use this knowledge to fix the <code class="literal">deal</code> and <code class="literal">shuffle</code> functions?</p><p>First, let’s start with a warm-up question. Suppose I redefine <code class="literal">deal</code> at the command line like this:</p><pre class="programlisting">deal <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  deck<code class="p">[</code><code class="m">1</code><code class="p">,</code> <code class="p">]</code>
<code class="p">}</code></pre><p>Notice that <code class="literal">deal</code> no longer takes an argument, and it calls the <code class="literal">deck</code> object, which lives in the global environment.</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Will R be able to find <code class="literal">deck</code> and return an answer when I call the new version of <code class="literal">deal</code>, such as <code class="literal">deal()</code>?</p></div><p>Yes. <code class="literal">deal</code> will still work the same as before. R will run <code class="literal">deal</code> in a runtime environment that is a child of the global environment. Why will it be a child of the global environment? Because the global environment is the origin environment of <code class="literal">deal</code> (we defined <code class="literal">deal</code> in the global environment):</p><pre class="programlisting">environment<code class="p">(</code>deal<code class="p">)</code>
<code class="c1">## &lt;environment: R_GlobalEnv&gt;</code></pre><p>When <code class="literal">deal</code> calls <code class="literal">deck</code>, R will need to look up the <code class="literal">deck</code> object. R’s scoping rules will lead it to the version of <code class="literal">deck</code> in the global environment, as in <a class="xref" href="ch06.html#FIGURE-ENVIRONMENTS-DEAL" title="Figure 6-5. R finds deck by looking in the parent of deal’s runtime environment. The parent is the global environment, deal’s origin environment. Here, R finds the copy of deck.">Figure 6-5</a>. <code class="literal">deal</code> works as expected as a result:</p><pre class="programlisting">deal<code class="p">()</code>
<code class="c1">##  face   suit value</code>
<code class="c1">##  king spades    13</code></pre><div class="figure"><a id="FIGURE-ENVIRONMENTS-DEAL"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0605.png" alt=""/></div></div><div class="figure-title">Figure 6-5. R finds deck by looking in the parent of deal’s runtime environment. The parent is the global environment, deal’s origin environment. Here, R finds the copy of deck.</div></div><p>Now let’s fix the <code class="literal">deal</code> function to remove the cards it has dealt from <code class="literal">deck</code>.<a id="id496732" class="indexterm"/> Recall that <code class="literal">deal</code> returns the top card of <code class="literal">deck</code> but does not remove the card from the deck. As a result, <code class="literal">deal</code> always returns the same card:</p><pre class="programlisting">deal<code class="p">()</code>
<code class="c1">##  face   suit value</code>
<code class="c1">##  king spades    13</code>

deal<code class="p">()</code>
<code class="c1">##  face   suit value</code>
<code class="c1">##  king spades    13</code></pre><p>You know enough R syntax to remove the top card of <code class="literal">deck</code>. The following code will save a prisitine copy of <code class="literal">deck</code> and then remove the top card:</p><pre class="programlisting">DECK <code class="o">&lt;-</code> deck

deck <code class="o">&lt;-</code> deck<code class="p">[</code><code class="m">-1</code><code class="p">,</code> <code class="p">]</code>

head<code class="p">(</code>deck<code class="p">,</code> <code class="m">3</code><code class="p">)</code>
<code class="c1">##  face   suit value</code>
<code class="c1">## queen spades    12</code>
<code class="c1">##  jack spades    11</code>
<code class="c1">##   ten spades    10</code></pre><p>Now let’s add the code to <code class="literal">deal</code>. Here <code class="literal">deal</code> saves (and then returns) the top card of <code class="literal">deck</code>. In between, it removes the card from <code class="literal">deck</code>…or does it?</p><pre class="programlisting">deal <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  card <code class="o">&lt;-</code> deck<code class="p">[</code><code class="m">1</code><code class="p">,</code> <code class="p">]</code>
  deck <code class="o">&lt;-</code> deck<code class="p">[</code><code class="m">-1</code><code class="p">,</code> <code class="p">]</code>
  card
<code class="p">}</code></pre><p>This code won’t work because R will be in a runtime environment when it executes <code class="literal">deck &lt;- deck[-1, ]</code>. Instead of overwriting the global copy of <code class="literal">deck</code> with <code class="literal">deck[-1, ]</code>, <code class="literal">deal</code> will just create a slightly altered copy of <code class="literal">deck</code> in its runtime environment, as in <a class="xref" href="ch06.html#FIGURE-SECOND-DECK" title="Figure 6-6. The deal function looks up deck in the global environment but saves deck[-1, ] in the runtime environment as a new object named deck.">Figure 6-6</a>.</p><div class="figure"><a id="FIGURE-SECOND-DECK"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0606.png" alt=""/></div></div><div class="figure-title">Figure 6-6. The deal function looks up deck in the global environment but saves deck[-1, ] in the runtime environment as a new object named deck.</div></div><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Rewrite the <code class="literal">deck &lt;- deck[-1, ]</code> line of <code class="literal">deal</code> to <span class="emphasis"><em>assign</em></span> <code class="literal">deck[-1, ]</code> to an object named <code class="literal">deck</code> in the global environment. Hint: consider the <code class="literal">assign</code> function.</p></div><p>You can assign an object to a specific environment with the <code class="literal">assign</code> function:</p><pre class="programlisting">deal <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  card <code class="o">&lt;-</code> deck<code class="p">[</code><code class="m">1</code><code class="p">,</code> <code class="p">]</code>
  assign<code class="p">(</code><code class="s">"deck"</code><code class="p">,</code> deck<code class="p">[</code><code class="m">-1</code><code class="p">,</code> <code class="p">],</code> envir <code class="o">=</code> globalenv<code class="p">())</code>
  card
<code class="p">}</code></pre><p>Now <code class="literal">deal</code> will finally clean up the global copy of <code class="literal">deck</code>, and we can <code class="literal">deal</code> cards just as we would in real life:</p><pre class="programlisting">deal<code class="p">()</code>
<code class="c1">##  face   suit value</code>
<code class="c1">## queen spades    12</code>

deal<code class="p">()</code>
<code class="c1">## face   suit value</code>
<code class="c1">## jack spades    11</code>

deal<code class="p">()</code>
<code class="c1">## face   suit value</code>
<code class="c1">##  ten spades    10</code></pre><p>Let’s turn our attention to the <code class="literal">shuffle</code> function:</p><pre class="programlisting">shuffle <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>cards<code class="p">)</code> <code class="p">{</code>
  random <code class="o">&lt;-</code> sample<code class="p">(</code><code class="m">1</code><code class="o">:</code><code class="m">52</code><code class="p">,</code> size <code class="o">=</code> <code class="m">52</code><code class="p">)</code>
  cards<code class="p">[</code>random<code class="p">,</code> <code class="p">]</code>
<code class="p">}</code></pre><p><code class="literal">shuffle(deck)</code> doesn’t shuffle the <code class="literal">deck</code> object; it returns a shuffled copy of the <code class="literal">deck</code> object:</p><pre class="programlisting">head<code class="p">(</code>deck<code class="p">,</code> <code class="m">3</code><code class="p">)</code>
<code class="c1">##  face   suit value</code>
<code class="c1">##  nine spades     9</code>
<code class="c1">## eight spades     8</code>
<code class="c1">## seven spades     7</code>

a <code class="o">&lt;-</code> shuffle<code class="p">(</code>deck<code class="p">)</code>

head<code class="p">(</code>deck<code class="p">,</code> <code class="m">3</code><code class="p">)</code>
<code class="c1">##  face   suit value</code>
<code class="c1">##  nine spades     9</code>
<code class="c1">## eight spades     8</code>
<code class="c1">## seven spades     7</code>

head<code class="p">(</code>a<code class="p">,</code> <code class="m">3</code><code class="p">)</code>
<code class="c1">##  face     suit value</code>
<code class="c1">##   ace diamonds     1</code>
<code class="c1">## seven    clubs     7</code>
<code class="c1">##   two    clubs     2</code></pre><p>This behavior is now undesirable in two ways. First, <code class="literal">shuffle</code> fails to shuffle <code class="literal">deck</code>. Second, <code class="literal">shuffle</code> returns a copy of <code class="literal">deck</code>, which may be missing the cards that have been dealt away. It would be better if <code class="literal">shuffle</code> returned the dealt cards to the deck and then shuffled. This is what happens when you shuffle a deck of cards in real life.</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Rewrite <code class="literal">shuffle</code> so that it replaces the copy of <code class="literal">deck</code> that lives in the global environment with a shuffled version of <code class="literal">DECK</code>, the intact copy of <code class="literal">deck</code> that also lives in the global environment. The new version of <code class="literal">shuffle</code> should have no arguments and return no output.</p></div><p>You can update <code class="literal">shuffle</code> in the same way that you updated <code class="literal">deck</code>. The following version will do the job:</p><pre class="programlisting">shuffle <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(){</code>
  random <code class="o">&lt;-</code> sample<code class="p">(</code><code class="m">1</code><code class="o">:</code><code class="m">52</code><code class="p">,</code> size <code class="o">=</code> <code class="m">52</code><code class="p">)</code>
  assign<code class="p">(</code><code class="s">"deck"</code><code class="p">,</code> DECK<code class="p">[</code>random<code class="p">,</code> <code class="p">],</code> envir <code class="o">=</code> globalenv<code class="p">())</code>
<code class="p">}</code></pre><p>Since <code class="literal">DECK</code> lives in the global environment, <code class="literal">shuffle</code>’s environment of origin, <code class="literal">shuffle</code> will be able to find <code class="literal">DECK</code> at runtime. R will search for <code class="literal">DECK</code> first in <code class="literal">shuffle</code>’s runtime environment, and then in <code class="literal">shuffle</code>’s origin environment—the global environment—which is where <code class="literal">DECK</code> is stored.</p><p>The second line of <code class="literal">shuffle</code> will create a reordered copy of <code class="literal">DECK</code> and save it as <code class="literal">deck</code> in the global environment. This will overwrite the previous, nonshuffled version of <code class="literal">deck</code>.<a id="id470833" class="indexterm"/><a id="id470830" class="indexterm"/><a id="id470844" class="indexterm"/></p></div><div class="sect1" title="Closures"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_closures">Closures</h2></div></div></div><p>Our system finally works.<a id="id470862" class="indexterm"/><a id="id470872" class="indexterm"/> For example, you can shuffle the cards and then deal a hand of blackjack:</p><pre class="programlisting">shuffle<code class="p">()</code>

deal<code class="p">()</code>
<code class="c1">##  face   suit value</code>
<code class="c1">## queen hearts    12</code>

deal<code class="p">()</code>
<code class="c1">##  face   suit value</code>
<code class="c1">## eight hearts     8</code></pre><p>But the system requires <code class="literal">deck</code> and <code class="literal">DECK</code> to exist in the global environment. Lots of things happen in this environment, and it is possible that <code class="literal">deck</code> may get modified or erased by accident.</p><p>It would be better if we could store <code class="literal">deck</code> in a safe, out-of-the-way place, like one of those safe, out-of-the-way environments that R creates to run functions in. In fact, storing <code class="literal">deck</code> in a runtime environment is not such a bad idea.<a id="id468709" class="indexterm"/></p><p>You could create a function that takes <code class="literal">deck</code> as an argument and saves a copy of <code class="literal">deck</code> as <code class="literal">DECK</code>. The function could also save its own copies of <code class="literal">deal</code> and <code class="literal">shuffle</code>:</p><pre class="programlisting">setup <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>deck<code class="p">)</code> <code class="p">{</code>
  DECK <code class="o">&lt;-</code> deck

  DEAL <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
    card <code class="o">&lt;-</code> deck<code class="p">[</code><code class="m">1</code><code class="p">,</code> <code class="p">]</code>
    assign<code class="p">(</code><code class="s">"deck"</code><code class="p">,</code> deck<code class="p">[</code><code class="m">-1</code><code class="p">,</code> <code class="p">],</code> envir <code class="o">=</code> globalenv<code class="p">())</code>
    card
  <code class="p">}</code>

  SHUFFLE <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(){</code>
    random <code class="o">&lt;-</code> sample<code class="p">(</code><code class="m">1</code><code class="o">:</code><code class="m">52</code><code class="p">,</code> size <code class="o">=</code> <code class="m">52</code><code class="p">)</code>
    assign<code class="p">(</code><code class="s">"deck"</code><code class="p">,</code> DECK<code class="p">[</code>random<code class="p">,</code> <code class="p">],</code> envir <code class="o">=</code> globalenv<code class="p">())</code>
 <code class="p">}</code>
<code class="p">}</code></pre><p>When you run <code class="literal">setup</code>, R will create a runtime environment to store these objects in. The environment will look like <a class="xref" href="ch06.html#FIGURE-ENVIRONMENTS-CLOSURE1" title="Figure 6-7. Running setup will store deck and DECK in an out-of-the-way place, and create a DEAL and SHUFFLE function. Each of these objects will be stored in an environment whose parent is the global environment.">Figure 6-7</a>.</p><p>Now all of these things are safely out of the way in a child of the global environment. That makes them safe but hard to use. Let’s ask <code class="literal">setup</code> to return <code class="literal">DEAL</code> and <code class="literal">SHUFFLE</code> so we can use them. The best way to do this is to return the functions as a list:</p><pre class="programlisting">setup <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>deck<code class="p">)</code> <code class="p">{</code>
  DECK <code class="o">&lt;-</code> deck

  DEAL <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
    card <code class="o">&lt;-</code> deck<code class="p">[</code><code class="m">1</code><code class="p">,</code> <code class="p">]</code>
    assign<code class="p">(</code><code class="s">"deck"</code><code class="p">,</code> deck<code class="p">[</code><code class="m">-1</code><code class="p">,</code> <code class="p">],</code> envir <code class="o">=</code> globalenv<code class="p">())</code>
    card
  <code class="p">}</code>

  SHUFFLE <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(){</code>
    random <code class="o">&lt;-</code> sample<code class="p">(</code><code class="m">1</code><code class="o">:</code><code class="m">52</code><code class="p">,</code> size <code class="o">=</code> <code class="m">52</code><code class="p">)</code>
    assign<code class="p">(</code><code class="s">"deck"</code><code class="p">,</code> DECK<code class="p">[</code>random<code class="p">,</code> <code class="p">],</code> envir <code class="o">=</code> globalenv<code class="p">())</code>
 <code class="p">}</code>

 list<code class="p">(</code>deal <code class="o">=</code> DEAL<code class="p">,</code> shuffle <code class="o">=</code> SHUFFLE<code class="p">)</code>
<code class="p">}</code>

cards <code class="o">&lt;-</code> setup<code class="p">(</code>deck<code class="p">)</code></pre><div class="figure"><a id="FIGURE-ENVIRONMENTS-CLOSURE1"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0607.png.jpg" alt=""/></div></div><div class="figure-title">Figure 6-7. Running setup will store deck and DECK in an out-of-the-way place, and create a DEAL and SHUFFLE function. Each of these objects will be stored in an environment whose parent is the global environment.</div></div><p>Then you can save each of the elements of the list to a dedicated object in the global environment:</p><pre class="programlisting">deal <code class="o">&lt;-</code> cards<code class="o">$</code>deal
shuffle <code class="o">&lt;-</code> cards<code class="o">$</code>shuffle</pre><p>Now you can run <code class="literal">deal</code> and <code class="literal">shuffle</code> just as before. Each object contains the same code as the original <code class="literal">deal</code> and <code class="literal">shuffle</code>:</p><pre class="programlisting">deal
<code class="c1">## function() {</code>
<code class="c1">##     card &lt;- deck[1, ]</code>
<code class="c1">##     assign("deck", deck[-1, ], envir = globalenv())</code>
<code class="c1">##     card</code>
<code class="c1">##   }</code>
<code class="c1">## &lt;environment: 0x7ff7169c3390&gt;</code>

shuffle
<code class="c1">## function(){</code>
<code class="c1">##     random &lt;- sample(1:52, size = 52)</code>
<code class="c1">##     assign("deck", DECK[random, ], envir = globalenv())</code>
<code class="c1">##  }</code>
<code class="c1">## &lt;environment: 0x7ff7169c3390&gt;</code></pre><p>However, the functions now have one important difference. Their origin environment is no longer the global environment (although <code class="literal">deal</code> and <code class="literal">shuffle</code> <span class="emphasis"><em>are</em></span> currently saved there). Their origin environment is the runtime environment that R made when you ran <code class="literal">setup</code>. That’s where R created <code class="literal">DEAL</code> and <code class="literal">SHUFFLE</code>, the functions copied into the new <code class="literal">deal</code> and <code class="literal">shuffle</code>, as shown in:</p><pre class="programlisting">environment<code class="p">(</code>deal<code class="p">)</code>
<code class="c1">## &lt;environment: 0x7ff7169c3390&gt;</code>

environment<code class="p">(</code>shuffle<code class="p">)</code>
<code class="c1">## &lt;environment: 0x7ff7169c3390&gt;</code></pre><p>Why does this matter? Because now when you run <code class="literal">deal</code> or <code class="literal">shuffle</code>, R will evaluate the functions in a runtime environment that uses <code class="literal">0x7ff7169c3390</code> as its parent. <code class="literal">DECK</code> and <code class="literal">deck</code> will be in this parent environment, which means that <code class="literal">deal</code> and <code class="literal">shuffle</code> will be able to find them at runtime. <code class="literal">DECK</code> and <code class="literal">deck</code> will be in the functions’ search path but still out of the way in every other respect, as shown in <a class="xref" href="ch06.html#FIGURE-ENVIRONMENTS-CLOSURE2" title="Figure 6-8. Now deal and shuffle will be run in an environment that has the protected deck and DECK in its search path.">Figure 6-8</a>.</p><div class="figure"><a id="FIGURE-ENVIRONMENTS-CLOSURE2"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0608.png.jpg" alt=""/></div></div><div class="figure-title">Figure 6-8. Now deal and shuffle will be run in an environment that has the protected deck and DECK in its search path.</div></div><p>This arrangement is called a <span class="emphasis"><em>closure</em></span>. <code class="literal">setup</code>’s runtime environment “encloses” the <code class="literal">deal</code> and <code class="literal">shuffle</code> functions. Both <code class="literal">deal</code> and <code class="literal">shuffle</code> can work closely with the objects contained in the enclosing environment, but almost nothing else can. The enclosing environment is not on the search path for any other R function or environment.</p><p>You may have noticed that <code class="literal">deal</code> and <code class="literal">shuffle</code> still update the <code class="literal">deck</code> object in the global environment. Don’t worry, we’re about to change that. We want <code class="literal">deal</code> and <code class="literal">shuffle</code> to work exclusively with the objects in the parent (enclosing) environment of their runtime environments. Instead of having each function reference the global environment to update <code class="literal">deck</code>, you can have them reference their parent environment at runtime, as shown in <a class="xref" href="ch06.html#FIGURE-ENVIRONMENTS-CLOSURE3" title="Figure 6-9. When you change your code, deal and shuffle will go from updating the global environment (left) to updating their parent environment (right).">Figure 6-9</a>:</p><pre class="programlisting">setup <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>deck<code class="p">)</code> <code class="p">{</code>
  DECK <code class="o">&lt;-</code> deck

  DEAL <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
    card <code class="o">&lt;-</code> deck<code class="p">[</code><code class="m">1</code><code class="p">,</code> <code class="p">]</code>
    assign<code class="p">(</code><code class="s">"deck"</code><code class="p">,</code> deck<code class="p">[</code><code class="m">-1</code><code class="p">,</code> <code class="p">],</code> envir <code class="o">=</code> parent.env<code class="p">(</code>environment<code class="p">()))</code>
    card
  <code class="p">}</code>

  SHUFFLE <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(){</code>
    random <code class="o">&lt;-</code> sample<code class="p">(</code><code class="m">1</code><code class="o">:</code><code class="m">52</code><code class="p">,</code> size <code class="o">=</code> <code class="m">52</code><code class="p">)</code>
    assign<code class="p">(</code><code class="s">"deck"</code><code class="p">,</code> DECK<code class="p">[</code>random<code class="p">,</code> <code class="p">],</code> envir <code class="o">=</code> parent.env<code class="p">(</code>environment<code class="p">()))</code>
 <code class="p">}</code>

 list<code class="p">(</code>deal <code class="o">=</code> DEAL<code class="p">,</code> shuffle <code class="o">=</code> SHUFFLE<code class="p">)</code>
<code class="p">}</code>

cards <code class="o">&lt;-</code> setup<code class="p">(</code>deck<code class="p">)</code>
deal <code class="o">&lt;-</code> cards<code class="o">$</code>deal
shuffle <code class="o">&lt;-</code> cards<code class="o">$</code>shuffle</pre><div class="figure"><a id="FIGURE-ENVIRONMENTS-CLOSURE3"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0609.png" alt=""/></div></div><div class="figure-title">Figure 6-9. When you change your code, deal and shuffle will go from updating the global environment (left) to updating their parent environment (right).</div></div><p>We finally have a self-contained card game. You can delete (or modify) the global copy of <code class="literal">deck</code> as much as you want and still play cards. <code class="literal">deal</code> and <code class="literal">shuffle</code> will use the pristine, protected copy of <code class="literal">deck</code>:</p><pre class="programlisting">rm<code class="p">(</code>deck<code class="p">)</code>

shuffle<code class="p">()</code>

deal<code class="p">()</code>
<code class="c1">## face   suit value</code>
<code class="c1">##  ace hearts     1</code>

deal<code class="p">()</code>
<code class="c1">## face  suit value</code>
<code class="c1">## jack clubs    11</code></pre><p>Blackjack!</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_summary_6">Summary</h2></div></div></div><p>R saves its objects in an environment system that resembles your computer’s file system. If you understand this system, you can predict how R will look up objects. If you call an object at the command line, R will look for the object in the global environment and then the parents of the global environment, working its way up the environment tree one environment at a time.</p><p>R will use a slightly different search path when you call an object from inside of a function. When you run a function, R creates a new environment to execute commands in. This environment will be a child of the environment where the function was originally defined. This may be the global environment, but it also may not be.  You can use this behavior to create closures, which are functions linked to objects in protected environments.</p><p>As you become familiar with R’s environment system, you can use it to produce elegant results, like we did here. However, the real value of understanding the environment system comes from knowing how R functions do their job. You can use this knowledge to figure out what is going wrong when a function does not perform as expected.</p></div><div class="sect1" title="Project 2 Wrap-up"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_project_2_wrap_up">Project 2 Wrap-up</h2></div></div></div><p>You now have full control over the data sets and values that you load into R. You can store data as R objects, you can retrieve and manipulate data values at will, and you can even predict how R will store and look up your objects in your computer’s memory.</p><p>You may not realize it yet, but your expertise makes you a powerful, computer-augmented data user. You can use R to save and work with larger data sets than you could otherwise handle. So far we’ve only worked with <code class="literal">deck</code>, a small data set; but you can use the same techniques to work with any data set that fits in your computer’s memory.</p><p>However, storing data is not the only logistical task that you will face as a data scientist. You will often want to do tasks with your data that are so complex or repetitive that they are difficult to do without a computer. Some of the things can be done with functions that already exist in R and its packages, but others cannot. You will be the most versatile as a data scientist if you can write your own programs for computers to follow. R can help you do this. When you are ready, <a class="xref" href="pt03.html" title="Part III. Project 3: Slot Machine">Part III</a> will teach you the most useful skills for writing programs in R.</p></div></section></body></html>
