<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 7. Programs</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt03.html" title="Part III. Project 3: Slot Machine"/><link rel="prev" href="pt03.html" title="Part III. Project 3: Slot Machine"/><link rel="next" href="ch08.html" title="Chapter 8. S3"/></head><body><section class="chapter" title="Chapter 7. Programs" epub:type="chapter" id="PROGRAMS"><div class="titlepage"><div><div><h2 class="title">Chapter 7. Programs</h2></div></div></div><p>In this chapter, you will build a real, working slot machine that you can play by running an R function. When you’re finished, you’ll be able to play it like this:</p><pre class="programlisting">play<code class="p">()</code>
<code class="c1">## 0 0 DD</code>
<code class="c1">## $0</code>

play<code class="p">()</code>
<code class="c1">## 7 7 7</code>
<code class="c1">## $80</code></pre><p>The <code class="literal">play</code> function will need to do two things. First, it will need to randomly generate three symbols; and, second, it will need to calculate a prize based on those symbols.<a id="id433070" class="indexterm"/></p><p>The first step is easy to simulate. You can randomly generate three symbols with the <code class="literal">sample</code> function—just like you randomly “rolled” two dice in <a class="xref" href="pt01.html" title="Part I. Project 1: Weighted Dice">Part I</a>.<a id="id433063" class="indexterm"/> The following function generates three symbols from a group of common slot machine symbols: diamonds (<code class="literal">DD</code>), sevens (<code class="literal">7</code>), triple bars (<code class="literal">BBB</code>), double bars (<code class="literal">BB</code>), single bars (<code class="literal">B</code>), cherries (<code class="literal">C</code>), and zeroes (<code class="literal">0</code>). The symbols are selected randomly, and each symbol appears with a different probability:</p><pre class="programlisting">get_symbols <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  wheel <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code><code class="p">,</code> <code class="s">"7"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"B"</code><code class="p">,</code> <code class="s">"C"</code><code class="p">,</code> <code class="s">"0"</code><code class="p">)</code>
  sample<code class="p">(</code>wheel<code class="p">,</code> size <code class="o">=</code> <code class="m">3</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">,</code>
    prob <code class="o">=</code> c<code class="p">(</code><code class="m">0.03</code><code class="p">,</code> <code class="m">0.03</code><code class="p">,</code> <code class="m">0.06</code><code class="p">,</code> <code class="m">0.1</code><code class="p">,</code> <code class="m">0.25</code><code class="p">,</code> <code class="m">0.01</code><code class="p">,</code> <code class="m">0.52</code><code class="p">))</code>
<code class="p">}</code></pre><p>You can use <code class="literal">get_symbols</code> to generate the symbols used in your slot machine:</p><pre class="programlisting">get_symbols<code class="p">()</code>
<code class="c1">## "BBB" "0"   "C"</code>

get_symbols<code class="p">()</code>
<code class="c1">## "0" "0" "0"</code>

get_symbols<code class="p">()</code>
<code class="c1">## "7" "0" "B"</code></pre><p><code class="literal">get_symbols</code> uses the probabilities observed in a group of video lottery terminals from Manitoba, Canada.<a id="id500888" class="indexterm"/> These slot machines became briefly controversial in the 1990s, when a reporter decided to test their payout rate. The machines appeared to pay out only 40 cents on the dollar, even though the manufacturer claimed they would pay out 92 cents on the dollar. The original data collected on the machines and a description of the controversy is available online in <a class="ulink" href="http://bit.ly/jse_Braun" target="_top">a journal article by W. John Braun</a>. The controversy died down when additional testing showed that the manufacturer was correct.</p><p>The Manitoba slot machines use the complicated payout scheme shown in <a class="xref" href="ch07.html#TABLE-SLOTS-PRIZES" title="Table 7-1. Each play of the slot machine costs $1. A player’s symbols determine how much they win. Diamonds (DD) are wild, and each diamond doubles the final prize. * = any symbol.">Table 7-1</a>. A player will win a prize if he gets:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Three of the same type of symbol (except for three zeroes)
</li><li class="listitem">
Three bars (of mixed variety)
</li><li class="listitem">
One or more cherries
</li></ol></div><p>Otherwise, the player receives no prize.</p><p>The monetary value of the prize is determined by the exact combination of symbols and is further modified by the presence of diamonds. Diamonds are treated like “wild cards,” which means they can be considered any other symbol if it would increase a player’s prize. For example, a player who rolls <code class="literal">7</code> <code class="literal">7</code> <code class="literal">DD</code> would earn a prize for getting three sevens. There is one exception to this rule, however: a diamond cannot be considered a cherry unless the player also gets one real cherry. This prevents a dud roll like, <code class="literal">0</code> <code class="literal">DD</code> <code class="literal">0</code> from being scored as <code class="literal">0</code> <code class="literal">C</code> <code class="literal">0</code>.</p><p>Diamonds are also special in another way. Every diamond that appears in a combination doubles the amount of the final prize. So <code class="literal">7</code> <code class="literal">7</code> <code class="literal">DD</code> would actually be scored <span class="emphasis"><em>higher</em></span> than <code class="literal">7</code> <code class="literal">7</code> <code class="literal">7</code>. Three sevens would earn you $80, but two sevens and a diamond would earn you $160. One seven and two diamonds would be even better, resulting in a prize that has been doubled twice, or $320. A jackpot occurs when a player rolls <code class="literal">DD</code> <code class="literal">DD</code> <code class="literal">DD</code>. Then a player earns $100 doubled three times, which is $800.</p><div class="table"><a id="TABLE-SLOTS-PRIZES"/><div class="table-title">Table 7-1. Each play of the slot machine costs $1. A player’s symbols determine how much they win. Diamonds (<code class="literal">DD</code>) are wild, and each diamond doubles the final prize. * = any symbol.</div><div class="table-contents"><table style="width: 50%; border-collapse: collapse; border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="col_1"/><col class="col_2"/></colgroup><thead><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; ">Combination</td><td style="border-bottom: 0.5pt solid ; ">Prize($)</td></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">DD  DD  DD</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>100</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">7  7  7</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>80</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BBB  BBB  BBB</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>40</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">BB  BB  BB</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>25</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">B  B  B</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>10</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">C  C  C</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>10</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p>Any combination of bars</p></td><td style="border-bottom: 0.5pt solid ; "><p>5</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">C  C  *</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>5</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">C  *  C</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>5</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">*  C  C</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>5</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">C  *  *</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>2</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "><p><code class="literal">*  C  *</code></p></td><td style="border-bottom: 0.5pt solid ; "><p>2</p></td></tr><tr><td style="border-right: 0.5pt solid ; "><p><code class="literal">*  *  C</code></p></td><td><p>2</p></td></tr></tbody></table></div></div><p>To create your <code class="literal">play</code> function, you will need to write a program that can take the output of <code class="literal">get_symbols</code> and calculate the correct prize based on  <a class="xref" href="ch07.html#TABLE-SLOTS-PRIZES" title="Table 7-1. Each play of the slot machine costs $1. A player’s symbols determine how much they win. Diamonds (DD) are wild, and each diamond doubles the final prize. * = any symbol.">Table 7-1</a>.<a id="id473384" class="indexterm"/></p><p>In R, programs are saved either as R scripts or as functions.<a id="id473404" class="indexterm"/><a id="id473416" class="indexterm"/><a id="id473422" class="indexterm"/><a id="id473429" class="indexterm"/><a id="id473437" class="indexterm"/> We’ll save your program as a function named <code class="literal">score</code>. When you are finished, you will be able to use <code class="literal">score</code> to calculate a prize like this:</p><pre class="programlisting">score<code class="p">(</code>c<code class="p">(</code><code class="s">"DD"</code><code class="p">,</code> <code class="s">"DD"</code><code class="p">,</code> <code class="s">"DD"</code><code class="p">))</code>
<code class="c1">## 800</code></pre><p>After that it will be easy to create the full slot machine, like this:</p><pre class="programlisting">play <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  symbols <code class="o">&lt;-</code> get_symbols<code class="p">()</code>
  print<code class="p">(</code>symbols<code class="p">)</code> <a id="CO6-1"/><img src="callouts/1.png" alt="1"/>
  score<code class="p">(</code>symbols<code class="p">)</code>
<code class="p">}</code></pre><div class="calloutlist"><dl><dt><a href="#CO6-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
The <code class="literal">print</code> command prints its output to the console window, which makes <code class="literal">print</code> a useful way to display messages from within the body of a function.<a id="id490732" class="indexterm"/><a id="id490720" class="indexterm"/><a id="id490740" class="indexterm"/><a id="id490749" class="indexterm"/>
</p></dd></dl></div><p>You may notice that <code class="literal">play</code> calls a new function, <code class="literal">print</code>. This will help <code class="literal">play</code> display the three slot machine symbols, since they do not get returned by the last line of the function. The <code class="literal">print</code> command prints its output to the console window — even if R calls it from within a function.</p><p>In <a class="xref" href="pt01.html" title="Part I. Project 1: Weighted Dice">Part I</a>, I encouraged you to write all of your R code in an R script, a text file where you can compose and save code. That advice will become very important as you work through this chapter. Remember that you can open an R script in RStudio by going to the menu bar and clicking on File &gt; New File &gt; R Script.<a id="id490803" class="indexterm"/></p><div class="sect1" title="Strategy"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_strategy">Strategy</h2></div></div></div><p>Scoring slot-machine results is a complex task that will require a complex algorithm.<a id="id490822" class="indexterm"/><a id="id490811" class="indexterm"/> You can make this, and other coding tasks, easier by using a simple strategy:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Break complex tasks into simple subtasks.
</li><li class="listitem">
Use concrete examples.
</li><li class="listitem">
Describe your solutions in English, then convert them to R.
</li></ol></div><p>Let’s start by looking at how you can divide a program into subtasks that are simple to work with.</p><p>A program is a set of step-by-step instructions for your computer to follow. Taken together, these instructions may accomplish something very sophisticated. Taken apart, each individual step will likely be simple and straightforward.</p><p>You can make coding easier by identifying the individual steps or subtasks within your program. You can then work on each subtask separately. If a subtask seems complicated, try to divide it again into even subtasks that are even more simple. You can often reduce an R program into substasks so simple that each can be performed with a preexisting function.</p><p>R programs contain two types of subtasks: sequential steps and parallel cases.</p><div class="sect2" title="Sequential Steps"><div class="titlepage"><div><div><h3 class="title" id="_sequential_steps">Sequential Steps</h3></div></div></div><p>One way to subdivide a program is into a series of sequential steps.<a id="id490930" class="indexterm"/><a id="id490925" class="indexterm"/><a id="id490892" class="indexterm"/><a id="id490898" class="indexterm"/> The <code class="literal">play</code> function takes the approach, shown in <a class="xref" href="ch07.html#FIGURE-SUBDIVIDE1" title="Figure 7-1. The play function uses a series of steps.">Figure 7-1</a>. First, it generates three symbols (step 1), then it displays them in the console window (step 2), and then it scores them (step 3):</p><pre class="programlisting">play <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>

  <code class="c1"># step 1: generate symbols</code>
  symbols <code class="o">&lt;-</code> get_symbols<code class="p">()</code>

  <code class="c1"># step 2: display the symbols</code>
  print<code class="p">(</code>symbols<code class="p">)</code>

  <code class="c1"># step 3: score the symbols</code>
  score<code class="p">(</code>symbols<code class="p">)</code>
<code class="p">}</code></pre><p>To have R execute steps in sequence, place the steps one after another in an R script or function body.</p><div class="figure"><a id="FIGURE-SUBDIVIDE1"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0701.png" alt="Subtasks in play"/></div></div><div class="figure-title">Figure 7-1. The play function uses a series of steps.</div></div></div><div class="sect2" title="Parallel Cases"><div class="titlepage"><div><div><h3 class="title" id="_parallel_cases">Parallel Cases</h3></div></div></div><p>Another way to divide a task is to spot groups of similar cases within the task. Some tasks require different algorithms for different groups of input. If you can identify those groups, you can work out their algorithms one at a time.<a id="id491087" class="indexterm"/><a id="id491082" class="indexterm"/><a id="id491089" class="indexterm"/></p><p>For example, <code class="literal">score</code> will need to calculate the prize one way if <code class="literal">symbols</code> contains three of a kind (In that case, <code class="literal">score</code> will need to match the common symbol to a prize). <code class="literal">score</code> will need to calculate the prize a second way if the symbols are all bars (In that case, <code class="literal">score</code> can just assign a prize of $5). And, finally, <code class="literal">score</code> will need to calculate the prize in a third way if the symbols do not contain three of a kind or all bars (In that case, <code class="literal">score</code> must count the number of cherries present). <code class="literal">score</code> will never use all three of these algorithms at once; it will always choose just one algorithm to run based on the combination of symbols.<a id="id491154" class="indexterm"/></p><p>Diamonds complicate all of this because diamonds can be treated as wild cards. Let’s ignore that for now and focus on the simpler case where diamonds double the prize but are not wilds. <code class="literal">score</code> can double the prize as necessary after it runs one of the following algorithms, as shown in <a class="xref" href="ch07.html#FIGURE-SUBDIVIDE2" title="Figure 7-2. The score function must distinguish between parallel cases.">Figure 7-2</a>.</p><p>Adding the <code class="literal">score</code> cases to the <code class="literal">play</code> steps reveals a strategy for the complete slot machine program, as shown in <a class="xref" href="ch07.html#FIGURE-SUBDIVIDE3" title="Figure 7-3. The complete slot machine simulation will involve subtasks that are arranged both in series and in parallel.">Figure 7-3</a>.</p><p>We’ve already solved the first few steps in this strategy. Our program can get three slot machine symbols with the <code class="literal">get_symbols</code> function. Then it can display the symbols with the <code class="literal">print</code> function. Now let’s examine how the program can handle the parallel score cases.</p><div class="figure"><a id="FIGURE-SUBDIVIDE2"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0702.png" alt="Subtasks in score."/></div></div><div class="figure-title">Figure 7-2. The score function must distinguish between parallel cases.</div></div><div class="figure"><a id="FIGURE-SUBDIVIDE3"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0703.png.jpg" alt="Subtasks in the slot machine simulation"/></div></div><div class="figure-title">Figure 7-3. The complete slot machine simulation will involve subtasks that are arranged both in series and in parallel.</div></div></div></div><div class="sect1" title="if Statements"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_if_statements">if Statements</h2></div></div></div><p>Linking cases together in parallel requires a bit of structure; your program faces a fork in the road whenever it must choose between cases. You can help the program navigate this fork with an <code class="literal">if</code> statement.<a id="id514169" class="indexterm"/><a id="id514180" class="indexterm"/></p><p>An <code class="literal">if</code> statement tells R to do a certain task for a certain case. In English you would say something like, “If this is true, do that.” In R, you would say:</p><pre class="programlisting"><code class="kr">if</code> <code class="p">(</code>this<code class="p">)</code> <code class="p">{</code>
  that
<code class="p">}</code></pre><p>The <code class="literal">this</code> object should be a logical test or an R expression that evaluates to a single <code class="literal">TRUE</code> or <code class="literal">FALSE</code>. If <code class="literal">this</code> evaluates to <code class="literal">TRUE</code>, R will run all of the code that appears between the braces that follow the <code class="literal">if</code> statement (i.e., between the <code class="literal">{</code> and <code class="literal">}</code> symbols). If <code class="literal">this</code> evaluates to <code class="literal">FALSE</code>, R will skip the code between the braces without running it.<a id="id514283" class="indexterm"/><a id="id514279" class="indexterm"/><a id="id514289" class="indexterm"/><a id="id514295" class="indexterm"/><a id="id514301" class="indexterm"/><a id="id514307" class="indexterm"/><a id="id514313" class="indexterm"/></p><p>For example, you could write an <code class="literal">if</code> statement that ensures some object, <code class="literal">num</code>, is positive:</p><pre class="programlisting"><code class="kr">if</code> <code class="p">(</code>num <code class="o">&lt;</code> <code class="m">0</code><code class="p">)</code> <code class="p">{</code>
  num <code class="o">&lt;-</code> num <code class="o">*</code> <code class="m">-1</code>
<code class="p">}</code></pre><p>If <code class="literal">num &lt; 0</code> is <code class="literal">TRUE</code>, R will multiply <code class="literal">num</code> by negative one, which will make <code class="literal">num</code> positive:</p><pre class="programlisting">num <code class="o">&lt;-</code> <code class="m">-2</code>

<code class="kr">if</code> <code class="p">(</code>num <code class="o">&lt;</code> <code class="m">0</code><code class="p">)</code> <code class="p">{</code>
  num <code class="o">&lt;-</code> num <code class="o">*</code> <code class="m">-1</code>
<code class="p">}</code>

num
<code class="c1">## 2</code></pre><p>If <code class="literal">num &lt; 0</code> is <code class="literal">FALSE</code>, R will do nothing and <code class="literal">num</code> will remain as it is—positive (or zero):</p><pre class="programlisting">num <code class="o">&lt;-</code> <code class="m">4</code>

<code class="kr">if</code> <code class="p">(</code>num <code class="o">&lt;</code> <code class="m">0</code><code class="p">)</code> <code class="p">{</code>
  num <code class="o">&lt;-</code> num <code class="o">*</code> <code class="m">-1</code>
<code class="p">}</code>

num
<code class="c1">## 4</code></pre><p>The condition of an <code class="literal">if</code> statement must evaluate to a <span class="emphasis"><em>single</em></span> <code class="literal">TRUE</code> or <code class="literal">FALSE</code>. If the condition creates a vector of <code class="literal">TRUE</code>s and <code class="literal">FALSE</code>s (which is easier to make than you may think), your <code class="literal">if</code> statement will print a warning message and use only the first element of the vector. Remember that you can condense vectors of logical values to a single <code class="literal">TRUE</code> or <code class="literal">FALSE</code> with the functions <code class="literal">any</code> and <code class="literal">all</code>.<a id="id514625" class="indexterm"/><a id="id514632" class="indexterm"/><a id="id514651" class="indexterm"/><a id="id514658" class="indexterm"/><a id="id495364" class="indexterm"/></p><p>You don’t have to limit your <code class="literal">if</code> statements to a single line of code; you can include as many lines as you like between the braces. For example, the following code uses many lines to ensure that <code class="literal">num</code> is positive. The additional lines print some informative statements if <code class="literal">num</code> begins as a negative number. R will skip the entire code block—<code class="literal">print</code> statements and all—if <code class="literal">num</code> begins as a positive number:</p><pre class="programlisting">num <code class="o">&lt;-</code> <code class="m">-1</code>

<code class="kr">if</code> <code class="p">(</code>num <code class="o">&lt;</code> <code class="m">0</code><code class="p">)</code> <code class="p">{</code>
  print<code class="p">(</code><code class="s">"num is negative."</code><code class="p">)</code>
  print<code class="p">(</code><code class="s">"Don't worry, I'll fix it."</code><code class="p">)</code>
  num <code class="o">&lt;-</code> num <code class="o">*</code> <code class="m">-1</code>
  print<code class="p">(</code><code class="s">"Now num is positive."</code><code class="p">)</code>
<code class="p">}</code>
<code class="c1">## "num is negative."</code>
<code class="c1">## "Don't worry, I'll fix it."</code>
<code class="c1">## "Now num is positive."</code>

num
<code class="c1">## 1</code></pre><p>Try the following quizzes to develop your understanding of <code class="literal">if</code> statements.</p><div class="sidebar"><div class="sidebar-title">Quiz A</div><p>What will this return?</p><pre class="programlisting">x <code class="o">&lt;-</code> <code class="m">1</code>
<code class="kr">if</code> <code class="p">(</code><code class="m">3</code> <code class="o">==</code> <code class="m">3</code><code class="p">)</code> <code class="p">{</code>
  x <code class="o">&lt;-</code> <code class="m">2</code>
<code class="p">}</code>
x</pre><p><span class="emphasis"><em>Answer</em></span>: the code will return the number 2. <code class="literal">x</code> begins as 1, and then R encounters the <code class="literal">if</code> statement. Since the condition evaluates to <code class="literal">TRUE</code>, R will run <code class="literal">x &lt;- 2</code>, changing the value of <code class="literal">x</code>.</p></div><div class="sidebar"><div class="sidebar-title">Quiz B</div><p>What will this return?</p><pre class="programlisting">x <code class="o">&lt;-</code> <code class="m">1</code>
<code class="kr">if</code> <code class="p">(</code><code class="kc">TRUE</code><code class="p">)</code> <code class="p">{</code>
  x <code class="o">&lt;-</code> <code class="m">2</code>
<code class="p">}</code>
x</pre><p><span class="emphasis"><em>Answer</em></span>: this code will also return the number 2. It works the same as the code in Quiz A, except the condition in this statement is already <code class="literal">TRUE</code>. R doesn’t even need to evaluate it. As a result, the code inside the <code class="literal">if</code> statement will be run, and <code class="literal">x</code> will be set to 2.</p></div><div class="sidebar"><div class="sidebar-title">Quiz C</div><p>What will this return?</p><pre class="programlisting">x <code class="o">&lt;-</code> <code class="m">1</code>
<code class="kr">if</code> <code class="p">(</code>x <code class="o">==</code> <code class="m">1</code><code class="p">)</code> <code class="p">{</code>
  x <code class="o">&lt;-</code> <code class="m">2</code>
  <code class="kr">if</code> <code class="p">(</code>x <code class="o">==</code> <code class="m">1</code><code class="p">)</code> <code class="p">{</code>
    x <code class="o">&lt;-</code> <code class="m">3</code>
  <code class="p">}</code>
<code class="p">}</code>
x</pre><p><span class="emphasis"><em>Answer</em></span>: once again, the code will return the number 2. <code class="literal">x</code> starts out as 1, and the condition of the first <code class="literal">if</code> statement will evaluate to <code class="literal">TRUE</code>, which causes R to run the code in the body of the <code class="literal">if</code> statement. First, R sets <code class="literal">x</code> equal to 2, then R evaluates the second <code class="literal">if</code> statement, which is in the body of the first. This time <code class="literal">x == 1</code> will evaluate to <code class="literal">FALSE</code> because <code class="literal">x</code> now equals 2. As a result, R ignores <code class="literal">x &lt;- 3</code> and exits both <code class="literal">if</code> statements.</p></div></div><div class="sect1" title="else Statements"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_else_statements">else Statements</h2></div></div></div><p><code class="literal">if</code> statements tell R what to do when your condition is <span class="emphasis"><em>true</em></span>, but you can also tell R what to do when the condition is <span class="emphasis"><em>false</em></span>.<a id="ix_Pelse" class="indexterm"/><a id="ix_else" class="indexterm"/> <code class="literal">else</code> is a counterpart to <code class="literal">if</code> that extends an <code class="literal">if</code> statement to include a second case. In English, you would say, “If this is true, do plan A; else do plan B.” In R, you would say:</p><pre class="programlisting"><code class="kr">if</code> <code class="p">(</code>this<code class="p">)</code> <code class="p">{</code>
  Plan A
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  Plan B
<code class="p">}</code></pre><p>When <code class="literal">this</code> evaluates to <code class="literal">TRUE</code>, R will run the code in the first set of braces, but not the code in the second. When <code class="literal">this</code> evaluates to <code class="literal">FALSE</code>, R will run the code in the second set of braces, but not the first. You can use this arrangement to cover all of the possible cases. For example, you could write some code that rounds a decimal to the nearest integer.</p><p>Start with a decimal:</p><pre class="programlisting">a <code class="o">&lt;-</code> <code class="m">3.14</code></pre><p>Then isolate the decimal component with <code class="literal">trunc</code>:</p><pre class="programlisting">dec <code class="o">&lt;-</code> a <code class="o">-</code> trunc<code class="p">(</code>a<code class="p">)</code> <a id="CO7-1"/><img src="callouts/1.png" alt="1"/> <a id="CO7-2"/><img src="callouts/2.png" alt="2"/>
dec
<code class="c1">## 0.14</code></pre><div class="calloutlist"><dl><dt><a href="#CO7-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
<code class="literal">trunc</code> takes a number and returns only the portion of the number that appears to the left of the decimal place (i.e., the integer part of the number).
</p></dd><dt><a href="#CO7-2"><img src="callouts/2.png" alt="2"/></a> </dt><dd><p>
<code class="literal">a - trunc(a)</code> is a convenient way to return the decimal part of <code class="literal">a</code>.
</p></dd></dl></div><p>Then use an <code class="literal">if else</code> tree to round the number<a id="id427763" class="indexterm"/> (either up or down):</p><pre class="programlisting"><code class="kr">if</code> <code class="p">(</code>dec <code class="o">&gt;=</code> <code class="m">0.5</code><code class="p">)</code> <code class="p">{</code>
  a <code class="o">&lt;-</code> trunc<code class="p">(</code>a<code class="p">)</code> <code class="o">+</code> <code class="m">1</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  a <code class="o">&lt;-</code> trunc<code class="p">(</code>a<code class="p">)</code>
<code class="p">}</code>

a
<code class="c1">## 3</code></pre><p>If your situation has more than two mutually exclusive cases, you can string multiple <code class="literal">if</code> and <code class="literal">else</code> statements together by adding a new <code class="literal">if</code> statement immediately after <code class="literal">else</code>. For example:</p><pre class="programlisting">a <code class="o">&lt;-</code> <code class="m">1</code>
b <code class="o">&lt;-</code> <code class="m">1</code>

<code class="kr">if</code> <code class="p">(</code>a <code class="o">&gt;</code> b<code class="p">)</code> <code class="p">{</code>
  print<code class="p">(</code><code class="s">"A wins!"</code><code class="p">)</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>a <code class="o">&lt;</code> b<code class="p">)</code> <code class="p">{</code>
  print<code class="p">(</code><code class="s">"B wins!"</code><code class="p">)</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  print<code class="p">(</code><code class="s">"Tie."</code><code class="p">)</code>
<code class="p">}</code>
<code class="c1">## "Tie."</code></pre><p>R will work through the <code class="literal">if</code> conditions until one evaluates to <code class="literal">TRUE</code>, then R will ignore any remaining <code class="literal">if</code> and <code class="literal">else</code> clauses in the tree. If no conditions evaluate to <code class="literal">TRUE</code>, R will run the final <code class="literal">else</code> statement.</p><p>If two <code class="literal">if</code> statements describe mutually exclusive events, it is better to join the <code class="literal">if</code> statements with an <code class="literal">else if</code> than to list them separately. This lets R ignore the second <code class="literal">if</code> statement whenever the first returns a <code class="literal">TRUE</code>, which saves work.</p><p>You can use <code class="literal">if</code> and <code class="literal">else</code> to link the subtasks in your slot-machine function. Open a fresh R script, and copy this code into it. The code will be the skeleton of our final <code class="literal">score</code> function. Compare it to the flow chart for <code class="literal">score</code> in <a class="xref" href="ch07.html#FIGURE-SUBDIVIDE2" title="Figure 7-2. The score function must distinguish between parallel cases.">Figure 7-2</a>:</p><pre class="programlisting"><code class="kr">if</code> <code class="p">(</code> <code class="c1"># Case 1: all the same </code><a id="CO8-1"/><img src="callouts/1.png" alt="1"/><code class="p">)</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="c1"># look up the prize </code><a id="CO8-2"/><img src="callouts/2.png" alt="2"/>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code> <code class="c1"># Case 2: all bars </code><a id="CO8-3"/><img src="callouts/3.png" alt="3"/> <code class="p">)</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="c1"># assign $5 </code><a id="CO8-4"/><img src="callouts/4.png" alt="4"/>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  <code class="c1"># count cherries </code><a id="CO8-5"/><img src="callouts/5.png" alt="5"/>
  prize <code class="o">&lt;-</code> <code class="c1"># calculate a prize </code><a id="CO8-6"/><img src="callouts/6.png" alt="6"/>
<code class="p">}</code>

<code class="c1"># count diamonds </code><a id="CO8-7"/><img src="callouts/7.png" alt="7"/>
<code class="c1"># double the prize if necessary </code><a id="CO8-8"/><img src="callouts/8.png" alt="8"/></pre><p>Our skeleton is rather incomplete; there are many sections that are just code comments instead of real code.<a id="id428173" class="indexterm"/><a id="id428350" class="indexterm"/> However, we’ve reduced the program to eight simple subtasks:</p><div class="calloutlist"><dl><dt><a href="#CO8-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
Test whether the symbols are three of a kind.
</p></dd><dt><a href="#CO8-3"><img src="callouts/3.png" alt="3"/></a> </dt><dd><p>
Test whether the symbols are all bars.
</p></dd><dt><a href="#CO8-2"><img src="callouts/2.png" alt="2"/></a> </dt><dd><p>
Look up the prize for three of a kind based on the common symbol.
</p></dd><dt><a href="#CO8-4"><img src="callouts/4.png" alt="4"/></a> </dt><dd><p>
Assign a prize of $5.
</p></dd><dt><a href="#CO8-5"><img src="callouts/5.png" alt="5"/></a> </dt><dd><p>
Count the number of cherries.
</p></dd><dt><a href="#CO8-7"><img src="callouts/7.png" alt="7"/></a> </dt><dd><p>
Count the number of diamonds.
</p></dd><dt><a href="#CO8-6"><img src="callouts/6.png" alt="6"/></a> </dt><dd><p>
Calculate a prize based on the number of cherries.
</p></dd><dt><a href="#CO8-8"><img src="callouts/8.png" alt="8"/></a> </dt><dd><p>
Adjust the prize for diamonds.
</p></dd></dl></div><p>If you like, you can reorganize your flow chart around these tasks, as in <a class="xref" href="ch07.html#FIGURE-SUBDIVIDE4" title="Figure 7-4. score can navigate three cases with two if else decisions. We can also break some of our tasks into two steps.">Figure 7-4</a>. The chart will describe the same strategy, but in a more precise way. I’ll use a diamond shape to symbolize an <code class="literal">if else</code> decision.</p><div class="figure"><a id="FIGURE-SUBDIVIDE4"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0704.png.jpg" alt="More precise subtasks in score."/></div></div><div class="figure-title">Figure 7-4. score can navigate three cases with two if else decisions. We can also break some of our tasks into two steps.</div></div><p>Now we can work through the subtasks one at a time, adding R code to the <code class="literal">if</code> tree as we go. Each subtask will be easy to solve if you set up a concrete example to work with and try to describe a solution in English before coding in R.</p><p>The first subtask asks you to test whether the symbols are three of a kind. How should you begin writing the code for this subtask?<a id="id428499" class="indexterm"/></p><p>You know that the final <code class="literal">score</code> function will look something like this:</p><pre class="programlisting">score <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>symbols<code class="p">)</code> <code class="p">{</code>

  <code class="c1"># calculate a prize</code>

  prize
<code class="p">}</code></pre><p>Its argument, <code class="literal">symbols</code>, will be the output of <code class="literal">get_symbols</code>, a vector that contains three character strings. You could start writing <code class="literal">score</code> as I have written it, by defining an object named <code class="literal">score</code> and then slowly filling in the body of the function. However, this would be a bad idea. The eventual function will have eight separate parts, and it will not work correctly until <span class="emphasis"><em>all</em></span> of those parts are written (and themselves work correctly). This means you would have to write the entire <code class="literal">score</code> function before you could test any of the subtasks. If <code class="literal">score</code> doesn’t work—which is very likely—you will not know which subtask needs fixed.</p><p>You can save yourself time and headaches if you focus on one subtask at a time. For each subtask, create a concrete example that you can test your code on.<a id="id428624" class="indexterm"/><a id="id428596" class="indexterm"/> For example, you know that <code class="literal">score</code> will need to work on a vector named <code class="literal">symbols</code> that contains three character strings. If you make a real vector named <code class="literal">symbols</code>, you can run the code for many of your subtasks on the vector as you go:</p><pre class="programlisting">symbols <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"7"</code><code class="p">,</code> <code class="s">"7"</code><code class="p">,</code> <code class="s">"7"</code><code class="p">)</code></pre><p>If a piece of code does not work on <code class="literal">symbols</code>, you will know that you need to fix it before you move on. You can change the value of <code class="literal">symbols</code> from subtask to subtask to ensure that your code works in every situation:</p><pre class="programlisting">symbols <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>
symbols <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"C"</code><code class="p">,</code> <code class="s">"DD"</code><code class="p">,</code> <code class="s">"0"</code><code class="p">)</code></pre><p>Only combine your subtasks into a <code class="literal">score</code> function once each subtask works on a concrete example. If you follow this plan, you will spend more time using your functions and less time trying to figure out why they do not work.</p><p>After you set up a concrete example, try to describe how you will do the subtask in English. The more precisely you can describe your solution, the easier it will be to write your R code.</p><p>Our first subtask asks us to “test whether the symbols are three of a kind.” This phrase does not suggest any useful R code to me. However, I could describe a more precise test for three of a kind: three symbols will be the same if the first symbol is equal to the second and the second symbol is equal to the third. Or, even more precisely:</p><p><span class="emphasis"><em>A vector named <code class="literal">symbols</code> will contain three of the same symbol if the first element of <code class="literal">symbols</code> is equal to the second element of <code class="literal">symbols</code> and the second element of <code class="literal">symbols</code> is equal to the third element of <code class="literal">symbols</code></em></span>.</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Turn the preceding statement into a logical test written in R. Use your knowledge of logical tests, Boolean operators, and subsetting from <a class="xref" href="ch04.html" title="Chapter 4. R Notation">Chapter 4</a>. The test should work with the vector <code class="literal">symbols</code> and return a <code class="literal">TRUE</code> <span class="emphasis"><em>if and only if</em></span> each element in <code class="literal">symbols</code> is the same. Be sure to test your code on <code class="literal">symbols</code>.</p></div><p>Here are a couple of ways to test that <code class="literal">symbols</code> contains three of the same symbol. The first method parallels the English suggestion above, but there are other ways to do the same test. There is no right or wrong answer, so long as your solution works, which is easy to check because you’ve created a vector named <code class="literal">symbols</code>:</p><pre class="programlisting">symbols
<code class="c1">##  "7" "7" "7"</code>

symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
<code class="c1">## TRUE</code>

symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
<code class="c1">## TRUE</code>

all<code class="p">(</code>symbols <code class="o">==</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">])</code>
<code class="c1">## TRUE</code></pre><p>As your vocabulary of R functions broadens, you’ll think of more ways to do basic tasks. One method that I like for checking three of a kind is:</p><pre class="programlisting">length<code class="p">(</code>unique<code class="p">(</code>symbols<code class="p">)</code> <code class="o">==</code> <code class="m">1</code><code class="p">)</code></pre><p>The <code class="literal">unique</code> function returns every unique term that appears in a vector.<a id="id503516" class="indexterm"/><a id="id503511" class="indexterm"/> If your <code class="literal">symbols</code> vector contains three of a kind (i.e., one unique term that appears three times), then <code class="literal">unique(symbols)</code> will return a vector of length <code class="literal">1</code>.</p><p>Now that you have a working test, you can add it to your slot-machine script:</p><pre class="programlisting">same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code> <a id="CO9-1"/><img src="callouts/1.png" alt="1"/>

<code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="c1"># look up the prize</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code> <code class="c1"># Case 2: all bars ) {</code>
  prize <code class="o">&lt;-</code> <code class="c1"># assign $5</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  <code class="c1"># count cherries</code>
  prize <code class="o">&lt;-</code> <code class="c1"># calculate a prize</code>
<code class="p">}</code>

<code class="c1"># count diamonds</code>
<code class="c1"># double the prize if necessary</code></pre><div class="calloutlist"><dl><dt><a href="#CO9-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
<code class="literal">&amp;&amp;</code> and <code class="literal">||</code> behave like <code class="literal">&amp;</code> and <code class="literal">|</code> but can sometimes be more efficient. The double operators will not evaluate the second test in a pair of tests if the first test makes the result clear. For example, if <code class="literal">symbols[1]</code> does not equal <code class="literal">symbols[2]</code> in the next expression, <code class="literal">&amp;&amp;</code> will not evaluate <code class="literal">symbols[2] == symbols[3]</code>; it can immediately return a <code class="literal">FALSE</code> for the whole expression (because <code class="literal">FALSE &amp; TRUE</code> and <code class="literal">FALSE &amp; FALSE</code> both evaluate to <code class="literal">FALSE</code>). This efficiency can speed up your programs; however, double operators are not appropriate everywhere. <code class="literal">&amp;&amp;</code> and <code class="literal">||</code> are not vectorized, which means they can only handle a single logical test on each side of the operator.<a id="id503830" class="indexterm"/><a id="id503831" class="indexterm"/><a id="id503836" class="indexterm"/><a id="id503853" class="indexterm"/>
</p></dd></dl></div><p>The second prize case occurs when all the symbols are a type of bar, for example, <code class="literal">B</code>, <code class="literal">BB</code>, and <code class="literal">BBB</code>. Let’s begin by creating a concrete example to work with:</p><pre class="programlisting">symbols <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">)</code></pre><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Use R’s logical and Boolean operators to write a test that will determine whether a vector named <code class="literal">symbols</code> contains only symbols that are a type of bar. Check whether your test works with our example <code class="literal">symbols</code> vector. Remember to describe how the test should work in English, and then convert the solution to R.</p></div><p>As with many things in R, there are multiple ways to test whether <code class="literal">symbols</code> contains all bars. For example, you could write a very long test that uses multiple Boolean operators, like this:</p><pre class="programlisting">symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> <code class="s">"B"</code> <code class="o">|</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> <code class="s">"BB"</code> <code class="o">|</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> <code class="s">"BBB"</code> <code class="o">&amp;</code>
  symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> <code class="s">"B"</code> <code class="o">|</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> <code class="s">"BB"</code> <code class="o">|</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> <code class="s">"BBB"</code> <code class="o">&amp;</code>
  symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code> <code class="o">==</code> <code class="s">"B"</code> <code class="o">|</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code> <code class="o">==</code> <code class="s">"BB"</code> <code class="o">|</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code> <code class="o">==</code> <code class="s">"BBB"</code>
<code class="c1">## TRUE</code></pre><p>However, this is not a very efficient solution, because R has to run nine logical tests (and you have to type them). You can often replace multiple <code class="literal">|</code> operators with a single <code class="literal">%in%</code>. Also, you can check that a test is true for each element in a vector with <code class="literal">all</code>. These two changes shorten the preceding code to:</p><pre class="programlisting">all<code class="p">(</code>symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">))</code>
<code class="c1">## TRUE</code></pre><p>Let’s add this code to our script:</p><pre class="programlisting">same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
bars <code class="o">&lt;-</code> symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>

<code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="c1"># look up the prize</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>all<code class="p">(</code>bars<code class="p">))</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="c1"># assign $5</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  <code class="c1"># count cherries</code>
  prize <code class="o">&lt;-</code> <code class="c1"># calculate a prize</code>
<code class="p">}</code>

<code class="c1"># count diamonds</code>
<code class="c1"># double the prize if necessary</code></pre><p>You may have noticed that I split this test up into two steps, <code class="literal">bars</code> and <code class="literal">all(bars)</code>. That’s just a matter of personal preference. Wherever possible, I like to write my code so it can be read with function and object names conveying what they do.</p><p>You also may have noticed that our test for Case 2 will capture some symbols that should be in Case 1 because they contain three of a kind:</p><pre class="programlisting">symbols <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"B"</code><code class="p">,</code> <code class="s">"B"</code><code class="p">)</code>
all<code class="p">(</code>symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">))</code>
<code class="c1">## TRUE</code></pre><p>That won’t be a problem, however, because we’ve connected our cases with <code class="literal">else if</code> in the <code class="literal">if</code> tree.<a id="id517132" class="indexterm"/> As soon as R comes to a case that evaluates to <code class="literal">TRUE</code>, it will skip over the rest of the tree. Think of it this way: each <code class="literal">else</code> tells R to only run the code that follows it <span class="emphasis"><em>if none of the previous conditions have been met</em></span>. So when we have three of the same type of bar, R will evaluate the code for Case 1 and then skip the code for Case 2 (and Case 3).</p><p>Our next subtask is to assign a prize for <code class="literal">symbols</code>. When the <code class="literal">symbols</code> vector contains three of the same symbol, the prize will depend on which symbol there are three of. If there are three <code class="literal">DD</code>s, the prize will be $100; if there are three <code class="literal">7</code>s, the prize will be $80; and so on.</p><p>This suggests another <code class="literal">if</code> tree. You could assign a prize with some code like this:</p><pre class="programlisting"><code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
  symbol <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code>
  <code class="kr">if</code> <code class="p">(</code>symbol <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code> <code class="p">{</code>
    prize <code class="o">&lt;-</code> <code class="m">800</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>symbol <code class="o">==</code> <code class="s">"7"</code><code class="p">)</code> <code class="p">{</code>
    prize <code class="o">&lt;-</code> <code class="m">80</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>symbol <code class="o">==</code> <code class="s">"BBB"</code><code class="p">)</code> <code class="p">{</code>
    prize <code class="o">&lt;-</code> <code class="m">40</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>symbol <code class="o">==</code> <code class="s">"BB"</code><code class="p">)</code> <code class="p">{</code>
    prize <code class="o">&lt;-</code> <code class="m">5</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>symbol <code class="o">==</code> <code class="s">"B"</code><code class="p">)</code> <code class="p">{</code>
    prize <code class="o">&lt;-</code> <code class="m">10</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>symbol <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code> <code class="p">{</code>
    prize <code class="o">&lt;-</code> <code class="m">10</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>symbol <code class="o">==</code> <code class="s">"0"</code><code class="p">)</code> <code class="p">{</code>
    prize <code class="o">&lt;-</code> <code class="m">0</code>
  <code class="p">}</code>
<code class="p">}</code></pre><p>While this code will work, it is a bit long to write and read, and it may require R to perform multiple logical tests before delivering the correct prize. We can do better with a different method.<a id="id517215" class="indexterm"/><a id="id517660" class="indexterm"/></p></div><div class="sect1" title="Lookup Tables"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_lookup_tables">Lookup Tables</h2></div></div></div><p>Very often in R, the simplest way to do something will involve subsetting.<a id="ix_Plook" class="indexterm"/><a id="ix_look" class="indexterm"/> How could you use subsetting here? Since you know the exact relationship between the symbols and their prizes, you can create a vector that captures this information. This vector can store symbols as names and prize values as elements:</p><pre class="programlisting">payouts <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code> <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code>
  <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
payouts
<code class="c1">##  DD   7 BBB  BB   B   C   0</code>
<code class="c1">## 100  80  40  25  10  10   0</code></pre><p>Now you can extract the correct prize for any symbol by subsetting the vector with the symbol’s name:</p><pre class="programlisting">payouts<code class="p">[</code><code class="s">"DD"</code><code class="p">]</code>
<code class="c1">##  DD</code>
<code class="c1">## 100</code>

payouts<code class="p">[</code><code class="s">"B"</code><code class="p">]</code>
<code class="c1">##  B</code>
<code class="c1">## 10</code></pre><p>If you want to leave behind the symbol’s name when subsetting, you can run the <code class="literal">unname</code> function on the output:</p><pre class="programlisting">unname<code class="p">(</code>payouts<code class="p">[</code><code class="s">"DD"</code><code class="p">])</code> <a id="CO10-1"/><img src="callouts/1.png" alt="1"/>
<code class="c1">## 100</code></pre><div class="calloutlist"><dl><dt><a href="#CO10-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
<code class="literal">unname</code> returns a copy of an object with the names attribute removed.
</p></dd></dl></div><p><code class="literal">payouts</code> is a type of <span class="emphasis"><em>lookup table</em></span>, an R object that you can use to look up values. Subsetting <code class="literal">payouts</code> provides a simple way to find the prize for a symbol. It doesn’t take many lines of code, and it does the same amount of work whether your symbol is <code class="literal">DD</code> or <code class="literal">0</code>. You can create lookup tables in R by creating named objects that can be subsetted in clever ways.</p><p>Sadly, our method is not quite automatic; we need to tell R which symbol to look up in <code class="literal">payouts</code>. Or do we? What would happen if you subsetted <code class="literal">payouts</code> by <code class="literal">symbols[1]</code>? Give it a try:</p><pre class="programlisting">symbols <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"7"</code><code class="p">,</code> <code class="s">"7"</code><code class="p">,</code> <code class="s">"7"</code><code class="p">)</code>
symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code>
<code class="c1">## "7"</code>

payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]]</code>
<code class="c1">##  7</code>
<code class="c1">## 80</code>

symbols <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"C"</code><code class="p">,</code> <code class="s">"C"</code><code class="p">,</code> <code class="s">"C"</code><code class="p">)</code>
payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]]</code>
<code class="c1">##  C</code>
<code class="c1">## 10</code></pre><p>You don’t need to know the exact symbol to look up because you can tell R to look up whichever symbol happens to be in <code class="literal">symbols</code>. You can find this symbol with <code class="literal">symbols[1]</code>, <code class="literal">symbols[2]</code>, or <code class="literal">symbols[3]</code>, because each contains the same symbol in this case. You now have a simple automated way to calculate the prize when <code class="literal">symbols</code> contains three of a kind. Let’s add it to our code and then look at Case 2:</p><pre class="programlisting">same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
bars <code class="o">&lt;-</code> symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>

<code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
  payouts <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code> <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code>
    <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> unname<code class="p">(</code>payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]])</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>all<code class="p">(</code>bars<code class="p">))</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="c1"># assign $5</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  <code class="c1"># count cherries</code>
  prize <code class="o">&lt;-</code> <code class="c1"># calculate a prize</code>
<code class="p">}</code>

<code class="c1"># count diamonds</code>
<code class="c1"># double the prize if necessary</code></pre><p>Case 2 occurs whenever the symbols are all bars. In that case, the prize will be $5, which is easy to assign:</p><pre class="programlisting">same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
bars <code class="o">&lt;-</code> symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>

<code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
  payouts <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code> <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code>
    <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> unname<code class="p">(</code>payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]])</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>all<code class="p">(</code>bars<code class="p">))</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="m">5</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  <code class="c1"># count cherries</code>
  prize <code class="o">&lt;-</code> <code class="c1"># calculate a prize</code>
<code class="p">}</code>

<code class="c1"># count diamonds</code>
<code class="c1"># double the prize if necessary</code></pre><p>Now we can work on the last case. Here, you’ll need to know how many cherries are in <code class="literal">symbols</code> before you can calculate a prize.</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>How can you tell which elements of a vector named <code class="literal">symbols</code> are a <code class="literal">C</code>? Devise a test and try it out.</p></div><div class="sidebar"><div class="sidebar-title">Challenge</div><p>How might you count the number of <code class="literal">C</code>s in a vector named <code class="literal">symbols</code>? Remember R’s coercion rules.</p></div><p>As always, let’s work with a real example:</p><pre class="programlisting">symbols <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"C"</code><code class="p">,</code> <code class="s">"DD"</code><code class="p">,</code> <code class="s">"C"</code><code class="p">)</code></pre><p>One way to test for cherries would be to check which, if any, of the symbols are a <code class="literal">C</code>:</p><pre class="programlisting">symbols <code class="o">==</code> <code class="s">"C"</code>
<code class="c1">## TRUE FALSE  TRUE</code></pre><p>It’d be even more useful to count how many of the symbols are cherries. You can do this with <code class="literal">sum</code>, which expects numeric input, not logical. Knowing this, R will coerce the <code class="literal">TRUE</code>s and <code class="literal">FALSE</code>s to <code class="literal">1</code>s and <code class="literal">0</code>s before doing the summation. As a result, <code class="literal">sum</code> will return the number of <code class="literal">TRUE</code>s, which is also the number of cherries:</p><pre class="programlisting">sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code>
<code class="c1">## 2</code></pre><p>You can use the same method to count the number of diamonds in <code class="literal">symbols</code>:</p><pre class="programlisting">sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code>
<code class="c1">## 1</code></pre><p>Let’s add both of these subtasks to the program skeleton:</p><pre class="programlisting">same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
bars <code class="o">&lt;-</code> symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>

<code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
  payouts <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code> <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code>
    <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> unname<code class="p">(</code>payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]])</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>all<code class="p">(</code>bars<code class="p">))</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="m">5</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  cherries <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> <code class="c1"># calculate a prize</code>
<code class="p">}</code>

diamonds <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code>
<code class="c1"># double the prize if necessary</code></pre><p>Since Case 3 appears further down the <code class="literal">if</code> tree than Cases 1 and 2, the code in Case 3 will only be applied to players that do not have three of a kind or all bars. According to the slot machine’s payout scheme, these players will win $5 if they have two cherries and $2 if they have one cherry. If the player has no cherries, she gets a prize of $0. We don’t need to worry about three cherries because that outcome is already covered in Case 1.</p><p>As in Case 1, you could write an <code class="literal">if</code> tree<a id="id519988" class="indexterm"/> that handles each combination of cherries, but just like in Case 1, this would be an inefficient solution:</p><pre class="programlisting"><code class="kr">if</code> <code class="p">(</code>cherries <code class="o">==</code> <code class="m">2</code><code class="p">)</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="m">5</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>cherries <code class="o">==</code> <code class="m">1</code><code class="p">)</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="m">2</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{}</code>
  prize <code class="o">&lt;-</code> <code class="m">0</code>
<code class="p">}</code></pre><p>Again, I think the best solution will involve subsetting. If you are feeling ambitious, you can try to work this solution out on your own, but you will learn just as quickly by mentally working through the following proposed solution.</p><p>We know that our prize should be $0 if we have no cherries, $2 if we have one cherry, and $5 if we have two cherries. You can create a vector that contains this information. This will be a very simple lookup table:</p><pre class="programlisting">c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)</code></pre><p>Now, like in Case 1, you can subset the vector to retrieve the correct prize. In this case, the prize’s aren’t identified by a symbol name, but by the number of cherries present. Do we have that information? Yes, it is stored in <code class="literal">cherries</code>. We can use basic integer subsetting to get the correct prize from the prior lookup table, for example, <code class="literal">c(0, 2, 5)[1]</code>.</p><p><code class="literal">cherries</code> isn’t exactly suited for integer subsetting because it could contain a zero, but that’s easy to fix. We can subset with <code class="literal">cherries + 1</code>. Now when <code class="literal">cherries</code> equals zero, we have:</p><pre class="programlisting">cherries <code class="o">+</code> <code class="m">1</code>
<code class="c1">## 1</code>

c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)[</code>cherries <code class="o">+</code> <code class="m">1</code><code class="p">]</code>
<code class="c1">## 0</code></pre><p>When <code class="literal">cherries</code> equals one, we have:</p><pre class="programlisting">cherries <code class="o">+</code> <code class="m">1</code>
<code class="c1">## 2</code>

c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)[</code>cherries <code class="o">+</code> <code class="m">1</code><code class="p">]</code>
<code class="c1">## 2</code></pre><p>And when <code class="literal">cherries</code> equals three, we have:</p><pre class="programlisting">cherries <code class="o">+</code> <code class="m">1</code>
<code class="c1">## 3</code>

c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)[</code>cherries <code class="o">+</code> <code class="m">1</code><code class="p">]</code>
<code class="c1">## 5</code></pre><p>Examine these solutions until you are satisfied that they return the correct prize for each number of cherries. Then add the code to your script, as follows:</p><pre class="programlisting">same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
bars <code class="o">&lt;-</code> symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>

<code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
  payouts <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code> <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code>
    <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> unname<code class="p">(</code>payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]])</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>all<code class="p">(</code>bars<code class="p">))</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="m">5</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  cherries <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)[</code>cherries <code class="o">+</code> <code class="m">1</code><code class="p">]</code>
<code class="p">}</code>

diamonds <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code>
<code class="c1"># double the prize if necessary</code></pre><div class="sidebar"><div class="sidebar-title">Lookup Tables Versus if Trees</div><p>This is the second time we’ve created a lookup table to avoid writing an <code class="literal">if</code> tree. Why is this technique helpful and why does it keep appearing? Many <code class="literal">if</code> trees in R are essential. They provide a useful way to tell R to use different algorithms in different cases. However, <code class="literal">if</code> trees are not appropriate everywhere.<a id="id521103" class="indexterm"/></p><p><code class="literal">if</code> trees have a couple of drawbacks. First, they require R to run multiple tests as it works its way down the <code class="literal">if</code> tree, which can create unnecessary work. Second, as you’ll see in <a class="xref" href="ch10.html" title="Chapter 10. Speed">Chapter 10</a>, it can be difficult to use <code class="literal">if</code> trees in vectorized code, a style of code that takes advantage of R’s programming strengths to create fast programs. Lookup tables do not suffer from either of these drawbacks.</p><p>You won’t be able to replace every <code class="literal">if</code> tree with a lookup table, nor should you. However, you can usually use lookup tables to avoid assigning variables with <code class="literal">if</code> trees. As a general rule, use an <code class="literal">if</code> tree if each branch of the tree runs different <span class="emphasis"><em>code</em></span>. Use a lookup table if each branch of the tree only assigns a different <span class="emphasis"><em>value</em></span>.</p><p>To convert an <code class="literal">if</code> tree to a lookup table, identify the values to be assigned and store them in a vector. Next, identify the selection criteria used in the conditions of the <code class="literal">if</code> tree. If the conditions use character strings, give your vector names and use name-based subsetting. If the conditions use integers, use integer-based subsetting.<a id="id521152" class="indexterm"/></p></div><p>The final subtask is to double the prize once for every diamond present. This means that the final prize will be some multiple of the current prize.<a id="id521189" class="indexterm"/><a id="id521162" class="indexterm"/>  For example, if no diamonds are present, the prize will be:</p><pre class="programlisting">prize <code class="o">*</code> <code class="m">1</code>      <code class="c1"># 1 = 2 ^ 0</code></pre><p>If one diamond is present, it will be:</p><pre class="programlisting">prize <code class="o">*</code> <code class="m">2</code>      <code class="c1"># 2 = 2 ^ 1</code></pre><p>If two diamonds are present, it will be:</p><pre class="programlisting">prize <code class="o">*</code> <code class="m">4</code>      <code class="c1"># 4 = 2 ^ 2</code></pre><p>And if three diamonds are present, it will be:</p><pre class="programlisting">prize <code class="o">*</code> <code class="m">8</code>      <code class="c1"># 8 = 2 ^ 3</code></pre><p>Can you think of an easy way to handle this? How about something similar to these examples?</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Write a method for adjusting <code class="literal">prize</code> based on <code class="literal">diamonds</code>. Describe a solution in English first, and then write your code.</p></div><p>Here is a concise solution inspired by the previous pattern. The adjusted prize will equal:</p><pre class="programlisting">prize <code class="o">*</code> <code class="m">2</code> <code class="o">^</code> diamonds</pre><p>which gives us our final <code class="literal">score</code> script:</p><pre class="programlisting">same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
bars <code class="o">&lt;-</code> symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>

<code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
  payouts <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code> <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code>
    <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> unname<code class="p">(</code>payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]])</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>all<code class="p">(</code>bars<code class="p">))</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="m">5</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  cherries <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)[</code>cherries <code class="o">+</code> <code class="m">1</code><code class="p">]</code>
<code class="p">}</code>

diamonds <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code>
prize <code class="o">*</code> <code class="m">2</code> <code class="o">^</code> diamonds</pre></div><div class="sect1" title="Code Comments"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_code_comments">Code Comments</h2></div></div></div><p>You now have a working score script that you can save to a function.<a id="id521387" class="indexterm"/><a id="id521397" class="indexterm"/><a id="id521963" class="indexterm"/> Before you save your script, though, consider adding comments to your code with a <code class="literal">#</code>. Comments can make your code easier to understand by explaining <span class="emphasis"><em>why</em></span> the code does what it does. You can also use comments to break long programs into scannable chunks. For example, I would include three comments in the <code class="literal">score</code> code:</p><pre class="programlisting"><code class="c1"># identify case</code>
same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
bars <code class="o">&lt;-</code> symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>

<code class="c1"># get prize</code>
<code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
  payouts <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code> <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code>
    <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> unname<code class="p">(</code>payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]])</code>
<code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>all<code class="p">(</code>bars<code class="p">))</code> <code class="p">{</code>
  prize <code class="o">&lt;-</code> <code class="m">5</code>
<code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
  cherries <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code>
  prize <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)[</code>cherries <code class="o">+</code> <code class="m">1</code><code class="p">]</code>
<code class="p">}</code>

<code class="c1"># adjust for diamonds</code>
diamonds <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code>
prize <code class="o">*</code> <code class="m">2</code> <code class="o">^</code> diamonds</pre><p>Now that each part of your code works, you can wrap it into a function with the methods you learned in <a class="xref" href="ch01.html#WRITE-FUNCTIONS" title="Writing Your Own Functions">Writing Your Own Functions</a>. Either use RStudio’s Extract Function option in the menu bar under Code, or use the <code class="literal">function</code> function.<a id="id522025" class="indexterm"/><a id="id522034" class="indexterm"/><a id="id522613" class="indexterm"/><a id="id522621" class="indexterm"/> Ensure that the last line of the function returns a result (it does), and identify any arguments used by your function. Often the concrete examples that you used to test your code, like <code class="literal">symbols</code>, will become the arguments of your function. Run the following code to start using the <code class="literal">score</code> function:</p><pre class="programlisting">score <code class="o">&lt;-</code> <code class="kr">function</code> <code class="p">(</code>symbols<code class="p">)</code> <code class="p">{</code>
  <code class="c1"># identify case</code>
  same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
  bars <code class="o">&lt;-</code> symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>

  <code class="c1"># get prize</code>
  <code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
    payouts <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code> <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code>
      <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
    prize <code class="o">&lt;-</code> unname<code class="p">(</code>payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]])</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>all<code class="p">(</code>bars<code class="p">))</code> <code class="p">{</code>
    prize <code class="o">&lt;-</code> <code class="m">5</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
    cherries <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code>
    prize <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)[</code>cherries <code class="o">+</code> <code class="m">1</code><code class="p">]</code>
  <code class="p">}</code>

  <code class="c1"># adjust for diamonds</code>
  diamonds <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code>
  prize <code class="o">*</code> <code class="m">2</code> <code class="o">^</code> diamonds
<code class="p">}</code></pre><p>Once you have defined the <code class="literal">score</code> function, the <code class="literal">play</code> function will work as well:</p><pre class="programlisting">play <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  symbols <code class="o">&lt;-</code> get_symbols<code class="p">()</code>
  print<code class="p">(</code>symbols<code class="p">)</code>
  score<code class="p">(</code>symbols<code class="p">)</code>
<code class="p">}</code></pre><p>Now it is easy to play the slot machine:</p><pre class="programlisting">play<code class="p">()</code>
<code class="c1">## "0"  "BB" "B"</code>
<code class="c1">## 0</code>

play<code class="p">()</code>
<code class="c1">## "DD"  "0" "B"</code>
<code class="c1">## 0</code>

play<code class="p">()</code>
<code class="c1">## "BB" "BB" "B"</code>
<code class="c1">## 25</code></pre></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_summary_7">Summary</h2></div></div></div><p>An R program is a set of instructions for your computer to follow that has been organized into a sequence of steps and cases. This may make programs seem simple, but don’t be fooled: you can create complicated results with the right combination of simple steps (and cases).</p><p>As a programmer, you are more likely to be fooled in the opposite way. A program may seem impossible to write when you know that it must do something impressive. Do not panic in these situations. Divide the job before you into simple tasks, and then divide the tasks again. You can visualize the relationship between tasks with a flow chart if it helps. Then work on the subtasks one at a time. Describe solutions in English, then convert them to R code. Test each solution against concrete examples as you go. Once each of your subtasks works, combine your code into a function that you can share and reuse.<a id="id523451" class="indexterm"/><a id="id523426" class="indexterm"/><a id="id523435" class="indexterm"/></p><p>R provides tools that can help you do this. You can manage cases with <code class="literal">if</code> and <code class="literal">else</code> statements. You can create a lookup table with objects and subsetting. You can add code comments with <code class="literal">#</code>. And you can save your programs as a function with <code class="literal">function</code>.</p><p>Things often go wrong when people write programs. It will be up to you to find the source of any errors that occur and to fix them. It should be easy to find the source of your errors if you use a stepwise approach to writing functions, writing—and then testing—one bit at a time.<a id="id523480" class="indexterm"/> However, if the source of an error eludes you, or you find yourself working with large chunks of untested code, consider using R’s built in debugging tools, described in <a class="xref" href="ape.html" title="Appendix E. Debugging R Code">Appendix E</a>.</p><p>The next two chapters will teach you more tools that you can use in your programs. As you master these tools, you will find it easier to write R programs that let you do whatever you wish to your data. In <a class="xref" href="ch08.html" title="Chapter 8. S3">Chapter 8</a>, you will learn how to use R’s S3 system, an invisible hand that shapes many parts of R. You will use the system to build a custom class for your slot machine output, and you will tell R how to display objects that have your class.</p></div></section></body></html>
