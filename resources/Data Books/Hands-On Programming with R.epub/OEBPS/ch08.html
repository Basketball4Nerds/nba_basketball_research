<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 8. S3</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt03.html" title="Part III. Project 3: Slot Machine"/><link rel="prev" href="ch07.html" title="Chapter 7. Programs"/><link rel="next" href="ch09.html" title="Chapter 9. Loops"/></head><body><section class="chapter" title="Chapter 8. S3" epub:type="chapter" id="S3"><div class="titlepage"><div><div><h2 class="title">Chapter 8. S3</h2></div></div></div><p>You may have noticed that your slot machine results do not look the way I promised they would.<a id="id523517" class="indexterm"/> I suggested that the slot machine would display its results like this:</p><pre class="programlisting">play<code class="p">()</code>
<code class="c1">## 0 0 DD</code>
<code class="c1">## $0</code></pre><p>But the current machine displays its results in a less pretty format:</p><pre class="programlisting">play<code class="p">()</code>
<code class="c1">## "0"  "0" "DD"</code>
<code class="c1">## 0</code></pre><p>Moreover, the slot machine uses a hack to display symbols (we call <code class="literal">print</code> from within <code class="literal">play</code>). As a result, the symbols do not follow your prize output if you save it:</p><pre class="programlisting">one_play <code class="o">&lt;-</code> play<code class="p">()</code>
<code class="c1">## "B" "0" "B"</code>

one_play
<code class="c1">## 0</code></pre><p>You can fix both of these problems with R’s S3 system.</p><div class="sect1" title="The S3 System"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_the_s3_system">The S3 System</h2></div></div></div><p>S3 refers to a class system built into R. The system governs how R handles objects of different classes. Certain R functions will look up an object’s S3 class, and then behave differently in response.<a id="id523674" class="indexterm"/><a id="id523652" class="indexterm"/><a id="id523659" class="indexterm"/></p><p>The <code class="literal">print</code> function is like this. When you print a numeric vector, <code class="literal">print</code> will display a number:</p><pre class="programlisting">num <code class="o">&lt;-</code> <code class="m">1000000000</code>
print<code class="p">(</code>num<code class="p">)</code>
<code class="c1">## 1000000000</code></pre><p>But if you give that number the S3 class <code class="literal">POSIXct</code> followed by <code class="literal">POSIXt</code>, <code class="literal">print</code> will display a time:</p><pre class="programlisting">class<code class="p">(</code>num<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"POSIXct"</code><code class="p">,</code> <code class="s">"POSIXt"</code><code class="p">)</code>
print<code class="p">(</code>num<code class="p">)</code>
<code class="c1">## "2001-09-08 19:46:40 CST"</code></pre><p>If you use objects with classes—and you do—you will run into R’s S3 system. S3 behavior can seem odd at first, but is easy to predict once you are familiar with it.</p><p>R’s S3 system is built around three components: attributes (especially the <code class="literal">class</code> attribute), generic functions, and methods.</p></div><div class="sect1" title="Attributes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_attributes">Attributes</h2></div></div></div><p>In <a class="xref" href="ch03.html#ATTRIBUTES" title="Attributes">Attributes</a>, you learned that many R objects come with attributes, pieces of extra information that are given a name and appended to the object. Attributes do not affect the values of the object, but stick to the object as a type of metadata that R can use to handle the object. For example, a data frame stores its row and column names as attributes. Data frames also store their class, <code class="literal">"data.frame"</code>, as an attribute.<a id="ix_S3att" class="indexterm"/><a id="id523869" class="indexterm"/><a id="id523878" class="indexterm"/></p><p>You can see an object’s attributes with <code class="literal">attribute</code>.<a id="id523902" class="indexterm"/><a id="id523894" class="indexterm"/> If you run <code class="literal">attribute</code> on the <code class="literal">DECK</code> data frame that you created in <a class="xref" href="pt02.html" title="Part II. Project 2: Playing Cards">Part II</a>, you will see:</p><pre class="programlisting">attributes<code class="p">(</code>DECK<code class="p">)</code>
<code class="c1">## $names</code>
<code class="c1">## [1] "face"  "suit"  "value"</code>
<code class="c1">##</code>
<code class="c1">## $class</code>
<code class="c1">## [1] "data.frame"</code>
<code class="c1">##</code>
<code class="c1">## $row.names</code>
<code class="c1">##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19</code>
<code class="c1">## [20] 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36</code>
<code class="c1">## [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52</code></pre><p>R comes with many helper functions that let you set and access the most common attributes used in R.<a id="id523932" class="indexterm"/><a id="id524019" class="indexterm"/><a id="id524030" class="indexterm"/><a id="id524038" class="indexterm"/><a id="id524047" class="indexterm"/><a id="id524056" class="indexterm"/><a id="id524062" class="indexterm"/> You’ve already met the <code class="literal">names</code>, <code class="literal">dim</code>, and <code class="literal">class</code> functions, which each work with an eponymously named attribute. However, R also has <code class="literal">row.names</code>, <code class="literal">levels</code>, and many other attribute-based helper functions. You can use any of these functions to retrieve an attribute’s value:</p><pre class="programlisting">row.names<code class="p">(</code>DECK<code class="p">)</code>
<code class="c1">##  [1] "1"  "2"  "3"  "4"  "5"  "6"  "7"  "8"  "9"  "10" "11" "12" "13"</code>
<code class="c1">## [14] "14" "15" "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26"</code>
<code class="c1">## [27] "27" "28" "29" "30" "31" "32" "33" "34" "35" "36" "37" "38" "39"</code>
<code class="c1">## [40] "40" "41" "42" "43" "44" "45" "46" "47" "48" "49" "50" "51" "52"</code></pre><p>or to change an attribute’s value:</p><pre class="programlisting">row.names<code class="p">(</code>DECK<code class="p">)</code> <code class="o">&lt;-</code> <code class="m">101</code><code class="o">:</code><code class="m">152</code></pre><p>or to give an object a new attribute altogether:</p><pre class="programlisting">levels<code class="p">(</code>DECK<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"level 1"</code><code class="p">,</code> <code class="s">"level 2"</code><code class="p">,</code> <code class="s">"level 3"</code><code class="p">)</code>

attributes<code class="p">(</code>DECK<code class="p">)</code>
<code class="c1">## $names</code>
<code class="c1">## [1] "face"  "suit"  "value"</code>
<code class="c1">##</code>
<code class="c1">## $class</code>
<code class="c1">## [1] "data.frame"</code>
<code class="c1">##</code>
<code class="c1">## $row.names</code>
<code class="c1">##  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117</code>
<code class="c1">## [18] 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134</code>
<code class="c1">## [35] 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151</code>
<code class="c1">## [52] 152</code>
<code class="c1">##</code>
<code class="c1">## $levels</code>
<code class="c1">## [1] "level 1" "level 2" "level 3"</code></pre><p>R is very laissez faire when it comes to attributes. It will let you add any attributes that you like to an object (and then it will usually ignore them). The only time R will complain is when a function needs to find an attribute and it is not there.</p><p>You can add any general attribute to an object with <code class="literal">attr</code>; you can also use <code class="literal">attr</code> to look up the value of any attribute of an object.<a id="id524357" class="indexterm"/><a id="id524364" class="indexterm"/><a id="id524333" class="indexterm"/><a id="id524379" class="indexterm"/> Let’s see how this works with <code class="literal">one_play</code>, the result of playing our slot machine one time:</p><pre class="programlisting">one_play <code class="o">&lt;-</code> play<code class="p">()</code>
one_play
<code class="c1">## 0</code>

attributes<code class="p">(</code>one_play<code class="p">)</code>
<code class="c1">## NULL</code></pre><p><code class="literal">attr</code> takes two arguments: an R object and the name of an attribute (as a character string). To give the R object an attribute of the specified name, save a value to the output of <code class="literal">attr</code>. Let’s give <code class="literal">one_play</code> an attribute named <code class="literal">symbols</code> that contains a vector of character strings:</p><pre class="programlisting">attr<code class="p">(</code>one_play<code class="p">,</code> <code class="s">"symbols"</code><code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"0"</code><code class="p">,</code> <code class="s">"B"</code><code class="p">)</code>

attributes<code class="p">(</code>one_play<code class="p">)</code>
<code class="c1">## $symbols</code>
<code class="c1">## [1] "B" "0" "B"</code></pre><p>To look up the value of any attribute, give <code class="literal">attr</code> an R object and the name of the attribute you would like to look up:</p><pre class="programlisting">attr<code class="p">(</code>one_play<code class="p">,</code> <code class="s">"symbols"</code><code class="p">)</code>
<code class="c1">## "B" "0" "B"</code></pre><p>If you give an attribute to an atomic vector, like <code class="literal">one_play</code>, R will usually display the attribute beneath the vector’s values. However, if the attribute changes the vector’s class, R may display all of the information in the vector in a new way (as we saw with <code class="literal">POSIXct</code> objects):</p><pre class="programlisting">one_play
<code class="c1">## [1] 0</code>
<code class="c1">## attr(,"symbols")</code>
<code class="c1">## [1] "B" "0" "B"</code></pre><p>R will generally ignore an object’s attributes unless you give them a name that an R function looks for,<a id="id524622" class="indexterm"/><a id="id524634" class="indexterm"/> like <code class="literal">names</code> or <code class="literal">class</code>. For example, R will ignore the <code class="literal">symbols</code> attribute of <code class="literal">one_play</code> as you manipulate <code class="literal">one_play</code>:</p><pre class="programlisting">one_play <code class="o">+</code> <code class="m">1</code>
<code class="c1">##  1</code>
<code class="c1">## attr(,"symbols")</code>
<code class="c1">##  "B" "0" "B"</code></pre><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Modify <code class="literal">play</code> to return a prize that contains the symbols associated with it as an attribute named <code class="literal">symbols</code>. Remove the redundant call to <code class="literal">print(symbols)</code>:</p><pre class="programlisting">play <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  symbols <code class="o">&lt;-</code> get_symbols<code class="p">()</code>
  print<code class="p">(</code>symbols<code class="p">)</code>
  score<code class="p">(</code>symbols<code class="p">)</code>
<code class="p">}</code></pre></div><p>You can create a new version of <code class="literal">play</code> by capturing the output of <code class="literal">score(symbols)</code> and assigning an attribute to it. <code class="literal">play</code> can then return the enhanced version of the output:</p><pre class="programlisting">play <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  symbols <code class="o">&lt;-</code> get_symbols<code class="p">()</code>
  prize <code class="o">&lt;-</code> score<code class="p">(</code>symbols<code class="p">)</code>
  attr<code class="p">(</code>prize<code class="p">,</code> <code class="s">"symbols"</code><code class="p">)</code> <code class="o">&lt;-</code> symbols
  prize
<code class="p">}</code></pre><p>Now <code class="literal">play</code> returns both the prize and the symbols associated with the prize. The results may not look pretty, but the symbols stick with the prize when we copy it to a new object. We can work on tidying up the display in a minute:</p><pre class="programlisting">play<code class="p">()</code>
<code class="c1">## [1] 0</code>
<code class="c1">## attr(,"symbols")</code>
<code class="c1">## [1] "B"  "BB" "0"</code>

two_play <code class="o">&lt;-</code> play<code class="p">()</code>

two_play
<code class="c1">## [1] 0</code>
<code class="c1">## attr(,"symbols")</code>
<code class="c1">## [1] "0" "B" "0"</code></pre><p>You can also generate a prize and set its attributes in one step with the <code class="literal">structure</code> function. <code class="literal">structure</code> creates an object with a set of attributes. The first argument of <code class="literal">structure</code> should be an R object or set of values, and the remaining arguments should be named attributes for <code class="literal">structure</code> to add to the object. You can give these arguments any argument names you like. <code class="literal">structure</code> will add the attributes to the object under the names that you provide as argument names:</p><pre class="programlisting">play <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  symbols <code class="o">&lt;-</code> get_symbols<code class="p">()</code>
  structure<code class="p">(</code>score<code class="p">(</code>symbols<code class="p">),</code> symbols <code class="o">=</code> symbols<code class="p">)</code>
<code class="p">}</code>

three_play <code class="o">&lt;-</code> play<code class="p">()</code>
three_play
<code class="c1">##  0</code>
<code class="c1">##  attr(,"symbols")</code>
<code class="c1">##  "0"  "BB" "B"</code></pre><p>Now that your <code class="literal">play</code> output contains a <code class="literal">symbols</code> attribute, what can you do with it? You can write your own functions that lookup and use the attribute. For example, the following function will look up <code class="literal">one_play</code>’s <code class="literal">symbols</code> attribute and use it to display <code class="literal">one_play</code> in a pretty manner. We will use this function to display our slot results, so let’s take a moment to study what it does:</p><pre class="programlisting">slot_display <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>prize<code class="p">){</code>

  <code class="c1"># extract symbols</code>
  symbols <code class="o">&lt;-</code> attr<code class="p">(</code>prize<code class="p">,</code> <code class="s">"symbols"</code><code class="p">)</code>

  <code class="c1"># collapse symbols into single string</code>
  symbols <code class="o">&lt;-</code> paste<code class="p">(</code>symbols<code class="p">,</code> collapse <code class="o">=</code> <code class="s">" "</code><code class="p">)</code>

  <code class="c1"># combine symbol with prize as a regular expression</code>
  <code class="c1"># \n is regular expression for new line (i.e. return or enter)</code>
  string <code class="o">&lt;-</code> paste<code class="p">(</code>symbols<code class="p">,</code> prize<code class="p">,</code> sep <code class="o">=</code> <code class="s">"\n$"</code><code class="p">)</code>

  <code class="c1"># display regular expression in console without quotes</code>
  cat<code class="p">(</code>string<code class="p">)</code>
<code class="p">}</code>

slot_display<code class="p">(</code>one_play<code class="p">)</code>
<code class="c1">## B 0 B</code>
<code class="c1">## $0</code></pre><p>The function expects an object like <code class="literal">one_play</code> that has both a numerical value and a <code class="literal">symbols</code> attribute. The first line of the function will look up the value of the <code class="literal">symbols</code> attribute and save it as an object named <code class="literal">symbols</code>. Let’s make an example <code class="literal">symbols</code> object so we can see what the rest of the function does. We can use <code class="literal">one_play</code>’s <code class="literal">symbols</code> attribute to do the job. <code class="literal">symbols</code> will be a vector of three-character strings:</p><pre class="programlisting">symbols <code class="o">&lt;-</code> attr<code class="p">(</code>one_play<code class="p">,</code> <code class="s">"symbols"</code><code class="p">)</code>

symbols
<code class="c1">## "B" "0" "B"</code></pre><p>Next, <code class="literal">slot_display</code> uses <code class="literal">paste</code> to collapse the three strings in <code class="literal">symbols</code> into a single-character string. <code class="literal">paste</code> collapses a vector of character strings into a single string when you give it the <code class="literal">collapse</code> argument. <code class="literal">paste</code> will use the value of <code class="literal">collapse</code> to separate the formerly distinct strings. Hence, <code class="literal">symbols</code> becomes <code class="literal">B 0 B</code> the three strings separated by a space:</p><pre class="programlisting">symbols <code class="o">&lt;-</code> paste<code class="p">(</code>symbols<code class="p">,</code> collapse <code class="o">=</code> <code class="s">" "</code><code class="p">)</code>

symbols
<code class="c1">## "B 0 B"</code></pre><p>Our function then uses <code class="literal">paste</code> in a new way to combine <code class="literal">symbols</code> with the value of <code class="literal">prize</code>. <code class="literal">paste</code> combines separate objects into a character string when you give it a <code class="literal">sep</code> argument. For example, here <code class="literal">paste</code> will combine the string in <code class="literal">symbols</code>, <code class="literal">B 0 B</code>, with the number in <code class="literal">prize</code>, 0. <code class="literal">paste</code> will use the value of <code class="literal">sep</code> argument to separate the inputs in the new string. Here, that value is <code class="literal">\n$</code>, so our result will look like <code class="literal">"B 0 B\n$0"</code>:</p><pre class="programlisting">prize <code class="o">&lt;-</code> one_play
string <code class="o">&lt;-</code> paste<code class="p">(</code>symbols<code class="p">,</code> prize<code class="p">,</code> sep <code class="o">=</code> <code class="s">"\n$"</code><code class="p">)</code>

string
<code class="c1">## "B 0 B\n$0"</code></pre><p>The last line of  <code class="literal">slot_display</code> calls <code class="literal">cat</code> on the new string. <code class="literal">cat</code> is like <code class="literal">print</code>; it displays its input at the command line. However, <code class="literal">cat</code> does not surround its output with quotation marks. <code class="literal">cat</code> also replaces every <code class="literal">\n</code> with  a new line or line break. The result is what we see. Notice that it looks just how I suggested that our <code class="literal">play</code> output should look in <a class="xref" href="ch07.html" title="Chapter 7. Programs">Chapter 7</a>:</p><pre class="programlisting">cat<code class="p">(</code>string<code class="p">)</code>
<code class="c1">## B 0 B</code>
<code class="c1">## $0</code></pre><p>You can use <code class="literal">slot_display</code> to manually clean up the output of <code class="literal">play</code>:</p><pre class="programlisting">slot_display<code class="p">(</code>play<code class="p">())</code>
<code class="c1">## C B 0</code>
<code class="c1">## $2</code>

slot_display<code class="p">(</code>play<code class="p">())</code>
<code class="c1">## 7 0 BB</code>
<code class="c1">## $0</code></pre><p>This method of cleaning the output requires you to manually intervene in your R session (to call <code class="literal">slot_display</code>). There is a function that you can use to automatically clean up the output of <code class="literal">play</code> <span class="emphasis"><em>each</em></span> time it is displayed. This function is <code class="literal">print</code>, and it is a <span class="emphasis"><em>generic function</em></span>.<a id="id525744" class="indexterm"/></p></div><div class="sect1" title="Generic Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_generic_functions">Generic Functions</h2></div></div></div><p>R uses <code class="literal">print</code> more often than you may think; R calls <code class="literal">print</code> each time it displays a result in your console window. This call happens in the background, so you do not notice it; but the call explains how output makes it to the console window (recall that <code class="literal">print</code> always prints its argument in the console window).<a id="id525793" class="indexterm"/><a id="id525796" class="indexterm"/><a id="id525801" class="indexterm"/><a id="id525812" class="indexterm"/><a id="id525818" class="indexterm"/><a id="id525826" class="indexterm"/><a id="id525832" class="indexterm"/> This <code class="literal">print</code> call also explains why the output of <code class="literal">print</code> always matches what you see when you display an object at the command line:</p><pre class="programlisting">print<code class="p">(</code>pi<code class="p">)</code>
<code class="c1">## 3.141593</code>

pi
<code class="c1">## 3.141593</code>


print<code class="p">(</code>head<code class="p">(</code>deck<code class="p">))</code>
<code class="c1">##  face   suit value</code>
<code class="c1">##  king spades    13</code>
<code class="c1">## queen spades    12</code>
<code class="c1">##  jack spades    11</code>
<code class="c1">##   ten spades    10</code>
<code class="c1">##  nine spades     9</code>
<code class="c1">## eight spades     8</code>

head<code class="p">(</code>deck<code class="p">)</code>
<code class="c1">##  face   suit value</code>
<code class="c1">##  king spades    13</code>
<code class="c1">## queen spades    12</code>
<code class="c1">##  jack spades    11</code>
<code class="c1">##   ten spades    10</code>
<code class="c1">##  nine spades     9</code>
<code class="c1">## eight spades     8</code>


print<code class="p">(</code>play<code class="p">())</code>
<code class="c1">##  5</code>
<code class="c1">## attr(,"symbols")</code>
<code class="c1">##  "B"  "BB" "B"</code>

play<code class="p">()</code>
<code class="c1">##  5</code>
<code class="c1">## attr(,"symbols")</code>
<code class="c1">##  "B"  "BB" "B"</code></pre><p>You can change how R displays your slot output by rewriting <code class="literal">print</code> to look like <code class="literal">slot_display</code>. Then R would print the output in our tidy format. However, this method would have negative side effects. You do not want R to call <code class="literal">slot_display</code> when it prints a data frame, a numerical vector, or any other object.</p><p>Fortunately, <code class="literal">print</code> is not a normal function; it is a <span class="emphasis"><em>generic</em></span> function. This means that <code class="literal">print</code> is written in a way that lets it do different things in different cases. You’ve already seen this behavior in action (although you may not have realized it). <code class="literal">print</code> did one thing when we looked at the unclassed version of <code class="literal">num</code>:</p><pre class="programlisting">num <code class="o">&lt;-</code> <code class="m">1000000000</code>
print<code class="p">(</code>num<code class="p">)</code>
<code class="c1">## 1000000000</code></pre><p>and a different thing when we gave <code class="literal">num</code> a class:</p><pre class="programlisting">class<code class="p">(</code>num<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"POSIXct"</code><code class="p">,</code> <code class="s">"POSIXt"</code><code class="p">)</code>
print<code class="p">(</code>num<code class="p">)</code>
<code class="c1">## "2001-09-08 19:46:40 CST"</code></pre><p>Take a look at the code inside <code class="literal">print</code> to see how it does this. You may imagine that print looks up the class attribute of its input and then uses an <code class="literal">if</code> tree to pick which output to display. If this occurred to you, great job! <code class="literal">print</code> does something very similar, but much more simple.</p></div><div class="sect1" title="Methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_methods">Methods</h2></div></div></div><p>When you call <code class="literal">print</code>, <code class="literal">print</code> calls a special function, <code class="literal">UseMethod</code>:<a id="id526240" class="indexterm"/><a id="id526249" class="indexterm"/><a id="ix_S3meth" class="indexterm"/><a id="ix_Smeth" class="indexterm"/></p><pre class="programlisting">print
<code class="c1">## function (x, ...)</code>
<code class="c1">## UseMethod("print")</code>
<code class="c1">## &lt;bytecode: 0x7ffee4c62f80&gt;</code>
<code class="c1">## &lt;environment: namespace:base&gt;</code></pre><p><code class="literal">UseMethod</code> examines the class of the input that you provide for the first argument of <code class="literal">print</code>, and then passes all of your arguments to a new function designed to handle that class of input. For example, when you give <code class="literal">print</code> a POSIXct object, <code class="literal">UseMethod</code> will pass all of <code class="literal">print</code>’s arguments  to <code class="literal">print.POSIXct</code>. R will then run <code class="literal">print.POSIXct</code> and return the results:</p><pre class="programlisting">print.POSIXct
<code class="c1">## function (x, ...)</code>
<code class="c1">## {</code>
<code class="c1">##     max.print &lt;- getOption("max.print", 9999L)</code>
<code class="c1">##     if (max.print &lt; length(x)) {</code>
<code class="c1">##         print(format(x[seq_len(max.print)], usetz = TRUE), ...)</code>
<code class="c1">##         cat(" [ reached getOption(\"max.print\") -- omitted",</code>
<code class="c1">##             length(x) - max.print, "entries ]\n")</code>
<code class="c1">##     }</code>
<code class="c1">##     else print(format(x, usetz = TRUE), ...)</code>
<code class="c1">##     invisible(x)</code>
<code class="c1">## }</code>
<code class="c1">## &lt;bytecode: 0x7fa948f3d008&gt;</code>
<code class="c1">## &lt;environment: namespace:base&gt;</code></pre><p>If you give <code class="literal">print</code> a factor object, <code class="literal">UseMethod</code> will pass all of <code class="literal">print</code>’s arguments  to <code class="literal">print.factor</code>. R will then run <code class="literal">print.factor</code> and return the results:</p><pre class="programlisting">print.factor
<code class="c1">## function (x, quote = FALSE, max.levels = NULL, width = getOption("width"),</code>
<code class="c1">##     ...)</code>
<code class="c1">## {</code>
<code class="c1">##     ord &lt;- is.ordered(x)</code>
<code class="c1">##     if (length(x) == 0L)</code>
<code class="c1">##         cat(if (ord)</code>
<code class="c1">##             "ordered"</code>
<code class="c1">## ...</code>
<code class="c1">##         drop &lt;- n &gt; maxl</code>
<code class="c1">##         cat(if (drop)</code>
<code class="c1">##             paste(format(n), ""), T0, paste(if (drop)</code>
<code class="c1">##             c(lev[1L:max(1, maxl - 1)], "...", if (maxl &gt; 1) lev[n])</code>
<code class="c1">##         else lev, collapse = colsep), "\n", sep = "")</code>
<code class="c1">##     }</code>
<code class="c1">##     invisible(x)</code>
<code class="c1">## }</code>
<code class="c1">## &lt;bytecode: 0x7fa94a64d470&gt;</code>
<code class="c1">## &lt;environment: namespace:base&gt;</code></pre><p><code class="literal">print.POSIXct</code> and <code class="literal">print.factor</code> are called <span class="emphasis"><em>methods</em></span> of <code class="literal">print</code>. By themselves, <code class="literal">print.POSIXct</code> and <code class="literal">print.factor</code> work like regular R functions. However, each was written specifically so <code class="literal">UseMethod</code> could call it to handle a specific class of <code class="literal">print</code> input.<a id="id526583" class="indexterm"/><a id="id526599" class="indexterm"/></p><p>Notice that <code class="literal">print.POSIXct</code> and <code class="literal">print.factor</code> do two different things (also notice that I abridged the middle of <code class="literal">print.factor</code>—it is a long function). This is how <code class="literal">print</code> manages to do different things in different cases. <code class="literal">print</code> calls <code class="literal">UseMethod</code>, which calls a specialized method based on the class of <code class="literal">print</code>’s first argument.</p><p>You can see which methods exist for a generic function by calling <code class="literal">methods</code> on the function. For example, <code class="literal">print</code> has almost 200 methods (which gives you an idea of how many classes exist in R):</p><pre class="programlisting">methods<code class="p">(</code>print<code class="p">)</code>
<code class="c1">##   [1] print.acf*</code>
<code class="c1">##   [2] print.anova</code>
<code class="c1">##   [3] print.aov*</code>
<code class="c1">##  ...</code>
<code class="c1">## [176] print.xgettext*</code>
<code class="c1">## [177] print.xngettext*</code>
<code class="c1">## [178] print.xtabs*</code>
<code class="c1">##</code>
<code class="c1">##   Nonvisible functions are asterisked</code></pre><p>This system of generic functions, methods, and class-based dispatch is known as S3 because it originated in the third version of S, the programming language that would evolve into S-PLUS and R. Many common R functions are S3 generics that work with a set of class methods. For example, <code class="literal">summary</code> and <code class="literal">head</code> also call <code class="literal">UseMethod</code>. More basic functions, like <code class="literal">c</code>, <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">&lt;</code> and others also behave like generic functions, although they call <code class="literal">.primitive</code> instead of <code class="literal">UseMethod</code>.<a id="id526755" class="indexterm"/><a id="id526772" class="indexterm"/><a id="id526777" class="indexterm"/><a id="id526783" class="indexterm"/><a id="id526791" class="indexterm"/><a id="id526799" class="indexterm"/></p><p>The S3 system allows R functions to behave in different ways for different classes. You can use S3 to format your slot output. First, give your output its own class. Then write a print method for that class. To do this efficiently, you will need to know a little about how <code class="literal">UseMethod</code> selects a method function to use.</p><div class="sect2" title="Method Dispatch"><div class="titlepage"><div><div><h3 class="title" id="_method_dispatch">Method Dispatch</h3></div></div></div><p><code class="literal">UseMethod</code> uses a very simple system to match methods to functions.<a id="id526836" class="indexterm"/></p><p>Every S3 method has a two-part name. The first part of the name will refer to the function that the method works with. The second part will refer to the class. These two parts will be separated by a period. So for example, the print method that works with functions will be called <code class="literal">print.function</code>. The summary method that works with matrices will be called <code class="literal">summary.matrix</code>. And so on.<a id="id526830" class="indexterm"/><a id="id526859" class="indexterm"/><a id="id526867" class="indexterm"/></p><p>When <code class="literal">UseMethod</code> needs to call a method, it searches for an R function with the correct S3-style name. The function does not have to be special in any way; it just needs to have the correct name.</p><p>You can participate in this system by writing your own function and giving it a valid S3-style name. For example, let’s give <code class="literal">one_play</code> a class of its own. It doesn’t matter what you call the class; R will store any character string in the class attribute:</p><pre class="programlisting">class<code class="p">(</code>one_play<code class="p">)</code> <code class="o">&lt;-</code> <code class="s">"slots"</code></pre><p>Now let’s write an S3 print method for the <code class="literal">slots</code> class. The method doesn’t need to do anything special—it doesn’t even need to print <code class="literal">one_play</code>. But it <span class="emphasis"><em>does</em></span> need to be named <code class="literal">print.slots</code>; otherwise <code class="literal">UseMethod</code> will not find it. The method should also take the same arguments as <code class="literal">print</code>; otherwise, R will give an error when it tries to pass the arguments to <code class="literal">print.slots</code>:</p><pre class="programlisting">args<code class="p">(</code>print<code class="p">)</code>
<code class="c1">## function (x, ...)</code>
<code class="c1">## NULL</code>

print.slots <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>x<code class="p">,</code> <code class="kc">...</code><code class="p">)</code> <code class="p">{</code>
  cat<code class="p">(</code><code class="s">"I'm using the print.slots method"</code><code class="p">)</code>
<code class="p">}</code></pre><p>Does our method work? Yes, and not only that; R uses the print method to display the contents of <code class="literal">one_play</code>. This method isn’t very useful, so I’m going to remove it. You’ll have a chance to write a better one in a minute:</p><pre class="programlisting">print<code class="p">(</code>one_play<code class="p">)</code>
<code class="c1">## I'm using the print.slots method</code>

one_play
<code class="c1">## I'm using the print.slots method</code>

rm<code class="p">(</code>print.slots<code class="p">)</code></pre><p>Some R objects have multiple classes. For example, the output of <code class="literal">Sys.time</code> has two classes. Which class will <code class="literal">UseMethod</code> use to find a print method?</p><pre class="programlisting">now <code class="o">&lt;-</code> Sys.time<code class="p">()</code>
attributes<code class="p">(</code>now<code class="p">)</code>
<code class="c1">## $class</code>
<code class="c1">## [1] "POSIXct" "POSIXt"</code></pre><p><code class="literal">UseMethod</code> will first look for a method that matches the first class listed in the object’s class vector. If <code class="literal">UseMethod</code> cannot find one, it will then look for the method that matches the second class (and so on if there are more classes in an object’s class vector).</p><p>If you give <code class="literal">print</code> an object whose class or classes do not have a print method, <code class="literal">UseMethod</code> will call <code class="literal">print.default</code>, a special method written to handle general cases.</p><p>Let’s use this system to write a better print method for the slot machine output.</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Write a new print method for the slots class. The method should call <code class="literal">slot_display</code> to return well-formatted slot-machine output.</p><p>What name must you use for this method?</p></div><p>It is surprisingly easy to write a good <code class="literal">print.slots</code> method because we’ve already done all of the hard work when we wrote <code class="literal">slot_display</code>. For example, the following method will work. Just make sure the method is named <code class="literal">print.slots</code> so <code class="literal">UseMethod</code> can find it, and make sure that it takes the same arguments as <code class="literal">print</code> so <code class="literal">UseMethod</code> can pass those arguments to <code class="literal">print.slots</code> without any trouble:</p><pre class="programlisting">print.slots <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">(</code>x<code class="p">,</code> <code class="kc">...</code><code class="p">)</code> <code class="p">{</code>
  slot_display<code class="p">(</code>x<code class="p">)</code>
<code class="p">}</code></pre><p>Now R will automatically use <code class="literal">slot_display</code> to display objects of class <code class="literal">slots</code> (and only objects of class “slots”):</p><pre class="programlisting">one_play
<code class="c1">## B 0 B</code>
<code class="c1">## $0</code></pre><p>Let’s ensure that every piece of slot machine output has the <code class="literal">slots</code> class.<a id="id527323" class="indexterm"/><a id="id527336" class="indexterm"/></p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Modify the <code class="literal">play</code> function so it assigns <code class="literal">slots</code> to the <code class="literal">class</code> attribute of its output:</p><pre class="programlisting">play <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  symbols <code class="o">&lt;-</code> get_symbols<code class="p">()</code>
  structure<code class="p">(</code>score<code class="p">(</code>symbols<code class="p">),</code> symbols <code class="o">=</code> symbols<code class="p">)</code>
<code class="p">}</code></pre></div><p>You can set the <code class="literal">class</code> attribute of the output at the same time that you set the <code class="literal">symbols</code> attribute. Just add <code class="literal">class = "slots"</code> to the <code class="literal">structure</code> call:</p><pre class="programlisting">play <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  symbols <code class="o">&lt;-</code> get_symbols<code class="p">()</code>
  structure<code class="p">(</code>score<code class="p">(</code>symbols<code class="p">),</code> symbols <code class="o">=</code> symbols<code class="p">,</code> class <code class="o">=</code> <code class="s">"slots"</code><code class="p">)</code>
<code class="p">}</code></pre><p>Now each of our slot machine plays will have the class <code class="literal">slots</code>:</p><pre class="programlisting">class<code class="p">(</code>play<code class="p">())</code>
<code class="c1">## "slots"</code></pre><p>As a result, R will display them in the correct slot-machine format:</p><pre class="programlisting">play<code class="p">()</code>
<code class="c1">## BB BB BBB</code>
<code class="c1">## $5</code>

play<code class="p">()</code>
<code class="c1">## BB 0 0</code>
<code class="c1">## $0</code></pre></div></div><div class="sect1" title="Classes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_classes">Classes</h2></div></div></div><p>You can use the S3 system to make a robust new class of objects in R. Then R will treat objects of your class in a consistent, sensible manner.<a id="id527638" class="indexterm"/><a id="id527647" class="indexterm"/> To make a class:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Choose a name for your class.
</li><li class="listitem">
Assign each instance of your class a <code class="literal">class</code> attribute.
</li><li class="listitem">
Write class methods for any generic function likely to use objects of your class.
</li></ol></div><p>Many R packages are based on classes that have been built in a similar manner. While this work is simple, it may not be easy. For example, consider how many methods exist for predefined classes.</p><p>You can call <code class="literal">methods</code> on a class with the <code class="literal">class</code> argument, which takes a character string. <code class="literal">methods</code> will return every method written for the class. Notice that <code class="literal">methods</code> will not be able to show you methods that come in an unloaded R package:</p><pre class="programlisting">methods<code class="p">(</code>class <code class="o">=</code> <code class="s">"factor"</code><code class="p">)</code>
<code class="c1">##  [1] [.factor             [[.factor</code>
<code class="c1">##  [3] [[&lt;-.factor          [&lt;-.factor</code>
<code class="c1">##  [5] all.equal.factor     as.character.factor</code>
<code class="c1">##  [7] as.data.frame.factor as.Date.factor</code>
<code class="c1">##  [9] as.list.factor       as.logical.factor</code>
<code class="c1">## [11] as.POSIXlt.factor    as.vector.factor</code>
<code class="c1">## [13] droplevels.factor    format.factor</code>
<code class="c1">## [15] is.na&lt;-.factor       length&lt;-.factor</code>
<code class="c1">## [17] levels&lt;-.factor      Math.factor</code>
<code class="c1">## [19] Ops.factor           plot.factor*</code>
<code class="c1">## [21] print.factor         relevel.factor*</code>
<code class="c1">## [23] relist.factor*       rep.factor</code>
<code class="c1">## [25] summary.factor       Summary.factor</code>
<code class="c1">## [27] xtfrm.factor</code>
<code class="c1">##</code>
<code class="c1">##    Nonvisible functions are asterisked</code></pre><p>This output indicates how much work is required to create a robust, well-behaved class. You will usually need to write a <code class="literal">class</code> method for every basic R operation.</p><p>Consider two challenges that you will face right away. First, R drops attributes (like <code class="literal">class</code>) when it combines objects into a vector:</p><pre class="programlisting">play1 <code class="o">&lt;-</code> play<code class="p">()</code>
play1
<code class="c1">## B BBB BBB</code>
<code class="c1">## $5</code>

play2 <code class="o">&lt;-</code> play<code class="p">()</code>
play2
<code class="c1">## 0 B 0</code>
<code class="c1">## $0</code>

c<code class="p">(</code>play1<code class="p">,</code> play2<code class="p">)</code>
<code class="c1">## [1] 5 0</code></pre><p>Here, R stops using <code class="literal">print.slots</code> to display the vector because the vector <code class="literal">c(play1, play2)</code> no longer has a “slots” <code class="literal">class</code> attribute.</p><p>Next, R will drop the attributes of an object (like <code class="literal">class</code>) when you subset the object:</p><pre class="programlisting">play1<code class="p">[</code><code class="m">1</code><code class="p">]</code>
<code class="c1">## [1] 5</code></pre><p>You can avoid this behavior by writing a <code class="literal">c.slots</code> method and a <code class="literal">[.slots</code> method, but then difficulties will quickly accrue. How would you combine the <code class="literal">symbols</code> attributes of multiple plays into a vector of symbols attributes? How would you change <code class="literal">print.slots</code> to handle vectors of outputs? These challenges are open for you to explore. However, you will usually not have to attempt this type of large-scale programming as a data scientist.</p><p>In our case, it is very handy to let <code class="literal">slots</code> objects revert to single prize values when we combine groups of them together into a vector.</p></div><div class="sect1" title="S3 and Debugging"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_s3_and_debugging">S3 and Debugging</h2></div></div></div><p>S3 can be annoying if you are trying to understand R functions.<a id="id528025" class="indexterm"/><a id="id528043" class="indexterm"/> It is difficult to tell what a function does if its code body contains a call to <code class="literal">UseMethod</code>. Now that you know that <code class="literal">UseMethod</code> calls a class-specific method, you can search for and examine the method directly. It will be a function whose name follows the <code class="literal">&lt;function.class&gt;</code> syntax, or possibly <code class="literal">&lt;function.default&gt;</code>. You can also use the <code class="literal">methods</code> function to see what methods are associated with a function or a class.</p></div><div class="sect1" title="S4 and R5"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_s4_and_r5">S4 and R5</h2></div></div></div><p>R also contains two other systems that create class specific behavior. These are known as S4 and R5 (or reference classes). Each of these systems is much harder to use than S3, and perhaps as a consequence, more rare. However, they offer safeguards that S3 does not. If you’d like to learn more about these systems, including how to write and use your own generic functions, I recommend the forthcoming book <span class="emphasis"><em>Advanced R Programming</em></span> by Hadley Wickham.<a id="id528146" class="indexterm"/></p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_summary_8">Summary</h2></div></div></div><p>Values are not the only place to store information in R, and functions are not the only way to create unique behavior. You can also do both of these things with R’s S3 system. The S3 system provides a simple way to create object-specific behavior in R. In other words, it is R’s version of object-oriented programming (OOP). The system is implemented by generic functions. These functions examine the class attribute of their input and call a class-specific method to generate output. Many S3 methods will look for and use additional information that is stored in an object’s attributes. Many common R functions are S3 generics.<a id="id528140" class="indexterm"/><a id="id528114" class="indexterm"/></p><p>R’s S3 system is more helpful for the tasks of computer science than the tasks of data science, but understanding S3 can help you troubleshoot your work in R as a data scientist.</p><p>You now know quite a bit about how to write R code that performs custom tasks, but how could you repeat these tasks? As a data scientist, you will often repeat tasks, sometimes thousands or even millions of times. Why? Because repetition lets you simulate results and estimate probabilities. <a class="xref" href="ch09.html" title="Chapter 9. Loops">Chapter 9</a> will show you how to automate repetition with R’s <code class="literal">for</code> and <code class="literal">while</code> functions. You’ll use <code class="literal">for</code> to simulate various slot machine plays and to calculate the payout rate of your slot machine.</p></div></section></body></html>
