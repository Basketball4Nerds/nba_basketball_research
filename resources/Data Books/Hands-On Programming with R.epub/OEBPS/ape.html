<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Appendix E. Debugging R Code</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt03.html" title="Part III. Project 3: Slot Machine"/><link rel="prev" href="apd.html" title="Appendix D. Loading and Saving Data in R"/><link rel="next" href="ix01.html" title="Index"/></head><body><section class="appendix" title="Appendix E. Debugging R Code" epub:type="appendix" id="DEBUG"><div class="titlepage"><div><div><h2 class="title">Appendix E. Debugging R Code</h2></div></div></div><div class="note" title="Note"><h3 class="title">Note</h3><p>This appendix refers to environments, the topic of <a class="xref" href="ch06.html" title="Chapter 6. Environments">Chapter 6</a>, and uses examples from <a class="xref" href="ch07.html" title="Chapter 7. Programs">Chapter 7</a> and <a class="xref" href="ch08.html" title="Chapter 8. S3">Chapter 8</a>. You should read through these chapters first to get the most out of this appendix.</p></div><p>R comes with a simple set of debugging tools that RStudio amplifies. You can use these tools to better understand code that produces an error or returns an unexpected result. Usually this will be your own code, but you can also examine the functions in R or one of its packages.</p><p>Debugging code can take as much creativity and insight as writing code. There is no guarantee that you will find a bug or be able to fix it when you do. However, you can help yourself by using R’s debugging tools. These include the <code class="literal">traceback</code>, <code class="literal">browser</code>, <code class="literal">debug</code>, <code class="literal">debugonce</code>, <code class="literal">trace</code>, and <code class="literal">recover</code> functions.</p><p>Using these tools is usually a two-step process. First, you locate <span class="emphasis"><em>where</em></span> an error occurred. Then you try to determine <span class="emphasis"><em>why</em></span> it occurred. You can do the first step with R’s <code class="literal">traceback</code> function.</p><div class="sect1" title="traceback"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_traceback">traceback</h2></div></div></div><p>The <code class="literal">traceback</code> tool pinpoints the location of an error.<a id="id547249" class="indexterm"/><a id="id547250" class="indexterm"/> Many R functions call other R functions, which call other functions, and so on. When an error occurs, it may not be clear which of these functions went wrong. Let’s consider an example. The following functions call one another, and the last function creates an error (you’ll see why in a second):</p><pre class="programlisting">first <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> second<code class="p">()</code>
second <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> third<code class="p">()</code>
third <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> fourth<code class="p">()</code>
fourth <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> fifth<code class="p">()</code>
fifth <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> bug<code class="p">()</code></pre><p>When you run <code class="literal">first</code>, it will call <code class="literal">second</code>, which will call <code class="literal">third</code>, which will call <code class="literal">fourth</code>, which will call <code class="literal">fifth</code>, which will call <code class="literal">bug</code>, a function that does not exist. Here’s what that will look like at the command line:</p><pre class="programlisting">first<code class="p">()</code>
<code class="c1">##  Error in fifth() : could not find function "bug"</code></pre><p>The error report tells us that the error occurred when R tried to run <code class="literal">fifth</code>. It also tells us the nature of the error (there is no function called <code class="literal">bug</code>). Here, it is obvious why R calls <code class="literal">fifth</code>, but it might not be so obvious why R calls a function when an error occurs in the wild.</p><p>You can see the path of functions that R called before it hit an error by typing <span class="strong"><strong><code class="literal">traceback()</code></strong></span> at the command line. <code class="literal">traceback</code> will return a call stack, a list of the functions that R called in the order that it called them. The bottom function will be the command that you entered in the command line. The top function will be the function that caused the error:</p><pre class="programlisting">traceback<code class="p">()</code>
<code class="c1">## 5: fifth() at #1</code>
<code class="c1">## 4: fourth() at #1</code>
<code class="c1">## 3: third() at #1</code>
<code class="c1">## 2: second() at #1</code>
<code class="c1">## 1: first()</code></pre><p><code class="literal">traceback</code> will always refer to the last error you encountered. If you would like to look at a less recent error, you will need to recreate it before running <code class="literal">traceback</code>.</p><p>How can this help you? First, <code class="literal">traceback</code> returns a list of suspects. One of these functions caused the error, and each function is more suspicious than the ones below it. Chances are that our bug came from <code class="literal">fifth</code> (it did), but it is also possible that an earlier function did something odd—like call <code class="literal">fifth</code> when it shouldn’t have.</p><p>Second, <code class="literal">traceback</code> can show you if R stepped off the path that you expected it to take. If this happened, look at the last function before things went wrong.</p><p>Third, <code class="literal">traceback</code> can reveal the frightening extent of infinite recursion errors. For example, if you change <code class="literal">fifth</code> so that it calls <code class="literal">second</code>, the functions will make a loop: <code class="literal">second</code> will call <code class="literal">third</code>, which will call <code class="literal">fourth</code>, which will call <code class="literal">fifth</code>, which will call <code class="literal">second</code> and start the loop over again. It is easier to do this sort of thing in practice than you might think:</p><pre class="programlisting">fifth <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> second<code class="p">()</code></pre><p>When you call <code class="literal">first()</code>, R will start to run the functions. After awhile, it will notice that it is repeating itself and will return an error. <code class="literal">traceback</code> will show just what R was doing:</p><pre class="programlisting">first<code class="p">()</code>
<code class="c1">## Error: evaluation nested too deeply: infinite recursion/options(expressions=)?</code>

traceback<code class="p">()</code>
<code class="c1">## 5000: fourth() at #1</code>
<code class="c1">## 4999: third() at #1</code>
<code class="c1">## 4998: second() at #1</code>
<code class="c1">## 4997: fifth() at #1</code>
<code class="c1">## 4996: fourth() at #1</code>
<code class="c1">## 4995: third() at #1</code>
<code class="c1">## 4994: second() at #1</code>
<code class="c1">## 4993: fifth() at #1</code>
<code class="c1">## ...</code></pre><p>Notice that there are 5,000 lines of output in this <code class="literal">traceback</code>. If you are using RStudio, you will not get to see the traceback of an infinite recursion error (I used the Mac GUI to get this output). RStudio represses the traceback for infinite recursion errors to prevent the large call stacks from pushing your console history out of R’s memory buffer. With RStudio, you will have to recognize the infinite recursion error by its error message. However, you can still see the imposing <code class="literal">traceback</code> by running things in a UNIX shell or the Windows or Mac GUIs.<a id="id547750" class="indexterm"/><a id="id547692" class="indexterm"/><a id="id547756" class="indexterm"/></p><p>RStudio makes it very easy to use <code class="literal">traceback</code>. You do not even need to type in the function name. Whenever an error occurs, RStudio will display it in a gray box with two options. The first is Show Traceback, shown in <a class="xref" href="ape.html#FIGURE-SHOW-TRACEBACK" title="Figure E-1. RStudio’s Show Traceback option.">Figure E-1</a>.<a id="id547711" class="indexterm"/></p><div class="figure"><a id="FIGURE-SHOW-TRACEBACK"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_ae01.png" alt="Show Traceback"/></div></div><div class="figure-title">Figure E-1. RStudio’s Show Traceback option.</div></div><p>If you click Show Traceback, RStudio will expand the gray box and display the <code class="literal">traceback</code> call stack, as in <a class="xref" href="ape.html#FIGURE-HIDE-TRACEBACK" title="Figure E-2. RStudio’s Traceback display.">Figure E-2</a>. The Show Traceback option will persist beside an error message in your console, even as you write new commands. This means that you can go back and look at the call stacks for all errors—not just the most recent error.</p><p>Imagine that you’ve used <code class="literal">traceback</code> to pinpoint a function that you think might cause a bug. Now what should you do? You should try to figure out what the function did to cause an error while it ran (if it did anything). You can examine how the function runs with <code class="literal">browser</code>.</p><div class="figure"><a id="FIGURE-HIDE-TRACEBACK"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_ae02.png.jpg" alt="Traceback display"/></div></div><div class="figure-title">Figure E-2. RStudio’s Traceback display.</div></div></div><div class="sect1" title="browser"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_browser">browser</h2></div></div></div><p>You can ask R to pause in the middle of running a function and give control back to you with <code class="literal">browser</code>. This will let you enter new commands at the command line.<a id="id547853" class="indexterm"/><a id="id547848" class="indexterm"/> The active environment for these commands will not be the global environment (as usual); it will be the runtime environment of the function that you have paused. As a result, you can look at the objects that the function is using, look up their values with the same scoping rules that the function would use, and run code under the same conditions that the function would run it in. This arrangement provides the best chance for spotting the source of bugs in a function.</p><p>To use <code class="literal">browser</code>, add the call <code class="literal">browser()</code> to the body of a function and then resave the function. For example, if I wanted to pause in the middle of the <code class="literal">score</code> function from <a class="xref" href="ch07.html" title="Chapter 7. Programs">Chapter 7</a>, I could add <code class="literal">browser()</code> to the body of <code class="literal">score</code> and then rerun the following code, which defines <code class="literal">score</code>:</p><pre class="programlisting">score <code class="o">&lt;-</code> <code class="kr">function</code> <code class="p">(</code>symbols<code class="p">)</code> <code class="p">{</code>
  <code class="c1"># identify case</code>
  same <code class="o">&lt;-</code> symbols<code class="p">[</code><code class="m">1</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">&amp;&amp;</code> symbols<code class="p">[</code><code class="m">2</code><code class="p">]</code> <code class="o">==</code> symbols<code class="p">[</code><code class="m">3</code><code class="p">]</code>
  bars <code class="o">&lt;-</code> symbols <code class="o">%in%</code> c<code class="p">(</code><code class="s">"B"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">)</code>

  <code class="c1"># get prize</code>
  <code class="kr">if</code> <code class="p">(</code>same<code class="p">)</code> <code class="p">{</code>
    payouts <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code> <code class="o">=</code> <code class="m">100</code><code class="p">,</code> <code class="s">"7"</code> <code class="o">=</code> <code class="m">80</code><code class="p">,</code> <code class="s">"BBB"</code> <code class="o">=</code> <code class="m">40</code><code class="p">,</code> <code class="s">"BB"</code> <code class="o">=</code> <code class="m">25</code><code class="p">,</code>
      <code class="s">"B"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"C"</code> <code class="o">=</code> <code class="m">10</code><code class="p">,</code> <code class="s">"0"</code> <code class="o">=</code> <code class="m">0</code><code class="p">)</code>
    prize <code class="o">&lt;-</code> unname<code class="p">(</code>payouts<code class="p">[</code>symbols<code class="p">[</code><code class="m">1</code><code class="p">]])</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="kr">if</code> <code class="p">(</code>all<code class="p">(</code>bars<code class="p">))</code> <code class="p">{</code>
    prize <code class="o">&lt;-</code> <code class="m">5</code>
  <code class="p">}</code> <code class="kr">else</code> <code class="p">{</code>
    cherries <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"C"</code><code class="p">)</code>
    prize <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">5</code><code class="p">)[</code>cherries <code class="o">+</code> <code class="m">1</code><code class="p">]</code>
  <code class="p">}</code>

  browser<code class="p">()</code>

  <code class="c1"># adjust for diamonds</code>
  diamonds <code class="o">&lt;-</code> sum<code class="p">(</code>symbols <code class="o">==</code> <code class="s">"DD"</code><code class="p">)</code>
  prize <code class="o">*</code> <code class="m">2</code> <code class="o">^</code> diamonds
<code class="p">}</code></pre><p>Now whenever R runs <code class="literal">score</code>, it will come to the call <code class="literal">browser()</code>. You can see this with the <code class="literal">play</code> function from <a class="xref" href="ch07.html" title="Chapter 7. Programs">Chapter 7</a>. If you don’t have <code class="literal">play</code> handy, you can access it by running this code:</p><pre class="programlisting">get_symbols <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  wheel <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"DD"</code><code class="p">,</code> <code class="s">"7"</code><code class="p">,</code> <code class="s">"BBB"</code><code class="p">,</code> <code class="s">"BB"</code><code class="p">,</code> <code class="s">"B"</code><code class="p">,</code> <code class="s">"C"</code><code class="p">,</code> <code class="s">"0"</code><code class="p">)</code>
  sample<code class="p">(</code>wheel<code class="p">,</code> size <code class="o">=</code> <code class="m">3</code><code class="p">,</code> replace <code class="o">=</code> <code class="kc">TRUE</code><code class="p">,</code>
    prob <code class="o">=</code> c<code class="p">(</code><code class="m">0.03</code><code class="p">,</code> <code class="m">0.03</code><code class="p">,</code> <code class="m">0.06</code><code class="p">,</code> <code class="m">0.1</code><code class="p">,</code> <code class="m">0.25</code><code class="p">,</code> <code class="m">0.01</code><code class="p">,</code> <code class="m">0.52</code><code class="p">))</code>
<code class="p">}</code>

play <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> <code class="p">{</code>
  symbols <code class="o">&lt;-</code> get_symbols<code class="p">()</code>
  structure<code class="p">(</code>score<code class="p">(</code>symbols<code class="p">),</code> symbols <code class="o">=</code> symbols<code class="p">,</code> class <code class="o">=</code> <code class="s">"slots"</code><code class="p">)</code>
<code class="p">}</code></pre><p>When you run <code class="literal">play</code>, <code class="literal">play</code> will call <code class="literal">get_symbols</code> and then <code class="literal">score</code>. As R works through <code class="literal">score</code>, it will come across the call to <code class="literal">browser</code> and run it. When R runs this call, several things will happen, as in <a class="xref" href="ape.html#FIGURE-BROWSER" title="Figure E-3. RStudio updates its display whenever you enter browser mode to help you navigate the mode.">Figure E-3</a>. First, R will stop running <code class="literal">score</code>. Second, the command prompt will change to <code class="literal">browser[1]&gt;</code> and R will give me back control; I can now type new commands in at the new command prompt. Third, three buttons will appear above the console pane: Next, Continue, and Stop. Fourth, RStudio will display the source code for <code class="literal">score</code> in the scripts pane, and it will highlight the line that contains <code class="literal">browser()</code>. Fifth, the environments tab will change. Instead of revealing the objects that are saved in the global environment, it will reveal the objects that are saved in the runtime environment of <code class="literal">score</code> (see <a class="xref" href="ch06.html" title="Chapter 6. Environments">Chapter 6</a> for an explanation of R’s environment system). Sixth, RStudio will open a new Traceback pane, which shows the call stack RStudio took to get to <code class="literal">browser</code>. The most recent function, <code class="literal">score</code>, will be highlighted.<a id="id548951" class="indexterm"/></p><p>I’m now in a new R mode, called <span class="emphasis"><em>browser mode</em></span>. Browser mode is designed to help you uncover bugs, and the new display in RStudio is designed to help you navigate this mode.<a id="id549009" class="indexterm"/><a id="id548996" class="indexterm"/></p><p>Any command that you run in browser mode will be evaluated in the context of the runtime environment of the function that called <code class="literal">browser</code>. This will be the function that is highlighted in the new Traceback pane. Here, that function is <code class="literal">score</code>. So while we are in browser mode, the active environment will be <code class="literal">score</code>’s runtime environment. This lets you do two things.</p><div class="figure"><a id="FIGURE-BROWSER"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_ae03.png.jpg" alt="RStudio’s browser display"/></div></div><div class="figure-title">Figure E-3. RStudio updates its display whenever you enter browser mode to help you navigate the mode.</div></div><p>First, you can inspect the objects that <code class="literal">score</code> uses. The updated Environments pane shows you which objects <code class="literal">score</code> has saved in its local environment. You can inspect any of them by typing their name at the browser prompt. This gives you a way to see the values of runtime variables that you normally would not be able to access. If a value looks clearly wrong, you may be close to finding a bug:</p><pre class="programlisting">Browse<code class="p">[</code><code class="m">1</code><code class="p">]</code><code class="o">&gt;</code> symbols
<code class="c1">## [1] "B" "B" "0"</code>

Browse<code class="p">[</code><code class="m">1</code><code class="p">]</code><code class="o">&gt;</code> same
<code class="c1">## [1] FALSE</code></pre><p>Second, you can run code and see the same results that <code class="literal">score</code> would see. For example, you could run the remaining lines of the <code class="literal">score</code> function and see if they do anything unusual. You could run these lines by typing them into the command prompt, or you could use the three navigation buttons that now appear above the prompt, as in <a class="xref" href="ape.html#FIGURE-BROWSER-BUTTONS" title="Figure E-4. You can navigate browser mode with the three buttons at the top of the console pane.">Figure E-4</a>.</p><p>The first button, Next, will run the next line of code in <code class="literal">score</code>. The highlighted line in the scripts pane will advance by one line to show you your new location in the <code class="literal">score</code> function. If the next line begins a code chunk, like a <code class="literal">for</code> loop or an <code class="literal">if</code> tree, R will run the whole chunk and will highlight the whole chunk in the script window.</p><p>The second button, Continue, will run all of the remaining lines of <code class="literal">score</code> and then exit the browser mode.</p><p>The third button, Stop, will exit browser mode without running any more lines of <code class="literal">score</code>.</p><div class="figure"><a id="FIGURE-BROWSER-BUTTONS"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_ae04.png" alt="RStudio’s browser buttons"/></div></div><div class="figure-title">Figure E-4. You can navigate browser mode with the three buttons at the top of the console pane.</div></div><p>You can do the same things by typing the commands <code class="literal">n</code>, <code class="literal">c</code>, and <code class="literal">Q</code> into the browser prompt. This creates an annoyance: what if you want to look up an object named <code class="literal">n</code>, <code class="literal">c</code>, or <code class="literal">Q</code>? Typing in the object name will not work, R will either advance, continue, or quit the browser mode. Instead you will have to look these objects up with the commands <code class="literal">get("n")</code>, <code class="literal">get("c")</code>, and <code class="literal">get("Q")</code>. <code class="literal">cont</code> is a synonym for <code class="literal">c</code> in browser mode and <code class="literal">where</code> prints the call stack, so you’ll have to look up these objects with <code class="literal">get</code> as well.</p><p>Browser mode can help you see things from the perspective of your functions, but it cannot show you where the bug lies. However, browser mode can help you test hypotheses and investigate function behavior. This is usually all you need to spot and fix a bug. The browser mode is the basic debugging tool of R. Each of the following functions just provides an alternate way to enter the browser mode.</p><p>Once you fix the bug, you should resave your function a third time—this time without the <code class="literal">browser()</code> call. As long as the browser call is in there, R will pause each time you, or another function, calls <code class="literal">score</code>.</p></div><div class="sect1" title="Break Points"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_break_points">Break Points</h2></div></div></div><p>RStudio’s break points provide a graphical way to add a <code class="literal">browser</code> statement to a function.<a id="id549273" class="indexterm"/><a id="id549301" class="indexterm"/> To use them, open the script where you’ve defined a function. Then click to the left of the line number of the line of code in the function body where you’d like to add the browser statement. A hollow red dot will appear to show you where the break point will occur. Then run the script by clicking the Source button at the top of the Scripts pane. The hollow dot will turn into a solid red dot to show that the function has a break point (see <a class="xref" href="ape.html#FIGURE-BREAK-POINT" title="Figure E-5. Break points provide the graphical equivalent of a browser statement.">Figure E-5</a>).</p><p>R will treat the break point like a <code class="literal">browser</code> statement, going into browser mode when it encounters it. You can remove a break point by clicking on the red dot. The dot will disappear, and the break point will be removed.</p><div class="figure"><a id="FIGURE-BREAK-POINT"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_ae05.png.jpg" alt="Break points"/></div></div><div class="figure-title">Figure E-5. Break points provide the graphical equivalent of a browser statement.</div></div><p>Break points and <code class="literal">browser</code> provide a great way to debug functions that you have defined. But what if you want to debug a function that already exists in R? You can do that with the <code class="literal">debug</code> function.</p></div><div class="sect1" title="debug"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_debug">debug</h2></div></div></div><p>You can “add” a browser call to the very start of a preexisting function with <code class="literal">debug</code>.<a id="id549396" class="indexterm"/><a id="id549390" class="indexterm"/> To do this, run <code class="literal">debug</code> on the function. For example, you can run <code class="literal">debug</code> on <code class="literal">sample</code> with:</p><pre class="programlisting">debug<code class="p">(</code>sample<code class="p">)</code></pre><p>Afterward, R will act as if there is a <code class="literal">browser()</code> statement in the first line of the function. Whenever R runs the function, it will immediately enter browser mode, allowing you to step through the function one line at a time. R will continue to behave this way until you “remove” the browser statement with <code class="literal">undebug</code>:</p><pre class="programlisting">undebug<code class="p">(</code>sample<code class="p">)</code></pre><p>You can check whether a function is in “debugging” mode with <code class="literal">isdebugged</code>. This will return <code class="literal">TRUE</code> if you’ve ran <code class="literal">debug</code> on the function but have yet to run <code class="literal">undebug</code>:</p><pre class="programlisting">isdebugged<code class="p">(</code>sample<code class="p">)</code>
<code class="c1">## FALSE</code></pre><p>If this is all too much of a hassle, you can do what I do and use <code class="literal">debugonce</code> instead of <code class="literal">debug</code>. R will enter browser mode the very next time it runs the function but will automatically undebug the function afterward. If you need to browse through the function again, you can just run <code class="literal">debugonce</code> on it a second time.<a id="id549520" class="indexterm"/></p><p>You can recreate <code class="literal">debugonce</code> in RStudio whenever an error occurs. “Rerun with debug” will appear in the grey error box beneath Show Traceback (<a class="xref" href="ape.html#FIGURE-SHOW-TRACEBACK" title="Figure E-1. RStudio’s Show Traceback option.">Figure E-1</a>). If you click this option, RStudio will rerun the command as if you had first run <code class="literal">debugonce</code> on it. R will immediately go into browser mode, allowing you to step through the code. The browser behavior will only occur on this run of the code. You do not need to worry about calling <code class="literal">undebug</code> when you are done.</p></div><div class="sect1" title="trace"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_trace">trace</h2></div></div></div><p>You can add the browser statement further into the function, and not at the very start, with <code class="literal">trace</code>. <code class="literal">trace</code> takes the name of a function as a character string and then an R expression to insert into the function.<a id="id549580" class="indexterm"/><a id="id549565" class="indexterm"/> You can also provide an <code class="literal">at</code> argument that tells <code class="literal">trace</code> at which line of the function to place the expression. So to insert a browser call at the fourth line of <code class="literal">sample</code>, you would run:</p><pre class="programlisting">trace<code class="p">(</code><code class="s">"sample"</code><code class="p">,</code> browser<code class="p">,</code> at <code class="o">=</code> <code class="m">4</code><code class="p">)</code></pre><p>You can use <code class="literal">trace</code> to insert other R functions (not just <code class="literal">browser</code>) into a function, but you may need to think of a clever reason for doing so. You can also run <code class="literal">trace</code> on a function without inserting any new code. R will prints <code class="literal">trace:&lt;the function&gt;</code> at the command line every time R runs the function. This is a great way to test a claim I made in <a class="xref" href="ch08.html" title="Chapter 8. S3">Chapter 8</a>, that R calls <code class="literal">print</code> every time it displays something at the command line:</p><pre class="programlisting">trace<code class="p">(</code>print<code class="p">)</code>

first
<code class="c1">## trace: print(function () second())</code>
<code class="c1">## function() second()</code>

head<code class="p">(</code>deck<code class="p">)</code>
<code class="c1">## trace: print</code>
<code class="c1">##    face   suit value</code>
<code class="c1">## 1  king spades    13</code>
<code class="c1">## 2 queen spades    12</code>
<code class="c1">## 3  jack spades    11</code>
<code class="c1">## 4   ten spades    10</code>
<code class="c1">## 5  nine spades     9</code>
<code class="c1">## 6 eight spades     8</code></pre><p>You can revert a function to normal after calling trace on it with <code class="literal">untrace</code>:</p><pre class="programlisting">untrace<code class="p">(</code>sample<code class="p">)</code>
untrace<code class="p">(</code>print<code class="p">)</code></pre></div><div class="sect1" title="recover"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_recover">recover</h2></div></div></div><p>The <code class="literal">recover</code> function provides one final option for debugging.<a id="id549831" class="indexterm"/><a id="id549833" class="indexterm"/> It combines the call stack of <code class="literal">traceback</code> with the browser mode of <code class="literal">browser</code>. You can use <code class="literal">recover</code> just like <code class="literal">browser</code>, by inserting it directly into a function’s body. Let’s demonstrate <code class="literal">recover</code> with the <code class="literal">fifth</code> function:</p><pre class="programlisting">fifth <code class="o">&lt;-</code> <code class="kr">function</code><code class="p">()</code> recover<code class="p">()</code></pre><p>When R runs <code class="literal">recover</code>, it will pause and display the call stack, but that’s not all. R gives you the option of opening a browser mode in <span class="emphasis"><em>any</em></span> of the functions that appear in the call stack. Annoyingly, the call stack will be displayed upside down compared to <code class="literal">traceback</code>. The most recent function will be on the bottom, and the original function will be on the top:</p><pre class="programlisting">first<code class="p">()</code>
<code class="c1">##</code>
<code class="c1">## Enter a frame number, or 0 to exit</code>
<code class="c1">##</code>
<code class="c1">## 1: first()</code>
<code class="c1">## 2: #1: second()</code>
<code class="c1">## 3: #1: third()</code>
<code class="c1">## 4: #1: fourth()</code>
<code class="c1">## 5: #1: fifth()</code></pre><p>To enter a browser mode, type in the number next to the function in whose runtime environment you would like to browse. If you do not wish to browse any of the functions, type <code class="literal">0</code>:</p><pre class="programlisting"><code class="m">3</code>
<code class="c1">## Selection: 3</code>
<code class="c1">## Called from: fourth()</code>
<code class="c1">## Browse[1]&gt;</code></pre><p>You can then proceed as normal. <code class="literal">recover</code> gives you a chance to inspect variables up and down your call stack and is a powerful tool for uncovering bugs. However, adding <code class="literal">recover</code> to the body of an R function can be cumbersome. Most R users use it as a global option for handling errors.</p><p>If you run the following code, R will automatically call <code class="literal">recover()</code> whenever an error occurs:</p><pre class="programlisting">options<code class="p">(</code>error <code class="o">=</code> recover<code class="p">)</code></pre><p>This behavior will last until you close your R session, or reverse the behavior by calling:</p><pre class="programlisting">options<code class="p">(</code>error <code class="o">=</code> <code class="kc">NULL</code><code class="p">)</code></pre></div></section></body></html>
