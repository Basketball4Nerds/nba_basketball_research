<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis" xmlns:svg="http://www.w3.org/2000/svg"><head><title>Chapter 3. R Objects</title><link rel="stylesheet" type="text/css" href="core.css"/><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"/><link rel="up" href="pt02.html" title="Part II. Project 2: Playing Cards"/><link rel="prev" href="pt02.html" title="Part II. Project 2: Playing Cards"/><link rel="next" href="ch04.html" title="Chapter 4. R Notation"/></head><body><section class="chapter" title="Chapter 3. R Objects" epub:type="chapter" id="OBJECTS"><div class="titlepage"><div><div><h2 class="title">Chapter 3. R Objects</h2></div></div></div><p>In this chapter, you’ll use R to assemble a deck of 52 playing cards.</p><p>You’ll start by building simple R objects that represent playing cards and then work your way up to a full-blown table of data. In short, you’ll build the equivalent of an Excel spreadsheet from scratch.<a id="id477215" class="indexterm"/> When you are finished, your deck of cards will look something like this:</p><pre class="programlisting"> face   suit value
 king spades    <code class="m">13</code>
queen spades    <code class="m">12</code>
 jack spades    <code class="m">11</code>
  ten spades    <code class="m">10</code>
 nine spades     <code class="m">9</code>
eight spades     <code class="m">8</code>
<code class="kc">...</code></pre><p>Do you need to build a data set from scratch to use it in R? Not at all. You can load most data sets into R with one simple step, see <a class="xref" href="ch03.html#LOADING" title="Loading Data">Loading Data</a>. But this exercise will teach you how R stores data, and how you can assemble—or disassemble—your own data sets. You will also learn about the various types of objects available for you to use in R (not all R objects are the same!). Consider this exercise a rite of passage; by doing it, you will become an expert on storing data in R.</p><p>We’ll start with the very basics. The most simple type of object in R is an <span class="emphasis"><em>atomic vector</em></span>. Atomic vectors are not nuclear powered, but they are very simple and they do show up everywhere. If you look closely enough, you’ll see that most structures in R are built from atomic vectors.</p><div class="sect1" title="Atomic Vectors"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_atomic_vectors">Atomic Vectors</h2></div></div></div><p>An atomic vector is just a simple vector of data. In fact, you’ve already made an atomic vector, your <code class="literal">die</code> object from <a class="xref" href="pt01.html" title="Part I. Project 1: Weighted Dice">Part I</a>.<a id="id446891" class="indexterm"/><a id="id489716" class="indexterm"/><a id="id508011" class="indexterm"/><a id="id508017" class="indexterm"/><a id="id508023" class="indexterm"/> You can make an atomic vector by grouping some values of data together with <code class="literal">c</code>:</p><pre class="programlisting">die <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">,</code> <code class="m">4</code><code class="p">,</code> <code class="m">5</code><code class="p">,</code> <code class="m">6</code><code class="p">)</code>
die
<code class="c1">## 1 2 3 4 5 6</code>

is.vector<code class="p">(</code>die<code class="p">)</code> <a id="CO4-1"/><img src="callouts/1.png" alt="1"/>
<code class="c1">##  TRUE</code></pre><div class="calloutlist"><dl><dt><a href="#CO4-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
<code class="literal">is.vector</code> tests whether an object is an atomic vector. It returns <code class="literal">TRUE</code> if the object is an atomic vector and <code class="literal">FALSE</code> otherwise.<a id="id512081" class="indexterm"/><a id="id439470" class="indexterm"/>
</p></dd></dl></div><p>You can also make an atomic vector with just one value. R saves single values as an atomic vector of length 1:</p><pre class="programlisting">five <code class="o">&lt;-</code> <code class="m">5</code>
five
<code class="c1">## 5</code>

is.vector<code class="p">(</code>five<code class="p">)</code>
<code class="c1">##  TRUE</code>

length<code class="p">(</code>five<code class="p">)</code>
<code class="c1">## 1</code>
length<code class="p">(</code>die<code class="p">)</code>
<code class="c1">## 6</code></pre><div class="tip" title="length"><h3 class="title"><code class="literal">length</code></h3><p><code class="literal">length</code> returns the length of an atomic vector.</p></div><p>Each atomic vector stores its values as a one-dimensional vector, and each atomic vector can only store one type of data. You can save different types of data in R by using different types of atomic vectors. Altogether, R recognizes six basic types of atomic vectors: <span class="emphasis"><em>doubles</em></span>, <span class="emphasis"><em>integers</em></span>, <span class="emphasis"><em>characters</em></span>, <span class="emphasis"><em>logicals</em></span>, <span class="emphasis"><em>complex</em></span>, and <span class="emphasis"><em>raw</em></span>.<a id="id442584" class="indexterm"/><a id="id442595" class="indexterm"/><a id="id442603" class="indexterm"/><a id="id441598" class="indexterm"/><a id="id441604" class="indexterm"/><a id="id441610" class="indexterm"/><a id="id441616" class="indexterm"/><a id="id511586" class="indexterm"/><a id="id511592" class="indexterm"/></p><p>To create your card deck, you will need to use different types of atomic vectors to save different types of information (text and numbers).<a id="id433820" class="indexterm"/> You can do this by using some simple conventions when you enter your data. For example, you can create an integer vector by including a capital <code class="literal">L</code> with your input. You can create a character vector by surrounding your input in quotation marks:</p><pre class="programlisting">int <code class="o">&lt;-</code> <code class="m">1L</code>
text <code class="o">&lt;-</code> <code class="s">"ace"</code></pre><p>Each type of atomic vector has its own convention (described below). R will recognize the convention and use it to create an atomic vector of the appropriate type. If you’d like to make atomic vectors that have more than one element in them, you can combine an element with the <code class="literal">c</code> function from <a class="xref" href="ch02.html" title="Chapter 2. Packages and Help Pages">Chapter 2</a>. Use the same convention with each element:</p><pre class="programlisting">int <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">1L</code><code class="p">,</code> <code class="m">5L</code><code class="p">)</code>
text <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"ace"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">)</code></pre><p>You may wonder why R uses multiple types of vectors. Vector types help R behave as you would expect. For example, R will do math with atomic vectors that contain numbers, but not with atomic vectors that contain character strings:</p><pre class="programlisting">sum<code class="p">(</code>num<code class="p">)</code>
<code class="c1">## 6</code>

sum<code class="p">(</code>text<code class="p">)</code>
<code class="c1">## Error in sum(text) : invalid 'type' (character) of argument</code></pre><p>But we’re getting ahead of ourselves! Get ready to say hello to the six types of atomic vectors in R.</p><div class="sect2" title="Doubles"><div class="titlepage"><div><div><h3 class="title" id="_doubles">Doubles</h3></div></div></div><p>A double vector stores regular numbers.<a id="id430614" class="indexterm"/><a id="id430591" class="indexterm"/><a id="id445362" class="indexterm"/><a id="id445371" class="indexterm"/> The numbers can be positive or negative, large or small, and have digits to the right of the decimal place or not. In general, R will save any number that you type in R as a double. So, for example, the die you made in <a class="xref" href="pt01.html" title="Part I. Project 1: Weighted Dice">Part I</a> was a double object:</p><pre class="programlisting">die <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">,</code> <code class="m">4</code><code class="p">,</code> <code class="m">5</code><code class="p">,</code> <code class="m">6</code><code class="p">)</code>
die
<code class="c1">## 1 2 3 4 5 6</code></pre><p>You’ll usually know what type of object you are working with in R (it will be obvious), but you can also ask R what type of object an object is with <code class="literal">typeof</code>.<a id="id445385" class="indexterm"/><a id="id509541" class="indexterm"/><a id="id509547" class="indexterm"/> For example:</p><pre class="programlisting">typeof<code class="p">(</code>die<code class="p">)</code>
<code class="c1">##  "double"</code></pre><p>Some R functions refer to doubles as “numerics,” and I will often do the same. Double is a computer science term. It refers to the specific number of bytes your computer uses to store a number, but I find “numeric” to be much more intuitive when doing data science.<a id="id461274" class="indexterm"/></p></div><div class="sect2" title="Integers"><div class="titlepage"><div><div><h3 class="title" id="_integers">Integers</h3></div></div></div><p>Integer vectors store integers, numbers that can be written without a decimal component. As a data scientist, you won’t use the integer type very often because you can save integers as a double object.<a id="id461292" class="indexterm"/><a id="id457240" class="indexterm"/><a id="id457224" class="indexterm"/><a id="id457230" class="indexterm"/><a id="id483785" class="indexterm"/></p><p>You can specifically create an integer in R by typing a number followed by an uppercase  <code class="literal">L</code>. For example:</p><pre class="programlisting">int <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">-1L</code><code class="p">,</code> <code class="m">2L</code><code class="p">,</code> <code class="m">4L</code><code class="p">)</code>
int
<code class="c1">## -1  2  4</code>

typeof<code class="p">(</code>int<code class="p">)</code>
<code class="c1">## "integer"</code></pre><p>Note that R won’t save a number as an integer unless you include the <code class="literal">L</code>. Integer numbers without the <code class="literal">L</code> will be saved as doubles. The only difference between <code class="literal">4</code> and <code class="literal">4L</code> is how R saves the number in your computer’s memory. Integers are defined more precisely in your computer’s memory than doubles (unless the integer is <span class="emphasis"><em>very</em></span> large or small).</p><p>Why would you save your data as an integer instead of a double? Sometimes a difference in precision can have surprising effects. Your computer allocates 64 bits of memory to store each double in an R program. This allows a lot of precision, but some numbers cannot be expressed exactly in 64 bits, the equivalent of a sequence of 64 ones and zeroes. For example, the number <span class="inlinemediaobject"><img src="inleq_0301.png" alt=""/></span> contains an endless sequences of digits to the right of the decimal place. Your computer must round <span class="inlinemediaobject"><img src="inleq_0302.png" alt=""/></span> to something close to, but not exactly equal to <span class="inlinemediaobject"><img src="inleq_0303.png" alt=""/></span> to store <span class="inlinemediaobject"><img src="inleq_0304.png" alt=""/></span> in its memory. Many decimal numbers share a similar fate.</p><p>As a result, each double is accurate to about 16 significant digits. This introduces a little bit of error. In most cases, this rounding error will go unnoticed. However, in some situations, the rounding error can cause surprising results. For example, you may expect the result of the expression below to be zero, but it is not:</p><pre class="programlisting">sqrt<code class="p">(</code><code class="m">2</code><code class="p">)</code><code class="o">^</code><code class="m">2</code> <code class="o">-</code> <code class="m">2</code>
<code class="c1">## 4.440892e-16</code></pre><p>The square root of two cannot be expressed exactly in 16 significant digits. As a result, R has to round the quantity, and the expression resolves to something very close to—but not quite—zero.</p><p>These errors are known as <span class="emphasis"><em>floating-point</em></span> errors, and doing arithmetic in these conditions is known as <span class="emphasis"><em>floating-point arithmetic</em></span>. Floating-point arithmetic is not a feature of R; it is a feature of computer programming. Usually floating-point errors won’t be enough to ruin your day. Just keep in mind that they may be the cause of surprising results.<a id="id441114" class="indexterm"/><a id="id441110" class="indexterm"/><a id="id441125" class="indexterm"/></p><p>You can avoid floating-point errors by avoiding decimals and only using integers. However, this is not an option in most data-science situations. You cannot do much math with integers before you need a noninteger to express the result. Luckily, the errors caused by floating-point arithmetic are usually insignificant (and when they are not, they are easy to spot). As a result, you’ll generally use doubles instead of integers as a data scientist.</p></div><div class="sect2" title="Characters"><div class="titlepage"><div><div><h3 class="title" id="_characters">Characters</h3></div></div></div><p>A character vector stores small pieces of text.<a id="id468183" class="indexterm"/><a id="id468192" class="indexterm"/><a id="id475939" class="indexterm"/><a id="id475944" class="indexterm"/><a id="id475950" class="indexterm"/><a id="id475956" class="indexterm"/> You can create a character vector in R by typing a character or string of characters surrounded by quotes:</p><pre class="programlisting">text <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"Hello"</code><code class="p">,</code>  <code class="s">"World"</code><code class="p">)</code>
text
<code class="c1">##  "Hello"  "World"</code>

typeof<code class="p">(</code>text<code class="p">)</code>
<code class="c1">## "character"</code>

typeof<code class="p">(</code><code class="s">"Hello"</code><code class="p">)</code>
<code class="c1">## "character"</code></pre><p>The individual elements of a character vector are known as <span class="emphasis"><em>strings</em></span>. Note that a string can contain more than just letters. You can assemble a character string from numbers or symbols as well.<a id="id440265" class="indexterm"/><a id="id440244" class="indexterm"/></p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Can you spot the difference between a character string and a number? Here’s a test: Which of these are character strings and which are numbers? <code class="literal">1</code>, <code class="literal">"1"</code>, <code class="literal">"one"</code>.</p></div><p><code class="literal">"1"</code> and <code class="literal">"one"</code> are both character strings. Character strings can contain number characters, but that doesn’t make them numeric. They’re just strings that happen to have numbers in them. You can tell strings from real numbers because strings come surrounded by quotes. In fact, anything surrounded by quotes in R will be treated as a character string—no matter what appears between the quotes.<a id="id369201" class="indexterm"/><a id="id499248" class="indexterm"/></p><p>It is easy to confuse R objects with character strings. Why? Because both appear as pieces of text in R code. For example, <code class="literal">x</code> is the name of an R object named “x,” <code class="literal">"x"</code> is a character string that contains the character “x.” One is an object that contains raw data, the other is a piece of raw data itself.<a id="id457722" class="indexterm"/><a id="id457710" class="indexterm"/><a id="id499236" class="indexterm"/></p><p>Expect an error whenever you forget your quotation marks; R will start looking for an object that probably does not exist.<a id="id445488" class="indexterm"/></p></div><div class="sect2" title="Logicals"><div class="titlepage"><div><div><h3 class="title" id="_logicals">Logicals</h3></div></div></div><p>Logical vectors store <code class="literal">TRUE</code>s and <code class="literal">FALSE</code>s, R’s form of Boolean data.<a id="id453568" class="indexterm"/><a id="id453579" class="indexterm"/><a id="id453585" class="indexterm"/><a id="id453594" class="indexterm"/><a id="id373745" class="indexterm"/><a id="id373754" class="indexterm"/><a id="id373762" class="indexterm"/> Logicals are very helpful for doing things like comparisons:</p><pre class="programlisting"><code class="m">3</code> <code class="o">&gt;</code> <code class="m">4</code>
<code class="c1">## FALSE</code></pre><p>Any time you type <code class="literal">TRUE</code> or <code class="literal">FALSE</code> in capital letters (without quotation marks), R will treat your input as logical data.<a id="id448803" class="indexterm"/><a id="id448810" class="indexterm"/><a id="id448816" class="indexterm"/><a id="id448822" class="indexterm"/> R also assumes that <code class="literal">T</code> and <code class="literal">F</code> are shorthand for <code class="literal">TRUE</code> and <code class="literal">FALSE</code>:</p><pre class="programlisting">logic <code class="o">&lt;-</code> c<code class="p">(</code><code class="kc">TRUE</code><code class="p">,</code> <code class="kc">FALSE</code><code class="p">,</code> <code class="kc">TRUE</code><code class="p">)</code>
logic
<code class="c1">##   TRUE FALSE  TRUE</code>

typeof<code class="p">(</code>logic<code class="p">)</code>
<code class="c1">## "logical"</code>

typeof<code class="p">(</code><code class="k-Variable">F</code><code class="p">)</code>
<code class="c1">## "logical"</code></pre></div><div class="sect2" title="Complex and Raw"><div class="titlepage"><div><div><h3 class="title" id="_complex_and_raw">Complex and Raw</h3></div></div></div><p>Doubles, integers, characters, and logicals are the most common types of atomic vectors in R, but R also recognizes two more types: complex and raw. It is doubtful that you will ever use these to analyze data, but here they are for the sake of thoroughness.<a id="id475252" class="indexterm"/><a id="id475249" class="indexterm"/><a id="id475268" class="indexterm"/><a id="id454634" class="indexterm"/><a id="id454645" class="indexterm"/><a id="id454651" class="indexterm"/><a id="id454658" class="indexterm"/><a id="id460771" class="indexterm"/></p><p>Complex vectors store complex numbers. To create a complex vector, add an imaginary term to a number with <code class="literal">i</code>:</p><pre class="programlisting">comp <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">1</code> <code class="o">+</code> <code class="m">1i</code><code class="p">,</code> <code class="m">1</code> <code class="o">+</code> <code class="m">2i</code><code class="p">,</code> <code class="m">1</code> <code class="o">+</code> <code class="m">3i</code><code class="p">)</code>
comp
<code class="c1">## 1+1i 1+2i 1+3i</code>

typeof<code class="p">(</code>comp<code class="p">)</code>
<code class="c1">## "complex"</code></pre><p>Raw vectors store raw bytes of data.<a id="id460785" class="indexterm"/><a id="id448610" class="indexterm"/> Making raw vectors gets complicated, but you can make an empty raw vector of length <span class="emphasis"><em>n</em></span> with <code class="literal">raw(n)</code>. See the help page of <code class="literal">raw</code> for more options when working with this type of data:</p><pre class="programlisting">raw<code class="p">(</code><code class="m">3</code><code class="p">)</code>
<code class="c1">## 00 00 00</code>

typeof<code class="p">(</code>raw<code class="p">(</code><code class="m">3</code><code class="p">))</code>
<code class="c1">## "raw"</code></pre><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Create an atomic vector that stores just the face names of the cards in a royal flush, for example, the ace of spades, king of spades, queen of spades, jack of spades, and ten of spades. The face name of the ace of spades would be “ace,” and “spades” is the suit.</p><p>Which type of vector will you use to save the names?</p></div><p>A character vector is the most appropriate type of atomic vector in which to save card names.<a id="id449532" class="indexterm"/> You can create one with the <code class="literal">c</code> function if you surround each name with quotation marks:</p><pre class="programlisting">hand <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"ace"</code><code class="p">,</code> <code class="s">"king"</code><code class="p">,</code> <code class="s">"queen"</code><code class="p">,</code> <code class="s">"jack"</code><code class="p">,</code> <code class="s">"ten"</code><code class="p">)</code>
hand
<code class="c1">## "ace"   "king"  "queen" "jack"  "ten"</code>

typeof<code class="p">(</code>hand<code class="p">)</code>
<code class="c1">## "character"</code></pre><p>This creates a one-dimensional group of card names—great job! Now let’s make a more sophisticated data structure, a two-dimensional table of card names and suits. You can build a more sophisticated object from an atomic vector by giving it some attributes and assigning it a class.</p></div></div><div class="sect1" title="Attributes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ATTRIBUTES">Attributes</h2></div></div></div><p>An attribute is a piece of information that you can attach to an atomic vector (or any R object). The attribute won’t affect any of the values in the object, and it will not appear when you display your object. You can think of an attribute as “metadata”; it is just a convenient place to put information associated with an object. R will normally ignore this metadata, but some R functions will check for specific attributes. These functions may use the attributes to do special things with the data.<a id="id480612" class="indexterm"/><a id="id383942" class="indexterm"/><a id="id383951" class="indexterm"/></p><p>You can see which attributes an object has with <code class="literal">attributes</code>. <code class="literal">attributes</code> will return <code class="literal">NULL</code> if an object has no attributes.<a id="id476420" class="indexterm"/><a id="id476431" class="indexterm"/> An atomic vector, like <code class="literal">die</code>, won’t have any attributes unless you give it some:</p><pre class="programlisting">attributes<code class="p">(</code>die<code class="p">)</code>
<code class="c1">## NULL</code></pre><div class="tip" title="NULL"><h3 class="title">NULL</h3><p>R uses <code class="literal">NULL</code> to represent the null set, an empty object. <code class="literal">NULL</code> is often returned by functions whose values are undefined. You can create a <code class="literal">NULL</code> object by typing <code class="literal">NULL</code> in capital letters.<a id="id365473" class="indexterm"/><a id="id365479" class="indexterm"/></p></div><div class="sect2" title="Names"><div class="titlepage"><div><div><h3 class="title" id="NAMES">Names</h3></div></div></div><p>The most common attributes to give an atomic vector are names, dimensions (dim), and classes.<a id="id379189" class="indexterm"/><a id="id379196" class="indexterm"/><a id="id443515" class="indexterm"/><a id="id443524" class="indexterm"/><a id="id443532" class="indexterm"/> Each of these attributes has its own helper function that you can use to give attributes to an object. You can also use the helper functions to look up the value of these attributes for objects that already have them. For example, you can look up the value of the names attribute of <code class="literal">die</code> with <code class="literal">names</code>:</p><pre class="programlisting">names<code class="p">(</code>die<code class="p">)</code>
<code class="c1">## NULL</code></pre><p><code class="literal">NULL</code> means that <code class="literal">die</code> does not have a names attribute. You can give one to <code class="literal">die</code> by assigning a character vector to the output of <code class="literal">names</code>. The vector should include one name for each element in <code class="literal">die</code>:</p><pre class="programlisting">names<code class="p">(</code>die<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"one"</code><code class="p">,</code> <code class="s">"two"</code><code class="p">,</code> <code class="s">"three"</code><code class="p">,</code> <code class="s">"four"</code><code class="p">,</code> <code class="s">"five"</code><code class="p">,</code> <code class="s">"six"</code><code class="p">)</code></pre><p>Now <code class="literal">die</code> has a names attribute:</p><pre class="programlisting">names<code class="p">(</code>die<code class="p">)</code>
<code class="c1">## "one"   "two"   "three" "four"  "five"  "six"</code>

attributes<code class="p">(</code>die<code class="p">)</code>
<code class="c1">## $names</code>
<code class="c1">## [1] "one"   "two"   "three" "four"  "five"  "six"</code></pre><p>R will display the names above the elements of <code class="literal">die</code> whenever you look at the vector:</p><pre class="programlisting">die
<code class="c1">##  one   two three  four  five   six</code>
<code class="c1">##    1     2     3     4     5     6</code></pre><p>However, the names won’t affect the actual values of the vector, nor will the names be affected when you manipulate the values of the vector:</p><pre class="programlisting">die <code class="o">+</code> <code class="m">1</code>
<code class="c1">##  one   two three  four  five   six</code>
<code class="c1">##    2     3     4     5     6     7</code></pre><p>You can also use <code class="literal">names</code> to change the names attribute or remove it all together. To change the names, assign a new set of labels to <code class="literal">names</code>:</p><pre class="programlisting">names<code class="p">(</code>die<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"uno"</code><code class="p">,</code> <code class="s">"dos"</code><code class="p">,</code> <code class="s">"tres"</code><code class="p">,</code> <code class="s">"quatro"</code><code class="p">,</code> <code class="s">"cinco"</code><code class="p">,</code> <code class="s">"seis"</code><code class="p">)</code>
die
<code class="c1">##   uno    dos   tres quatro  cinco   seis</code>
<code class="c1">##     1      2      3      4      5      6</code></pre><p>To remove the names attribute, set it to <code class="literal">NULL</code>:</p><pre class="programlisting">names<code class="p">(</code>die<code class="p">)</code> <code class="o">&lt;-</code> <code class="kc">NULL</code>
die
<code class="c1">##  1 2 3 4 5 6</code></pre></div><div class="sect2" title="Dim"><div class="titlepage"><div><div><h3 class="title" id="_dim">Dim</h3></div></div></div><p>You can transform an atomic vector into an <span class="emphasis"><em>n</em></span>-dimensional array by giving it a dimensions attribute with <code class="literal">dim</code>.<a id="id434649" class="indexterm"/><a id="id434660" class="indexterm"/><a id="id434669" class="indexterm"/> To do this, set the <code class="literal">dim</code> attribute to a numeric vector of length <span class="emphasis"><em>n</em></span>. R will reorganize the elements of the vector into <span class="emphasis"><em>n</em></span> dimensions. Each dimension will have as many rows (or columns, etc.) as the <span class="emphasis"><em>nth</em></span> value of the <code class="literal">dim</code> vector. For example, you can reorganize <code class="literal">die</code> into a 2 × 3 matrix (which has 2 rows and 3 columns):</p><pre class="programlisting">dim<code class="p">(</code>die<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">)</code>
die
<code class="c1">##      [,1] [,2] [,3]</code>
<code class="c1">## [1,]    1    3    5</code>
<code class="c1">## [2,]    2    4    6</code></pre><p>or a 3 × 2 matrix (which has 3 rows and 2 columns):</p><pre class="programlisting">dim<code class="p">(</code>die<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">3</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code>
die
<code class="c1">##      [,1] [,2]</code>
<code class="c1">## [1,]    1    4</code>
<code class="c1">## [2,]    2    5</code>
<code class="c1">## [3,]    3    6</code></pre><p>or a 1 × 2 × 3 hypercube (which has 1 row, 2 columns, and 3 “slices”). This is a three-dimensional structure, but R will need to show it slice by slice by slice on your two-dimensional computer screen:</p><pre class="programlisting">dim<code class="p">(</code>die<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">)</code>
die
<code class="c1">## , , 1</code>
<code class="c1">##</code>
<code class="c1">##      [,1] [,2]</code>
<code class="c1">## [1,]    1    2</code>
<code class="c1">##</code>
<code class="c1">## , , 2</code>
<code class="c1">##</code>
<code class="c1">##      [,1] [,2]</code>
<code class="c1">## [1,]    3    4</code>
<code class="c1">##</code>
<code class="c1">## , , 3</code>
<code class="c1">##</code>
<code class="c1">##      [,1] [,2]</code>
<code class="c1">## [1,]    5    6</code></pre><p>R will always use the first value in <code class="literal">dim</code> for the number of rows and the second value for the number of columns. In general, rows always come first in R operations that deal with both rows and columns.</p><p>You may notice that you don’t have much control over how R reorganizes the values into rows and columns. For example, R always fills up each matrix by columns, instead of by rows. If you’d like more control over this process, you can use one of R’s helper functions, <code class="literal">matrix</code> or <code class="literal">array</code>. They do the same thing as changing the <code class="literal">dim</code> attribute, but they provide extra arguments to customize the process.</p></div></div><div class="sect1" title="Matrices"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_matrices">Matrices</h2></div></div></div><p>Matrices store values in a two-dimensional array, just like a matrix from linear algebra.<a id="id488556" class="indexterm"/><a id="id488562" class="indexterm"/><a id="id440967" class="indexterm"/><a id="id440975" class="indexterm"/><a id="id440983" class="indexterm"/> To create one, first give <code class="literal">matrix</code> an atomic vector to reorganize into a matrix. Then, define how many rows should be in the matrix by setting the <code class="literal">nrow</code> argument to a number. <code class="literal">matrix</code> will organize your vector of values into a matrix with the specified number of rows. Alternatively, you can set the <code class="literal">ncol</code> argument, which tells R how many columns to include in the matrix:</p><pre class="programlisting">m <code class="o">&lt;-</code> matrix<code class="p">(</code>die<code class="p">,</code> nrow <code class="o">=</code> <code class="m">2</code><code class="p">)</code>
m
<code class="c1">##      [,1] [,2] [,3]</code>
<code class="c1">## [1,]    1    3    5</code>
<code class="c1">## [2,]    2    4    6</code></pre><p><code class="literal">matrix</code> will fill up the matrix column by column by default, but you can fill the matrix row by row if you include the argument <code class="literal">byrow = TRUE</code>:</p><pre class="programlisting">m <code class="o">&lt;-</code> matrix<code class="p">(</code>die<code class="p">,</code> nrow <code class="o">=</code> <code class="m">2</code><code class="p">,</code> byrow <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
m
<code class="c1">##      [,1] [,2] [,3]</code>
<code class="c1">## [1,]    1    2    3</code>
<code class="c1">## [2,]    4    5    6</code></pre><p><code class="literal">matrix</code> also has other default arguments that you can use to customize your matrix. You can read about them at <code class="literal">matrix</code>’s help page (accessible by <code class="literal">?matrix</code>).</p></div><div class="sect1" title="Arrays"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_arrays">Arrays</h2></div></div></div><p>The <code class="literal">array</code> function creates an n-dimensional array.<a id="id457332" class="indexterm"/><a id="id457341" class="indexterm"/><a id="id457347" class="indexterm"/><a id="id457356" class="indexterm"/><a id="id371460" class="indexterm"/> For example, you could use <code class="literal">array</code> to sort values into a cube of three dimensions or a hypercube in 4, 5, or <span class="emphasis"><em>n</em></span> dimensions. <code class="literal">array</code> is not as customizeable as <code class="literal">matrix</code> and basically does the same thing as setting the <code class="literal">dim</code> attribute. To use <code class="literal">array</code>, provide an atomic vector as the first argument, and a vector of dimensions as the second argument, now called <code class="literal">dim</code>:</p><pre class="programlisting">ar <code class="o">&lt;-</code> array<code class="p">(</code>c<code class="p">(</code><code class="m">11</code><code class="o">:</code><code class="m">14</code><code class="p">,</code> <code class="m">21</code><code class="o">:</code><code class="m">24</code><code class="p">,</code> <code class="m">31</code><code class="o">:</code><code class="m">34</code><code class="p">),</code> dim <code class="o">=</code> c<code class="p">(</code><code class="m">2</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">))</code>
ar
<code class="c1">## , , 1</code>
<code class="c1">##</code>
<code class="c1">##      [,1] [,2]</code>
<code class="c1">## [1,]   11   13</code>
<code class="c1">## [2,]   12   14</code>
<code class="c1">##</code>
<code class="c1">## , , 2</code>
<code class="c1">##</code>
<code class="c1">##      [,1] [,2]</code>
<code class="c1">## [1,]   21   23</code>
<code class="c1">## [2,]   22   24</code>
<code class="c1">##</code>
<code class="c1">## , , 3</code>
<code class="c1">##</code>
<code class="c1">##      [,1] [,2]</code>
<code class="c1">## [1,]   31   33</code>
<code class="c1">## [2,]   32   34</code></pre><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Create the following matrix, which stores the name and suit of every card in a royal flush.</p><pre class="programlisting"><code class="c1">##      [,1]    [,2]</code>
<code class="c1">## [1,] "ace"   "spades"</code>
<code class="c1">## [2,] "king"  "spades"</code>
<code class="c1">## [3,] "queen" "spades"</code>
<code class="c1">## [4,] "jack"  "spades"</code>
<code class="c1">## [5,] "ten"   "spades"</code></pre></div><p>There is more than one way to build this matrix, but in every case, you will need to start by making a character vector with 10 values. If you start with the following character vector, you can turn it into a matrix with any of the following three commands:</p><pre class="programlisting">hand1 <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"ace"</code><code class="p">,</code> <code class="s">"king"</code><code class="p">,</code> <code class="s">"queen"</code><code class="p">,</code> <code class="s">"jack"</code><code class="p">,</code> <code class="s">"ten"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code>
  <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">)</code>

matrix<code class="p">(</code>hand1<code class="p">,</code> nrow <code class="o">=</code> <code class="m">5</code><code class="p">)</code>
matrix<code class="p">(</code>hand1<code class="p">,</code> ncol <code class="o">=</code> <code class="m">2</code><code class="p">)</code>
dim<code class="p">(</code>hand1<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">5</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code></pre><p>You can also start with a character vector that lists the cards in a slightly different order. In this case, you will need to ask R to fill the matrix row by row instead of column by column:</p><pre class="programlisting">hand2 <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"ace"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"king"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"queen"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"jack"</code><code class="p">,</code>
  <code class="s">"spades"</code><code class="p">,</code> <code class="s">"ten"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">)</code>

matrix<code class="p">(</code>hand2<code class="p">,</code> nrow <code class="o">=</code> <code class="m">5</code><code class="p">,</code> byrow <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code>
matrix<code class="p">(</code>hand2<code class="p">,</code> ncol <code class="o">=</code> <code class="m">2</code><code class="p">,</code> byrow <code class="o">=</code> <code class="kc">TRUE</code><code class="p">)</code></pre></div><div class="sect1" title="Class"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_class">Class</h2></div></div></div><p>Notice that changing the dimensions of your object will not change the type of the object, but it <span class="emphasis"><em>will</em></span> change the object’s <code class="literal">class</code><a id="id511446" class="indexterm"/><a id="id511454" class="indexterm"/><a id="id511464" class="indexterm"/><a id="id511472" class="indexterm"/> attribute:</p><pre class="programlisting">dim<code class="p">(</code>die<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">)</code>
typeof<code class="p">(</code>die<code class="p">)</code>
<code class="c1">##  "double"</code>

class<code class="p">(</code>die<code class="p">)</code>
<code class="c1">##  "matrix"</code></pre><p>A class is a special case of an atomic vector. For example, the <code class="literal">die</code> matrix is a special case of a double vector. Every element in the matrix is still a double, but the elements have been arranged into a new structure. R added a <code class="literal">class</code> attribute to <code class="literal">die</code> when you changed its dimensions. This class describes <code class="literal">die</code>’s new format. Many R functions will specifically look for an object’s <code class="literal">class</code> attribute, and then handle the object in a predetermined way based on the attribute.</p><p>Note that an object’s <code class="literal">class</code> attribute will not always appear when you run <code class="literal">attributes</code>; you may need to specifically search for it with <code class="literal">class</code>:</p><pre class="programlisting">attributes<code class="p">(</code>die<code class="p">)</code>
<code class="c1">## $dim</code>
<code class="c1">## [1] 2 3</code></pre><p>You can apply <code class="literal">class</code> to objects that do not have a <code class="literal">class</code> attribute. <code class="literal">class</code> will return a value based on the object’s atomic type. Notice that the “class” of a double is “numeric,” an odd deviation, but one I am thankful for.<a id="id385456" class="indexterm"/><a id="id385458" class="indexterm"/> I think that the most important property of a double vector is that it contains numbers, a property that “numeric” makes obvious:</p><pre class="programlisting">class<code class="p">(</code><code class="s">"Hello"</code><code class="p">)</code>
<code class="c1">##  "character"</code>

class<code class="p">(</code><code class="m">5</code><code class="p">)</code>
<code class="c1">##  "numeric"</code></pre><p>You can also use <code class="literal">class</code> to set an object’s <code class="literal">class</code> attribute, but this is usually a bad idea. R will expect objects of a class to share certain traits, such as attributes, that your object may not possess. You’ll learn how to make and use your own classes in <a class="xref" href="pt03.html" title="Part III. Project 3: Slot Machine">Part III</a>.</p><div class="sect2" title="Dates and Times"><div class="titlepage"><div><div><h3 class="title" id="_dates_and_times">Dates and Times</h3></div></div></div><p>The attribute system lets R represent more types of data than just doubles, integers, characters, logicals, complexes, and raws.<a id="id385969" class="indexterm"/><a id="id514968" class="indexterm"/><a id="id385975" class="indexterm"/> For example, R uses a special class to represent dates and times. To see this, run <span class="strong"><strong><code class="literal">Sys.time()</code></strong></span>. <code class="literal">Sys.time</code> returns the current time on your computer.<a id="id514986" class="indexterm"/><a id="id485875" class="indexterm"/> The time looks like a character string when you display it, but its data type is actually <code class="literal">"double"</code>, and its class is <code class="literal">"POSIXct"</code> <code class="literal">"POSIXt"</code> (it has two classes):</p><pre class="programlisting">now <code class="o">&lt;-</code> Sys.time<code class="p">()</code>
now
<code class="c1">## "2014-03-17 12:00:00 UTC"</code>

typeof<code class="p">(</code>now<code class="p">)</code>
<code class="c1">##  "double"</code>

class<code class="p">(</code>now<code class="p">)</code>
<code class="c1">## "POSIXct" "POSIXt"</code></pre><p>POSIXct is a widely used framework for representing dates and times. In the POSIXct framework, each time is represented by the number of seconds that have passed between the time and 12:00 AM January 1st 1970 (in the Universal Time Coordinated (UTC) zone). For example, the time above occurs 1,395,057,600 seconds after then. So in the POSIXct system, the time would be saved as 1395057600.<a id="id434393" class="indexterm"/></p><p>R creates the time object by building a double vector with one element, <code class="literal">1395057600</code>. You can see this vector by removing the <code class="literal">class</code> attribute of <code class="literal">now</code>, or by using the <code class="literal">unclass</code> function, which does the same thing:</p><pre class="programlisting">unclass<code class="p">(</code>now<code class="p">)</code>
<code class="c1">## 1395057600</code></pre><p>R then gives the double vector a <code class="literal">class</code> attribute that contains two classes, <code class="literal">"POSIXct"</code> and <code class="literal">"POSIXt"</code>. This attribute alerts R functions that they are dealing with a POSIXct time, so they can treat it in a special way. For example, R functions will use the POSIXct standard to convert the time into a user-friendly character string before displaying it.</p><p>You can take advantage of this system by giving the <code class="literal">POSIXct</code> class to random R objects. For example, have you ever wondered what day it was a million seconds after 12:00 a.m. Jan. 1, 1970?</p><pre class="programlisting">mil <code class="o">&lt;-</code> <code class="m">1000000</code>
mil
<code class="c1">## 1e+06</code>

class<code class="p">(</code>mil<code class="p">)</code> <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"POSIXct"</code><code class="p">,</code> <code class="s">"POSIXt"</code><code class="p">)</code>
mil
<code class="c1">## "1970-01-12 13:46:40 UTC"</code></pre><p>Jan. 12, 1970. Yikes. A million seconds goes by faster than you would think. This conversion worked well because the <code class="literal">POSIXct</code> class does not rely on any additional attributes, but in general, forcing the class of an object is a bad idea.</p><p>There are many different classes of data in R and its packages, and new classes are invented every day. It would be difficult to learn about every class, but you do not have to. Most classes are only useful in specific situations. Since each class comes with its own help page, you can wait to learn about a class until you encounter it. However, there is one class of data that is so ubiquitous in R that you should learn about it alongside the atomic data types. That class is <code class="literal">factors</code>.</p></div><div class="sect2" title="Factors"><div class="titlepage"><div><div><h3 class="title" id="_factors">Factors</h3></div></div></div><p>Factors are R’s way of storing categorical information, like ethnicity or eye color. Think of a factor as something like a gender; it can only have certain values (male or female), and these values may have their own idiosyncratic order (ladies first). This arrangement makes factors very useful for recording the treatment levels of a study and other categorical variables.<a id="id448028" class="indexterm"/><a id="id386428" class="indexterm"/><a id="id386434" class="indexterm"/><a id="id386440" class="indexterm"/></p><p>To make a factor, pass an atomic vector into the <code class="literal">factor</code> function. R will recode the data in the vector as integers and store the results in an integer vector. R will also add a <code class="literal">levels</code> attribute to the integer, which contains a set of labels for displaying the factor values, and a <code class="literal">class</code> attribute, which contains the class <code class="literal">factor</code>:</p><pre class="programlisting">gender <code class="o">&lt;-</code> factor<code class="p">(</code>c<code class="p">(</code><code class="s">"male"</code><code class="p">,</code> <code class="s">"female"</code><code class="p">,</code> <code class="s">"female"</code><code class="p">,</code> <code class="s">"male"</code><code class="p">))</code>

typeof<code class="p">(</code>gender<code class="p">)</code>
<code class="c1">## "integer"</code>

attributes<code class="p">(</code>gender<code class="p">)</code>
<code class="c1">## $levels</code>
<code class="c1">## [1] "female" "male"</code>
<code class="c1">##</code>
<code class="c1">## $class</code>
<code class="c1">## [1] "factor"</code></pre><p>You can see exactly how R is storing your<a id="id369902" class="indexterm"/> factor with <code class="literal">unclass</code>:</p><pre class="programlisting">unclass<code class="p">(</code>gender<code class="p">)</code>
<code class="c1">## [1] 2 1 1 2</code>
<code class="c1">## attr(,"levels")</code>
<code class="c1">## [1] "female" "male"</code></pre><p>R uses the levels attribute when it displays the factor, as you will see. R will display each <code class="literal">1</code> as <code class="literal">female</code>, the first label in the levels vector, and each <code class="literal">2</code> as <code class="literal">male</code>, the second label. If the factor included <code class="literal">3</code>s, they would be displayed as the third label, and so on:</p><pre class="programlisting">gender
<code class="c1">## male   female female male</code>
<code class="c1">## Levels: female male</code></pre><p>Factors make it easy to put categorical variables into a statistical model because the variables are already coded as numbers. However, factors can be confusing since they look like character strings but behave like integers.<a id="id378348" class="indexterm"/></p><p>R will often try to convert character strings to factors when you load and create data. In general, you will have a smoother experience if you do not let R make factors until you ask for them. I’ll show you how to do this when we start reading in data.</p><p>You can convert a factor to a character string with the <code class="literal">as.character</code> function.<a id="id378358" class="indexterm"/><a id="id378367" class="indexterm"/> R will retain the display version of the factor, not the integers stored in memory:</p><pre class="programlisting">as.character<code class="p">(</code>gender<code class="p">)</code>
<code class="c1">## "male"   "female" "female" "male"</code></pre><p>Now that you understand the possibilities provided by R’s atomic vectors, let’s make a more complicated type of playing card.</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Many card games assign a numerical value to each card. For example, in blackjack, each face card is worth 10 points, each number card is worth between 2 and 10 points, and each ace is worth 1 or 11 points, depending on the final score.</p><p>Make a virtual playing card by combining “ace,” “heart,” and 1 into a vector. What type of atomic vector will result? Check if you are right.</p></div><p>You may have guessed that this exercise would not go well. Each atomic vector can only store one type of data. As a result, R coerces all of your values to character strings:</p><pre class="programlisting">card <code class="o">&lt;-</code> c<code class="p">(</code><code class="s">"ace"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="m">1</code><code class="p">)</code>
card
<code class="c1">## "ace"    "hearts" "1"</code></pre><p>This will cause trouble if you want to do math with that point value, for example, to see who won your game of blackjack.</p><div class="warning" title="Data types in vectors" epub:type="warning"><h3 class="title">Data types in vectors</h3><p>If you try to put multiple types of data into a vector, R will convert the elements to a single type of data.<a id="id372247" class="indexterm"/><a id="id372231" class="indexterm"/></p></div><p>Since matrices and arrays are special cases of atomic vectors, they suffer from the same behavior. Each can only store one type of data.</p><p>This creates a couple of problems. First, many data sets contain multiple types of data. Simple programs like Excel and Numbers can save multiple types of data in the same data set, and you should hope that R can too. Don’t worry, it can.<a id="id373779" class="indexterm"/></p><p>Second, coercion is a common behavior in R, so you’ll want to know how it works.</p></div></div><div class="sect1" title="Coercion"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_coercion">Coercion</h2></div></div></div><p>R’s coercion behavior may seem inconvenient, but it is not arbitrary. R always follows the same rules when it coerces data types. Once you are familiar with these rules, you can use R’s coercion behavior to do surprisingly useful things.<a id="id448157" class="indexterm"/><a id="id373803" class="indexterm"/><a id="id448166" class="indexterm"/><a id="id448174" class="indexterm"/><a id="id448183" class="indexterm"/></p><p>So how does R coerce data types? If a character string is present in an atomic vector, R will convert everything else in the vector to character strings. If a vector only contains logicals and numbers, R will convert the logicals to numbers; every <code class="literal">TRUE</code> becomes a 1, and every <code class="literal">FALSE</code> becomes a 0, as shown in <a class="xref" href="ch03.html#FIGURE-ORGANIZING-COERCION" title="Figure 3-1. R always uses the same rules to coerce data to a single type. If character strings are present, everything will be coerced to a character string. Otherwise, logicals are coerced to numerics.">Figure 3-1</a>.</p><div class="figure"><a id="FIGURE-ORGANIZING-COERCION"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0301.png" alt="Coercion rules"/></div></div><div class="figure-title">Figure 3-1. R always uses the same rules to coerce data to a single type. If character strings are present, everything will be coerced to a character string. Otherwise, logicals are coerced to numerics.</div></div><p>This arrangement preserves information. It is easy to look at a character string and tell what information it used to contain. For example, you can easily spot the origins of <code class="literal">"TRUE"</code> and <code class="literal">"5"</code>. You can also easily back-transform a vector of 1s and 0s to <code class="literal">TRUE</code>s and <code class="literal">FALSE</code>s.</p><p>R uses the same coercion rules when you try to do math with logical values. So the following code:</p><pre class="programlisting">sum<code class="p">(</code>c<code class="p">(</code><code class="kc">TRUE</code><code class="p">,</code> <code class="kc">TRUE</code><code class="p">,</code> <code class="kc">FALSE</code><code class="p">,</code> <code class="kc">FALSE</code><code class="p">))</code></pre><p>will become:</p><pre class="programlisting">sum<code class="p">(</code>c<code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">1</code><code class="p">,</code> <code class="m">0</code><code class="p">,</code> <code class="m">0</code><code class="p">))</code>
<code class="c1">## 2</code></pre><p>This means that <code class="literal">sum</code> will count the number of <code class="literal">TRUE</code>s in a logical vector (and <code class="literal">mean</code> will calculate the proportion of <code class="literal">TRUE</code>s). Neat, huh?</p><p>You can explicitly ask R to convert data from one type to another with the <code class="literal">as</code> functions. R will convert the data whenever there is a sensible way to do so:</p><pre class="programlisting">as.character<code class="p">(</code><code class="m">1</code><code class="p">)</code>
<code class="c1">## "1"</code>

as.logical<code class="p">(</code><code class="m">1</code><code class="p">)</code>
<code class="c1">## TRUE</code>

as.numeric<code class="p">(</code><code class="kc">FALSE</code><code class="p">)</code>
<code class="c1">## 0</code></pre><p>You now know how R coerces data types, but this won’t help you save a playing card. To do that, you will need to avoid coercion altogether. You can do this by using a new type of object, a <span class="emphasis"><em>list</em></span>.</p><p>Before we look at lists, let’s address a question that might be on your mind.</p><p>Many data sets contain multiple types of information. The inability of vectors, matrices, and arrays to store multiple data types seems like a major limitation. So why bother with them?<a id="id459544" class="indexterm"/><a id="id486537" class="indexterm"/></p><p>In some cases, using only a single type of data is a huge advantage. Vectors, matrices, and arrays make it very easy to do math on large sets of numbers because R knows that it can manipulate each value the same way. Operations with vectors, matrices, and arrays also tend to be fast because the objects are so simple to store in memory.</p><p>In other cases, allowing only a single type of data is not a disadvantage. Vectors are the most common data structure in R because they store variables very well. Each value in a variable measures the same property, so there’s no need to use different types of data.</p></div><div class="sect1" title="Lists"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_lists">Lists</h2></div></div></div><p>Lists are like atomic vectors because they group data into a one-dimensional set.<a id="id459529" class="indexterm"/><a id="id459537" class="indexterm"/><a id="id483113" class="indexterm"/> However, lists do not group together individual values; lists group together R objects, such as atomic vectors and other lists. For example, you can make a list that contains a numeric vector of length 31 in its first element, a character vector of length 1 in its second element, and a new list of length 2 in its third element. To do this, use the <code class="literal">list</code> function.</p><p><code class="literal">list</code> creates a list the same way <code class="literal">c</code> creates a vector. Separate each element in the list with a comma:</p><pre class="programlisting">list1 <code class="o">&lt;-</code> list<code class="p">(</code><code class="m">100</code><code class="o">:</code><code class="m">130</code><code class="p">,</code> <code class="s">"R"</code><code class="p">,</code> list<code class="p">(</code><code class="kc">TRUE</code><code class="p">,</code> <code class="kc">FALSE</code><code class="p">))</code>
list1
<code class="c1">## [[1]]</code>
<code class="c1">## [1] 100 101 102 103 104 105 106 107 108 109 110 111 112</code>
<code class="c1">## [14] 113 114 115 116 117 118 119 120 121 122 123 124 125</code>
<code class="c1">## [27] 126 127 128 129 130</code>
<code class="c1">##</code>
<code class="c1">## [[2]]</code>
<code class="c1">## [1] "R"</code>
<code class="c1">##</code>
<code class="c1">## [[3]]</code>
<code class="c1">## [[3]][[1]]</code>
<code class="c1">## [1] TRUE</code>
<code class="c1">##</code>
<code class="c1">## [[3]][[2]]</code>
<code class="c1">## [1] FALSE</code></pre><p>I left the <code class="literal">[1]</code> notation in the output so you can see how it changes for lists. The double-bracketed indexes tell you which element of the list is being displayed. The single-bracket indexes tell you which subelement of an element is being displayed. For example, <code class="literal">100</code> is the first subelement of the first element in the list. <code class="literal">"R"</code> is the first sub-element of the second element. This two-system notation arises because each element of a list can be <span class="emphasis"><em>any</em></span> R object, including a new vector (or list) with its own indexes.</p><p>Lists are a basic type of object in R, on par with atomic vectors. Like atomic vectors, they are used as building blocks to create many more spohisticated types of R objects.</p><p>As you can imagine, the structure of lists can become quite complicated, but this flexibility makes lists a useful all-purpose storage tool in R: you can group together anything with a list.</p><p>However, not every list needs to be complicated. You can store a playing card in a very simple list.</p><div class="sidebar"><div class="sidebar-title">Exercise</div><p>Use a list to store a single playing card, like the ace of hearts, which has a point value of one. The list should save the face of the card, the suit, and the point value in separate elements.</p></div><p>You can create your card like this. In the following example, the first element of the list is a character vector (of length 1). The second element is also a character vector, and the third element is a numeric vector:</p><pre class="programlisting">card <code class="o">&lt;-</code> list<code class="p">(</code><code class="s">"ace"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="m">1</code><code class="p">)</code>
card
<code class="c1">## [[1]]</code>
<code class="c1">## [1] "ace"</code>
<code class="c1">##</code>
<code class="c1">## [[2]]</code>
<code class="c1">## [1] "hearts"</code>
<code class="c1">##</code>
<code class="c1">## [[3]]</code>
<code class="c1">## [1] 1</code></pre><p>You can also use a list to store a whole deck of playing cards.<a id="id492677" class="indexterm"/> Since you can save a single playing card as a list, you can save a deck of playing cards as a list of 52 sublists (one for each card). But let’s not bother—there’s a much cleaner way to do the same thing. You can use a special class of list, known as a <span class="emphasis"><em>data frame</em></span>.</p></div><div class="sect1" title="Data Frames"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_data_frames">Data Frames</h2></div></div></div><p>Data frames are the two-dimensional version of a list. They are far and away the most useful storage structure for data analysis, and they provide an ideal way to store an entire deck of cards. You can think of a data frame as R’s equivalent to the Excel spreadsheet because it stores data in a similar format.<a id="id484013" class="indexterm"/><a id="id444248" class="indexterm"/><a id="id444256" class="indexterm"/><a id="id467334" class="indexterm"/></p><p>Data frames group vectors together into a two-dimensional table. Each vector becomes a column in the table. As a result, each column of a data frame can contain a different type of data; but within a column, every cell must be the same type of data, as in <a class="xref" href="ch03.html#FIGURE-ORGANIZING-DATA-FRAME" title="Figure 3-2. Data frames store data as a sequence of columns. Each column can be a different data type. Every column in a data frame must be the same length.">Figure 3-2</a>.</p><div class="figure"><a id="FIGURE-ORGANIZING-DATA-FRAME"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0302.png" alt="Data frames"/></div></div><div class="figure-title">Figure 3-2. Data frames store data as a sequence of columns. Each column can be a different data type. Every column in a data frame must be the same length.</div></div><p>Creating a data frame by hand takes a lot of typing, but you can do it (if you like) with the <code class="literal">data.frame</code> function. Give <code class="literal">data.frame</code> any number of vectors, each separated with a comma. Each vector should be set equal to a name that describes the vector. <code class="literal">data.frame</code> will turn each vector into a column of the new data frame:</p><pre class="programlisting">df <code class="o">&lt;-</code> data.frame<code class="p">(</code>face <code class="o">=</code> c<code class="p">(</code><code class="s">"ace"</code><code class="p">,</code> <code class="s">"two"</code><code class="p">,</code> <code class="s">"six"</code><code class="p">),</code>
  suit <code class="o">=</code> c<code class="p">(</code><code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">),</code> value <code class="o">=</code> c<code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">))</code>
df
<code class="c1">## face  suit value</code>
<code class="c1">##  ace clubs     1</code>
<code class="c1">##  two clubs     2</code>
<code class="c1">##  six clubs     3</code></pre><p>You’ll need to make sure that each vector is the same length (or can be made so with R’s recycling rules; see <a class="xref" href="ch01.html#FIGURE-LANGUAGE-RECYCLE" title="Figure 1-4. R will repeat a short vector to do element-wise operations with two vectors of uneven lengths.">Figure 1-4</a>), as data frames cannot combine columns of different lengths.</p><p>In the previous code, I named the arguments in <code class="literal">data.frame</code> <code class="literal">face</code>, <code class="literal">suit</code>, and <code class="literal">value</code>, but you can name the arguments whatever you like. <code class="literal">data.frame</code> will use your argument names to label the columns of the data frame.</p><div class="tip" title="Names"><h3 class="title">Names</h3><p>You can also give names to a list or vector when you create one of these objects.<a id="id370792" class="indexterm"/> Use the same syntax as with <code class="literal">data.frame</code>:</p><pre class="programlisting">list<code class="p">(</code>face <code class="o">=</code> <code class="s">"ace"</code><code class="p">,</code> suit <code class="o">=</code> <code class="s">"hearts"</code><code class="p">,</code> value <code class="o">=</code> <code class="m">1</code><code class="p">)</code>
c<code class="p">(</code>face <code class="o">=</code> <code class="s">"ace"</code><code class="p">,</code> suit <code class="o">=</code> <code class="s">"hearts"</code><code class="p">,</code> value <code class="o">=</code> <code class="s">"one"</code><code class="p">)</code></pre><p>The names will be stored in the object’s <code class="literal">names</code> attribute.</p></div><p>If you look at the type of a data frame, you will see that it is a list. In fact, each data frame is a list with class <code class="literal">data.frame</code>.<a id="id481311" class="indexterm"/> You can see what types of objects are grouped together by a list (or data frame) with the <code class="literal">str</code> function:</p><pre class="programlisting">typeof<code class="p">(</code>df<code class="p">)</code>
<code class="c1">## "list"</code>

class<code class="p">(</code>df<code class="p">)</code>
<code class="c1">## "data.frame"</code>

str<code class="p">(</code>df<code class="p">)</code>
<code class="c1">## 'data.frame':        3 obs. of  3 variables:</code>
<code class="c1">##  $ face : Factor w/ 3 levels "ace","six","two": 1 3 2</code>
<code class="c1">##  $ suit : Factor w/ 1 level "clubs": 1 1 1</code>
<code class="c1">##  $ value: num  1 2 3</code></pre><p>Notice that R saved your character strings as factors.<a id="id481294" class="indexterm"/><a id="id508431" class="indexterm"/> I told you that R likes factors! It is not a very big deal here, but you can prevent this behavior by adding the argument <code class="literal">stringsAsFactors = FALSE</code> to <code class="literal">data.frame</code>:</p><pre class="programlisting">df <code class="o">&lt;-</code> data.frame<code class="p">(</code>face <code class="o">=</code> c<code class="p">(</code><code class="s">"ace"</code><code class="p">,</code> <code class="s">"two"</code><code class="p">,</code> <code class="s">"six"</code><code class="p">),</code>
  suit <code class="o">=</code> c<code class="p">(</code><code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">),</code> value <code class="o">=</code> c<code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">),</code>
  stringsAsFactors <code class="o">=</code> <code class="kc">FALSE</code><code class="p">)</code></pre><p>A data frame is a great way to build an entire deck of cards.<a id="id429924" class="indexterm"/> You can make each row in the data frame a playing card, and each column a type of value—each with its own appropriate data type. The data frame would look something like this:</p><pre class="programlisting"><code class="c1">##   face     suit value</code>
<code class="c1">##   king   spades    13</code>
<code class="c1">##  queen   spades    12</code>
<code class="c1">##   jack   spades    11</code>
<code class="c1">##    ten   spades    10</code>
<code class="c1">##   nine   spades     9</code>
<code class="c1">##  eight   spades     8</code>
<code class="c1">##  seven   spades     7</code>
<code class="c1">##    six   spades     6</code>
<code class="c1">##   five   spades     5</code>
<code class="c1">##   four   spades     4</code>
<code class="c1">##  three   spades     3</code>
<code class="c1">##    two   spades     2</code>
<code class="c1">##    ace   spades     1</code>
<code class="c1">##   king    clubs    13</code>
<code class="c1">##  queen    clubs    12</code>
<code class="c1">##   jack    clubs    11</code>
<code class="c1">##    ten    clubs    10</code>
<code class="c1">##   ... and so on.</code></pre><p>You could create this data frame with <code class="literal">data.frame</code>, but look at the typing involved! You need to write three vectors, each with 52 elements:</p><pre class="programlisting">deck <code class="o">&lt;-</code> data.frame<code class="p">(</code>
  face <code class="o">=</code> c<code class="p">(</code><code class="s">"king"</code><code class="p">,</code> <code class="s">"queen"</code><code class="p">,</code> <code class="s">"jack"</code><code class="p">,</code> <code class="s">"ten"</code><code class="p">,</code> <code class="s">"nine"</code><code class="p">,</code> <code class="s">"eight"</code><code class="p">,</code> <code class="s">"seven"</code><code class="p">,</code> <code class="s">"six"</code><code class="p">,</code>
    <code class="s">"five"</code><code class="p">,</code> <code class="s">"four"</code><code class="p">,</code> <code class="s">"three"</code><code class="p">,</code> <code class="s">"two"</code><code class="p">,</code> <code class="s">"ace"</code><code class="p">,</code> <code class="s">"king"</code><code class="p">,</code> <code class="s">"queen"</code><code class="p">,</code> <code class="s">"jack"</code><code class="p">,</code> <code class="s">"ten"</code><code class="p">,</code>
    <code class="s">"nine"</code><code class="p">,</code> <code class="s">"eight"</code><code class="p">,</code> <code class="s">"seven"</code><code class="p">,</code> <code class="s">"six"</code><code class="p">,</code> <code class="s">"five"</code><code class="p">,</code> <code class="s">"four"</code><code class="p">,</code> <code class="s">"three"</code><code class="p">,</code> <code class="s">"two"</code><code class="p">,</code> <code class="s">"ace"</code><code class="p">,</code>
    <code class="s">"king"</code><code class="p">,</code> <code class="s">"queen"</code><code class="p">,</code> <code class="s">"jack"</code><code class="p">,</code> <code class="s">"ten"</code><code class="p">,</code> <code class="s">"nine"</code><code class="p">,</code> <code class="s">"eight"</code><code class="p">,</code> <code class="s">"seven"</code><code class="p">,</code> <code class="s">"six"</code><code class="p">,</code> <code class="s">"five"</code><code class="p">,</code>
    <code class="s">"four"</code><code class="p">,</code> <code class="s">"three"</code><code class="p">,</code> <code class="s">"two"</code><code class="p">,</code> <code class="s">"ace"</code><code class="p">,</code> <code class="s">"king"</code><code class="p">,</code> <code class="s">"queen"</code><code class="p">,</code> <code class="s">"jack"</code><code class="p">,</code> <code class="s">"ten"</code><code class="p">,</code> <code class="s">"nine"</code><code class="p">,</code>
    <code class="s">"eight"</code><code class="p">,</code> <code class="s">"seven"</code><code class="p">,</code> <code class="s">"six"</code><code class="p">,</code> <code class="s">"five"</code><code class="p">,</code> <code class="s">"four"</code><code class="p">,</code> <code class="s">"three"</code><code class="p">,</code> <code class="s">"two"</code><code class="p">,</code> <code class="s">"ace"</code><code class="p">),</code>
  suit <code class="o">=</code> c<code class="p">(</code><code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code>
    <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code> <code class="s">"spades"</code><code class="p">,</code>
    <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code>
    <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"clubs"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code>
    <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code>
    <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"diamonds"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code>
    <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code>
    <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">,</code> <code class="s">"hearts"</code><code class="p">),</code>
  value <code class="o">=</code> c<code class="p">(</code><code class="m">13</code><code class="p">,</code> <code class="m">12</code><code class="p">,</code> <code class="m">11</code><code class="p">,</code> <code class="m">10</code><code class="p">,</code> <code class="m">9</code><code class="p">,</code> <code class="m">8</code><code class="p">,</code> <code class="m">7</code><code class="p">,</code> <code class="m">6</code><code class="p">,</code> <code class="m">5</code><code class="p">,</code> <code class="m">4</code><code class="p">,</code> <code class="m">3</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">1</code><code class="p">,</code> <code class="m">13</code><code class="p">,</code> <code class="m">12</code><code class="p">,</code> <code class="m">11</code><code class="p">,</code> <code class="m">10</code><code class="p">,</code> <code class="m">9</code><code class="p">,</code> <code class="m">8</code><code class="p">,</code>
    <code class="m">7</code><code class="p">,</code> <code class="m">6</code><code class="p">,</code> <code class="m">5</code><code class="p">,</code> <code class="m">4</code><code class="p">,</code> <code class="m">3</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">1</code><code class="p">,</code> <code class="m">13</code><code class="p">,</code> <code class="m">12</code><code class="p">,</code> <code class="m">11</code><code class="p">,</code> <code class="m">10</code><code class="p">,</code> <code class="m">9</code><code class="p">,</code> <code class="m">8</code><code class="p">,</code> <code class="m">7</code><code class="p">,</code> <code class="m">6</code><code class="p">,</code> <code class="m">5</code><code class="p">,</code> <code class="m">4</code><code class="p">,</code> <code class="m">3</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">1</code><code class="p">,</code> <code class="m">13</code><code class="p">,</code> <code class="m">12</code><code class="p">,</code> <code class="m">11</code><code class="p">,</code>
    <code class="m">10</code><code class="p">,</code> <code class="m">9</code><code class="p">,</code> <code class="m">8</code><code class="p">,</code> <code class="m">7</code><code class="p">,</code> <code class="m">6</code><code class="p">,</code> <code class="m">5</code><code class="p">,</code> <code class="m">4</code><code class="p">,</code> <code class="m">3</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">1</code><code class="p">)</code>
<code class="p">)</code></pre><p>You should avoid typing large data sets in by hand whenever possible. Typing invites typos and errors, not to mention RSI. It is always better to acquire large data sets as a computer file. You can then ask R to read the file and store the contents as an object.<a id="id372502" class="indexterm"/></p><p>I’ve created a file for you to load that contains a data frame of playing-card information, so don’t worry about typing in the code. Instead, turn your attention toward loading data into R.</p></div><div class="sect1" title="Loading Data"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="LOADING">Loading Data</h2></div></div></div><p>You can load the <code class="literal">deck</code> data frame from the file <a class="ulink" href="http://bit.ly/deck_CSV" target="_top"><span class="emphasis"><em>deck.csv</em></span></a>. Please take a moment to download the file before reading on. Visit the website, click "Download Gist,” and then open the folder that your web browser downloads. <span class="emphasis"><em>deck.csv</em></span> will be inside.<a id="id386579" class="indexterm"/><a id="id386591" class="indexterm"/><a id="id386602" class="indexterm"/></p><p><span class="emphasis"><em>deck.csv</em></span> is a comma-separated values file, or CSV for short. CSVs are plain-text files, which means you can open them in a text editor (as well as many other programs). If you open <span class="emphasis"><em>desk.csv</em></span>, you’ll notice that it contains a table of data that looks like the following table. Each row of the table is saved on its own line, and a comma is used to separate the cells within each row.  Every CSV file shares this basic format:<a id="id462333" class="indexterm"/></p><pre class="screen">"face","suit,"value"
"king","spades",13
"queen","spades,12
"jack","spades,11
"ten","spades,10
"nine","spades,9
... and so on.</pre><p>Most data-science applications can open plain-text files and export data as plain-text files. This makes plain-text files a sort of lingua franca for data science.</p><p>To load a plain-text file into R, click the Import Dataset icon in RStudio, shown in <a class="xref" href="ch03.html#FIGURE-IMPORT" title="Figure 3-3. You can import data from plain-text files with RStudio’s Import Dataset.">Figure 3-3</a>. Then select “From text file.”<a id="id462361" class="indexterm"/></p><div class="figure"><a id="FIGURE-IMPORT"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0303.png.jpg" alt="Import Dataset"/></div></div><div class="figure-title">Figure 3-3. You can import data from plain-text files with RStudio’s Import Dataset.</div></div><p>RStudio will ask you to select the file you want to import, then it will open a wizard to help you import the data, as in <a class="xref" href="ch03.html#FIGURE-WIZARD" title="Figure 3-4. RStudio’s import wizard.">Figure 3-4</a>. Use the wizard to tell RStudio what name to give the data set.<a id="id476663" class="indexterm"/><a id="id476672" class="indexterm"/><a id="id476678" class="indexterm"/><a id="id441329" class="indexterm"/>  You can also use the wizard to tell RStudio which character the data set uses as a separator, which character it uses to represent decimals (usually a period in the United States and a comma in Europe), and whether or not the data set comes with a row of column names (known as a <span class="emphasis"><em>header</em></span>). To help you out, the wizard shows you what the raw file looks like, as well as what your loaded data will look like based on the input settings.</p><p>You can also unclick the box “Strings as factors” in the wizard. I recommend doing this. If you do, R will load all of your character strings as character strings. If you do not, R will convert them to factors.<a id="id441340" class="indexterm"/></p><div class="figure"><a id="FIGURE-WIZARD"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0304.png.jpg" alt="Import Wizard"/></div></div><div class="figure-title">Figure 3-4. RStudio’s import wizard.</div></div><p>Once everything looks right, click Import. RStudio will read in the data and save it to a data frame. RStudio will also open a data viewer, so you can see your new data in a spreadsheet format. This is a good way to check that everything came through as expected. If all worked well, your file should appear in a View tab of RStudio, like in <a class="xref" href="ch03.html#FIGURE-OBJECTS-VIEW" title="Figure 3-5. When you import a data set, RStudio will save the data to a data frame and then display the data frame in a View tab. You can open any data frame in a View tab at any time with the View function.">Figure 3-5</a>. You can examine the data frame in the console with <span class="strong"><strong><code class="literal">head(deck)</code></strong></span>.<a id="id458248" class="indexterm"/><a id="id458262" class="indexterm"/><a id="id458268" class="indexterm"/><a id="id458276" class="indexterm"/><a id="id458284" class="indexterm"/></p><div class="tip" title="Online data"><h3 class="title">Online data</h3><p>You can load a plain-text file straight from the Internet by clicking the “From Web URL…” option under Import Dataset. The file will need to have its own URL, and you will need to be connected.<a id="id464035" class="indexterm"/><a id="id464033" class="indexterm"/></p></div><div class="figure"><a id="FIGURE-OBJECTS-VIEW"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0305.png.jpg" alt="View tab"/></div></div><div class="figure-title">Figure 3-5. When you import a data set, RStudio will save the data to a data frame and then display the data frame in a View tab. You can open any data frame in a View tab at any time with the View function.</div></div><p>Now it is your turn. Download <span class="emphasis"><em>deck.csv</em></span> and import it into RStudio. Be sure to save the output to an R object called <code class="literal">deck</code>: you’ll use it in the next few chapters. If everything goes correctly, the first few lines of your data frame should look like this:</p><pre class="programlisting">head<code class="p">(</code>deck<code class="p">)</code> <a id="CO5-1"/><img src="callouts/1.png" alt="1"/>
<code class="c1">##  face   suit value</code>
<code class="c1">##  king spades    13</code>
<code class="c1">## queen spades    12</code>
<code class="c1">##  jack spades    11</code>
<code class="c1">##   ten spades    10</code>
<code class="c1">##  nine spades     9</code>
<code class="c1">## eight spades     8</code></pre><div class="calloutlist"><dl><dt><a href="#CO5-1"><img src="callouts/1.png" alt="1"/></a> </dt><dd><p>
<code class="literal">head</code> and <code class="literal">tail</code> are two functions that provide an easy way to peek at large data sets. <code class="literal">head</code> will return just the first six rows of the data set, and <code class="literal">tail</code> will return just the last six rows.<a id="id387528" class="indexterm"/><a id="id387535" class="indexterm"/><a id="id387541" class="indexterm"/><a id="id388928" class="indexterm"/><a id="id388937" class="indexterm"/> To see a different number of rows, give <code class="literal">head</code> or <code class="literal">tails</code> a second argument, the number of rows you would like to view, for example, <code class="literal">head(deck, 10)</code>.
</p></dd></dl></div><p>R can open many types of files—not just CSVs. Visit <a class="xref" href="apd.html" title="Appendix D. Loading and Saving Data in R">Appendix D</a> to learn how to open other common types of files in R.</p></div><div class="sect1" title="Saving Data"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_saving_data">Saving Data</h2></div></div></div><p>Before we go any further, let’s save a copy of <code class="literal">deck</code> as a new <span class="emphasis"><em>.csv</em></span> file. That way you can email it to a colleague, store it on a thumb drive, or open it in a different program.<a id="id444272" class="indexterm"/><a id="id444283" class="indexterm"/><a id="id444295" class="indexterm"/><a id="id444301" class="indexterm"/><a id="id444307" class="indexterm"/> You can save any data frame in R to a <span class="emphasis"><em>.csv</em></span> file with the command <code class="literal">write.csv</code>. To save <code class="literal">deck</code>, run:</p><pre class="programlisting">write.csv<code class="p">(</code>deck<code class="p">,</code> file <code class="o">=</code> <code class="s">"cards.csv"</code><code class="p">,</code> row.names <code class="o">=</code> <code class="kc">FALSE</code><code class="p">)</code></pre><p>R will turn your data frame into a plain-text file with the comma-separated values format and save the file to your working directory. To see where your working directory is, run <span class="strong"><strong><code class="literal">getwd()</code></strong></span>. To change the location of your working directory, visit Session &gt; Set Working Directory &gt; Choose Directory in the RStudio menu bar.</p><p>You can customize the save process with <code class="literal">write.csv</code>’s large set of optional arguments (see <code class="literal">?write.csv</code> for details). However, there are three arguments that you should use <span class="emphasis"><em>every</em></span> time you run <code class="literal">write.csv</code>.</p><p>First, you should give <code class="literal">write.csv</code> the name of the data frame that you wish to save. Next, you should provide a file name to give your file. R will take this name quite literally, so be sure to provide an extension.</p><p>Finally, you should add the argument <code class="literal">row.names = FALSE</code>.<a id="id453059" class="indexterm"/> This will prevent R from adding a column of numbers at the start of your data frame. These numbers will identify your rows from 1 to 52, but it is unlikely that whatever program you open <span class="emphasis"><em>cards.csv</em></span> in will understand the row name system. More than likely, the program will assume that the row names are the first column of data in your data frame. In fact, this is exactly what R will assume if you reopen <span class="emphasis"><em>cards.csv</em></span>. If you save and open <span class="emphasis"><em>cards.csv</em></span> several times in R, you’ll notice duplicate columns of row numbers forming at the start of your data frame. I can’t explain why R does this, but I can explain how to avoid it: use <code class="literal">row.names = FALSE</code> whenever you save data with <code class="literal">write.csv</code>.</p><p>For more details about saving files, including how to compress saved files and how to save files in other formats, see <a class="xref" href="apd.html" title="Appendix D. Loading and Saving Data in R">Appendix D</a>.</p><p>Good work. You now have a virtual deck of cards to work with. Take a breather, and when you come back, we’ll start writing some functions to use on your deck.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="_summary_3">Summary</h2></div></div></div><p>You can save data in R with five different objects, which let you store different types of values in different types of relationships, as in <a class="xref" href="ch03.html#FIGURE-ORGANIZING-STRUCTURES" title="Figure 3-6. R’s most common data structures are vectors, matrices, arrays, lists, and data frames.">Figure 3-6</a>. Of these objects, data frames are by far the most useful for data science. Data frames store one of the most common forms of data used in data science, tabular data.<a id="id442537" class="indexterm"/><a id="id442534" class="indexterm"/></p><div class="figure"><a id="FIGURE-ORGANIZING-STRUCTURES"/><div class="figure-contents"><div class="mediaobject"><img src="images/hopr_0306.png" alt="Data structures in R"/></div></div><div class="figure-title">Figure 3-6. R’s most common data structures are vectors, matrices, arrays, lists, and data frames.</div></div><p>You can load tabular data into a data frame with RStudio’s Import Dataset button—so long as the data is saved as a plain-text file. This requirement is not as limiting as it sounds. Most software programs can export data as a plain-text file. So if you have an Excel file (for example) you can open the file in Excel and export the data as a CSV to use with R. In fact, opening a file in its original program is good practice. Excel files use metadata, like sheets and formulas, that help Excel work with the file. R can try to extract raw data from the file, but it won’t be as good at doing this as Microsoft Excel is. No program is better at converting Excel files than Excel. Similarly, no program is better at converting SAS Xport files than SAS, and so on.</p><p>However, you may find yourself with a program-specific file, but not the program that created it. You wouldn’t want to buy a multi-thousand-dollar SAS license just to open a SAS file. Thankfully R <span class="emphasis"><em>can</em></span> open many types of files, including files from other programs and databases. R even has its own program-specific formats that can help you save memory and time if you know that you will be working entirely in R. If you’d like to know more about all of your options for loading and saving data in R, see <a class="xref" href="apd.html" title="Appendix D. Loading and Saving Data in R">Appendix D</a>.</p><p><a class="xref" href="ch04.html" title="Chapter 4. R Notation">Chapter 4</a> will build upon the skills you learned in this chapter. Here, you learned how to store data in R. In <a class="xref" href="ch04.html" title="Chapter 4. R Notation">Chapter 4</a>, you will learn how to access values once they’ve been stored. You’ll also write two functions that will let you start using your deck, a shuffle function and a deal function.</p></div></section></body></html>
